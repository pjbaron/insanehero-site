{
"comment": [
        "// Minecraft Shader. Created by Reinder Nijhoff 2013",
        "// @reindernijhoff",
        "//",
        "// https://www.shadertoy.com/view/4ds3WS",
        "//",
        "// port of javascript minecraft: http://jsfiddle.net/uzMPU/",
        "// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256",
        "// combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs)",
        "//",
        "// All credit goes to inigo quilez!",
        "//"
    ],

"fragment": [
        "precision mediump float;",

        "#define SEALEVEL 0.",
        "#define MAXSTEPS 1024",
        "#define MAXRANGE 448.0",
        "#define CAMERA_SCREEN 3.0",
        "#define SUN_POWER 0.4",
        "#define SUN_SIZE 18.0",
        "#define SKY_COLOUR vec3(0.35,0.47,0.60)",
        "#define TREE_FREQUENCY 0.25",
        "#define FOLIAGE_SIZE 2.5",
        "#define TRUNK_TALL 3.5",
        "#define GAMMA 0.45",
        "//#define HOUSE",

        "#define MAT_GRASS 1",
        "#define MAT_DIRT 2",
        "#define MAT_STONE 4",
        "#define MAT_HOUSE 5",
        "#define MAT_ROOF 6",
        "#define MAT_TRUNK 7",
        "#define MAT_LEAVES 8",
        "#define MAT_WATER 9",
        "#define MAT_CLOUD 10",

        "uniform float uGlobalTime;",
        "uniform vec3 uCameraPos;",
        "uniform vec3 uCameraLookAt;",
        "uniform sampler2D uImageSampler;",

        "vec2 iResolution = vec2(1.0, 1.0);",

        "vec3 getTint( in int index )",
        "{",
        "    if (index ==  0) return vec3( 96./256.,  32./256.,-128./256.);",
        "    if (index ==  1) return vec3(-96./256., -64./256., -96./256.);",
        "    if (index ==  2) return vec3(-64./256., -16./256., -64./256.);",
        "    if (index ==  3) return vec3(  0./256.,  32./256.,   0./256.);",
        "    if (index ==  4) return vec3( 32./256.,  64./256.,  16./256.);",
        "    if (index ==  5) return vec3( 96./256.,  16./256.,  96./256.);",
        "    if (index ==  6) return vec3( 96./256.,  64./256., 160./256.);",
        "    if (index ==  7) return vec3( 83./256., 128./256., 192./256.);",
        "    if (index ==  8) return vec3( 96./256.,  32./256.,  32./256.);",
        "    if (index ==  9) return vec3(176./256.,  80./256.,  64./256.);",
        "    if (index == 10) return vec3(192./256., 128./256., 112./256.);",
        "    if (index == 11) return vec3(224./256., 128./256., 112./256.);",
        "    if (index == 12) return vec3(192./256., 128./256., 192./256.);",
        "    if (index == 13) return vec3(224./256., 192./256., 224./256.);",
        "    if (index == 14) return vec3(240./256., 224./256., 240./256.);",
        "    return vec3(248./256., 224./256., 255./256.);",
        "}",

        "float hash( in float n ) {",
        "    return fract(sin(n)*43758.5453123);",
        "}",
        "float hash( in vec3 x ) {",
        "    float n = dot( x, vec3(1.0,113.0,257.0) );",
        "    return fract(sin(n)*43758.5453123);",
        "}",
        "vec3 hash3( vec3 n ) {",
        "    return fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));",
        "}",

        "vec3 getMaterialColor( int i, vec2 coord ) {",
        "    // 16x16 texture coordinates",
        "    vec2 uv = floor( coord );",

        "    // get hash value for stippling and variation",
        "    float h = hash(uv.x + uv.y*347.0 + 4321.0 * float(i));",

        "    // stippling for grass, water, leaves, dirt",
        "    float br = 1. - h * (96./255.);",

        "    // dirt colour by default",
        "    vec3 color = vec3( 128./255., 64./255., 48./255.);",

        "    if (i == MAT_GRASS) {",
        "        // make jaggy edge for hanging grass",
        "        float xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);",
        "        if ( uv.y < (xm1 + 18.)) {",
        "            // top and grass hanging over edge into top of dirt below",
        "            color = vec3( 96./255., 196./255., 64./255.);",
        "        } else if (uv.y < (xm1 + 19.)) {",
        "            // dark shadow underneath hanging grass edge",
        "            br *= .36;",
        "        } else if (uv.y < (xm1 + 21.)) {",
        "            // light shadow underneath hanging grass edge",
        "            br *= .66;",
        "        }",
        "    } else",

        "    if (i == MAT_WATER) {",
        "        // water",
        "        h = hash(mod(uv.x + uGlobalTime * 0.0005, 16.0) + uv.y*347.0 + 4321.0 * float(i));",
        "        br = 1. - h * (96./255.);",
        "        color = vec3(  32./255.,  64./255., 192./255.);",
        "        br = br * 0.25 + 0.2;",
        "    } else",

        "    if (i == MAT_TRUNK) {",
        "        color = vec3( 103./255., 82./255.,  49./255.); // 0x675231;",
        "        if ( h < 0.5 ) {",
        "            // vertical lines in the stippling to suggest bark strips",
        "            br = br * (3.0 - mod(uv.x, 3.));",
        "        }",
        "    } else",

        "    if (i == MAT_LEAVES) {",
        "        if ( h < 0.7) {",
        "            color = vec3(  32./255., 128./255., 32./255.);",
        "        }",
        "        else {",
        "            color = vec3(  8./255., 64./255.,  8./255.);",
        "        }",
        "    } else",

        "    if (i == MAT_STONE) {",
        "        color = vec3( 96./255., 96./255., 104./255.);",
        "    } else",

        "#ifdef HOUSE",
        "    if (i == MAT_HOUSE) {",
        "        color = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;",
        "        if ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {",
        "            color = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;",
        "        }",
        "    } else",
        "#endif",

        "    if (i == MAT_CLOUD) {",
        "        color = vec3(0.65,0.68,0.7)*1.35;",
        "        br = 1.;",
        "    }",

        "    color *= br;",
        "    return color;",
        "}",

        "const mat3 m = mat3( 0.00,  0.80,  0.60,",
        "                    -0.80,  0.36, -0.48,",
        "                    -0.60, -0.48,  0.64 );",

        "float mapTerrain( vec2 p ) {",
        "    float f = texture2D( uImageSampler, fract(p * 0.0002) ).r;",
        "    return max(f * 50.0 + SEALEVEL, SEALEVEL);",
        "}",

        "bool map(in vec3 c ) {",
        "    vec3 p = c + 0.5;",
        "    vec2 fc = floor( c.xz * 0.05 );",
        "    vec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );",
        "    bool hit = false;",

        "    if ( h.z < TREE_FREQUENCY ) {",
        "        vec2 tp = floor( fc * 20. + mod( h.yx * 154.43125, 10. ) ) + 5.5;",
        "        float f = mapTerrain( tp );",
        "        if ( f > SEALEVEL ) {",
        "            if ( all( equal( tp, p.xz ) ) ) hit = c.y < f + TRUNK_TALL; // treetrunk",
        "            if ( distance( p, vec3( tp.x, f + (TRUNK_TALL + FOLIAGE_SIZE), tp.y ) ) < FOLIAGE_SIZE ) hit = true; // leaves",
        "        }",
        "    }",

        "    float f = mapTerrain( p.xz );",
        "    hit = c.y < f ? true:hit; // ground",

        "    //if ( c.y > 8. && sin( (c.y - 8.) * (3.1415 / 32.) ) * ( 10./(c.y-7.) ) > 0.6 )",
        "    //    hit = true; // clouds",

        "#ifdef HOUSE",
        "    vec2 hc = abs(c.xz - vec2( 32., 130.)); // house",
        "    if ( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {",
        "        hit = true;",
        "        if ( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {",
        "            hit = false;",
        "        }",
        "        if ( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {",
        "            hit = false;",
        "        }",
        "    }",
        "#endif",

        "    return hit;",
        "}",


        "int mapMaterial(in vec3 c ) {",
        "    int mat = 0;",
        "    vec3 p = c + 0.5;",

        "    float f = ceil( mapTerrain( p.xz ) );",

        "    if ( p.y <= f ) mat = MAT_GRASS;",
        "    else if ( p.y < f+3. ) mat = MAT_TRUNK;",
        "    else if ( p.y < f+10. ) mat = MAT_LEAVES;",
        "    else mat = MAT_CLOUD;",

        "#ifdef HOUSE",
        "    vec2 hc = abs(c.xz - vec2( 32., 130.));",
        "    if ( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {",
        "        mat = MAT_HOUSE;",
        "        if ( !map( c+vec3(0.,1.,0.) ) ) mat = MAT_ROOF;",
        "    }",
        "#endif",

        "    return mat;",
        "}",

        "// oVos and oDir are NOT used if return == 0, faster exit from castRay if no collision",
        "float castRay( in vec3 rayOrigin, in vec3 rayDir, out vec3 oVos, out vec3 oDir ) {",
        "    vec3 pos = floor(rayOrigin);",
        "    vec3 ri = 1.0 / rayDir;",
        "    vec3 rs = sign(rayDir);",
        "    vec3 dis = (pos - rayOrigin + 0.5 + rs * 0.5) * ri;",
        "    vec3 rsi = rs * ri;",
        "    vec3 moveMask = vec3(0.0);",
        "    for( int i=0; i<MAXSTEPS; i++ )",
        "    {",
        "        // which axis to move? (the largest one)",
        "        moveMask = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);",
        "        dis += moveMask * rsi;",
        "        pos += moveMask * rs;",
        "        if ( map(pos) ) {",
        "            // intersect the cube",
        "            vec3 mini = (pos - rayOrigin + 0.5 - 0.5 * vec3(rs)) * ri;",
        "            float t = max ( mini.x, max( mini.y, mini.z ) );",
        "            oDir = moveMask;",
        "            oVos = pos;",
        "            return t;",
        "        }",
        "        if ( distance(pos, rayOrigin) > MAXRANGE)",
        "            break;",
        "    }",
        "    return 0.;",
        "}",

        "float castVRay( in vec3 rayOrigin, in vec3 rayDir, in float maxDist ) {",

        "    vec3 pos = floor(rayOrigin);",
        "    vec3 ri = 1.0/rayDir;",
        "    vec3 rs = sign(rayDir);",
        "    vec3 dis = (pos-rayOrigin + 0.5 + rs*0.5) * ri;",
        "    for( int i=0; i<18; i++ )",
        "    {",
        "        if ( map(pos) ) { return 0.; }",
        "        vec3 moveMask = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);",
        "        dis += moveMask * rs * ri;",
        "        pos += moveMask * rs;",
        "    }",
        "    return 1.0;",
        "}",

        "varying vec2 v_texcoord;",

        "void main() {",
        "    //vec3 sundir = normalize( vec3(mod(uGlobalTime * .001, 2.0) - 1.0,0.6,0.7) );",
        "    vec3 sundir = normalize( vec3(-0.5,0.6,0.7) );",

        "    // convert texture coordinate into range -1..+1 in x and y directions",
        "    vec2 q = v_texcoord.xy / iResolution.xy;",
        "    vec2 p = -1.0 + 2.0*q;",
        "    // adjust for aspect ratio of the texture",
        "    p.x *= iResolution.x / iResolution.y;",

        "    // camera",
        "    float cameraBank = 0.0;",
        "    vec3 rayOrigin = uCameraPos;",
        "    vec3 target = uCameraLookAt;",
        "    //target.y = rayOrigin.y;",

        "    // build ray",
        "    vec3 ww = normalize(target - rayOrigin);",
        "    vec3 uu = normalize(cross( vec3(sin(cameraBank),cos(cameraBank),0.0), ww ));",
        "    vec3 vv = normalize(cross(ww,uu));",
        "    vec3 rayDir = normalize(p.x*uu + p.y*vv + CAMERA_SCREEN*ww);",

        "    // sky azimuth",
        "    float azi = exp(rayDir.y) - 1.0;",
        "    vec3 col = clamp(SKY_COLOUR + vec3(-azi * 0.2, -azi * 0.2, azi * 0.6), 0., 1.);",

        "    // sky sun glare",
        "    float sun = clamp(dot(sundir, rayDir), 0., 1.);",
        "    col = clamp(col + SUN_POWER * vec3(1.0, 1.0, 0.0) * pow( sun, SUN_SIZE ), 0., 1.);",

        "    // vos and dir are NOT used if t == 0, faster exit from castRay if no collision",
        "    vec3 vos, dir;",
        "    float t = castRay( rayOrigin, rayDir, vos, dir );",

        "    if ( t > 0. ) {",
        "        vec3 nor = -dir * sign(rayDir);",
        "        vec3 pos = rayOrigin + rayDir*t;",
        "        int mMat = mapMaterial( vos );",

        "        // map conversions, grass to stone or dirt or water",
        "        if ( mMat == MAT_GRASS) {",
        "            if ( map( vos + vec3(0., 1., 0. ) ) ) {",
        "                mMat = hash(vos) > 0.5 ? MAT_DIRT : MAT_STONE;",
        "                if ( map( vos + vec3(0., 2., 0. ) ) ) mMat = MAT_STONE;",
        "            }",
        "            if ( vos.y < SEALEVEL ) mMat = MAT_WATER;",
        "        }",

        "        vec3 mpos = mod( pos * 16., 16. );",
        "        // use normal of the cube face to determine where the texture comes from",
        "        vec2 textureCoord = (nor.y != 0.) ? mpos.xz : (nor.x != 0.) ? -mpos.zy + vec2(32., 32.) : -mpos.xy + vec2(32., 32.);",
        "        vec3 mCol = getMaterialColor( mMat, textureCoord );",

        "        // cube face catches the suns rays?",
        "        float dif = clamp( dot( nor, sundir ), 0.0, 1.0 );",
        "        float sha = 0.0;",
        "        if ( dif > 0.01 ) sha = castVRay( pos + nor * 0.01, sundir, 32.0 );",
        "        float bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );",
        "        float sky = 0.5 + 0.5 * nor.y;",

        "        vec3 lin = vec3(0.0);",
        "        lin += 4.0 * dif * vec3(1.) * (0.25+0.75*sha);",
        "        lin += 1.8 * bac * vec3(1.0,0.5,1.0);",
        "        lin += 4.0 * sky * vec3(0.4,0.51,0.85);",

        "        if ( mMat == MAT_CLOUD ) {",
        "            col = mix( col, mCol*lin*0.6, 0.3);",
        "        } else {",
        "            // atmospheric haze... equation obscures details just before the MAXRANGE distance (fooplot.com)",
        "            col = mix( mCol*lin*0.2, col, clamp(exp(distance(vos, rayOrigin) * 0.013 - 6.), 0., 1.) );",
        "        }",

        "        if (mMat == MAT_GRASS) {",
        "            int index = int(clamp(.40 * max(vos.y, SEALEVEL), 0., 16.));",
        "            col = clamp(col + 0.25 * getTint(index), 0., 1.);",
        "        }",
        "    }",

        "    col = pow( col, vec3(GAMMA) );",

        "    // contrast",
        "    col = col * 0.15 + 0.85 * col * col * (3.0 - 2.0 * col);",
        "    col = clamp( col, 0.0, 1.0 );",

        "    // vignetting",
        "    //col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );",

        "    gl_FragColor = vec4( col, 1.0 );",
        "}"

    ],

"vertex": [
        " attribute vec4 aPosition;",
        " varying vec2 v_texcoord;",
        " void main() {",
        "   gl_Position = aPosition;",
        "   v_texcoord = aPosition.xy * 0.5 + 0.5;",
        " }"
    ],

"attributes":
    [ "aPosition" ],
"uniforms":
    [ "uCameraPos", "uCameraLookAt", "uGlobalTime" ],
"samplers":
    [ "uImageSampler" ]
}