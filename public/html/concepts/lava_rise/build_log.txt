=== BUILD LOG: Lava Rise ===
Started: 2026-02-13T15:06:25.045790
Duration: 354.3s
Success: True

=== STDOUT ===
{"type":"system","subtype":"init","cwd":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise","session_id":"49ae1741-8f7d-46af-8795-41b99d501708","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","TeamCreate","TeamDelete","SendMessage","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-6","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","debug","developer-model","loom","loom-about","loom-architecture","loom-attempted-fixes","loom-callers","loom-central","loom-class","loom-clusters","loom-debug","loom-extract","loom-failure-log","loom-help","loom-hypothesis","loom-impact","loom-ingest","loom-intent","loom-issues","loom-last-failure","loom-module","loom-note","loom-orphans","loom-path","loom-resolve","loom-search-notes","loom-stats","loom-test","loom-tests","loom-todo-add","loom-todo-done","loom-todo-list","loom-todo-next","loom-todo-stats","loom-understand","loom-validate","compact","context","cost","init","pr-comments","release-notes","review","security-review","insights"],"apiKeySource":"none","claude_code_version":"2.1.39","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan"],"skills":["keybindings-help","debug","developer-model","loom"],"plugins":[],"uuid":"7e6dc98e-e6d2-4c80-ade5-f38df1f8ff0f","fast_mode_state":"off"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nI'll start by reading the plan and existing template files to understand the full implementation requirements."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"9574b291-7566-4502-ac43-f6bce09a1b6f"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017aEjwteBMeLvzUBnfK8pto","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\PLAN.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"a6e93b29-d36d-4120-a3da-c18db4fe6ce3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017aEjwteBMeLvzUBnfK8pto","type":"tool_result","content":"     1â†’The implementation plan is written to `PLAN.md`. Here's a summary of the key design decisions:\n     2â†’\n     3â†’**Architecture**: One new file (`js/lava-rise.js`) holds all game logic. `game.js` gets its demo code replaced with calls into the LavaRise systems. No changes to `input.js`, `audio.js`, or `poki.js`.\n     4â†’\n     5â†’**Coordinate System**: Fixed 400-unit virtual width, height derived from aspect ratio. This makes gameplay identical across screen sizes.\n     6â†’\n     7â†’**Core Loop**: Instant tap-to-jump (no hold delay -- better for mobile). Player alternates between walls with physics-based arcing jumps. Gravity pulls down, walls catch. Simple and snappy.\n     8â†’\n     9â†’**Difficulty**: Single `difficultyLevel` float (0-1 over 2 minutes) drives everything -- lava speed (60->150), wall gap (400->220), spawn density. Clean single-knob tuning.\n    10â†’\n    11â†’**Key Design Choices**:\n    12â†’- **No audio files** -- all SFX are procedurally generated via Web Audio oscillators = zero load time\n    13â†’- **No sprite sheets** -- player and all objects drawn with canvas primitives = instant start\n    14â†’- **Particle pooling** -- pre-allocated array of 200, reuse dead particles for performance\n    15â†’- **Coin slow-mo** -- 0.3s at 40% speed on collect, makes coin grabs feel impactful\n    16â†’- **Safe first 5 seconds** -- no obstacles, wide walls, brief invincibility for new players\n    17â†’- **0.8s input lockout** on game over to prevent accidental restart\n    18â†’\n    19â†’The plan has specific numbers for every speed, size, timing, and color -- ready for implementation without ambiguity."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"88876da9-f16b-45b4-8b2b-b60c7baa7dbf","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\PLAN.md","content":"The implementation plan is written to `PLAN.md`. Here's a summary of the key design decisions:\n\n**Architecture**: One new file (`js/lava-rise.js`) holds all game logic. `game.js` gets its demo code replaced with calls into the LavaRise systems. No changes to `input.js`, `audio.js`, or `poki.js`.\n\n**Coordinate System**: Fixed 400-unit virtual width, height derived from aspect ratio. This makes gameplay identical across screen sizes.\n\n**Core Loop**: Instant tap-to-jump (no hold delay -- better for mobile). Player alternates between walls with physics-based arcing jumps. Gravity pulls down, walls catch. Simple and snappy.\n\n**Difficulty**: Single `difficultyLevel` float (0-1 over 2 minutes) drives everything -- lava speed (60->150), wall gap (400->220), spawn density. Clean single-knob tuning.\n\n**Key Design Choices**:\n- **No audio files** -- all SFX are procedurally generated via Web Audio oscillators = zero load time\n- **No sprite sheets** -- player and all objects drawn with canvas primitives = instant start\n- **Particle pooling** -- pre-allocated array of 200, reuse dead particles for performance\n- **Coin slow-mo** -- 0.3s at 40% speed on collect, makes coin grabs feel impactful\n- **Safe first 5 seconds** -- no obstacles, wide walls, brief invincibility for new players\n- **0.8s input lockout** on game over to prevent accidental restart\n\nThe plan has specific numbers for every speed, size, timing, and color -- ready for implementation without ambiguity.","numLines":19,"startLine":1,"totalLines":19}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PJiorsnzHLEiDLmaLeeyLz","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"e43432b6-4e95-426a-a72d-5613ea3bddd7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PJiorsnzHLEiDLmaLeeyLz","type":"tool_result","content":"     1â†’/**\n     2â†’ * Game - State machine, rAF loop, Poki lifecycle\n     3â†’ * Override render/update methods for your actual game\n     4â†’ */\n     5â†’\n     6â†’import { InputManager } from './input.js';\n     7â†’\n     8â†’/** Config â€“ tweak per game */\n     9â†’export const Config = {\n    10â†’    adsEnabled: false,  // set true when ready for Poki ads\n    11â†’};\n    12â†’\n    13â†’export class Game {\n    14â†’    constructor(canvas) {\n    15â†’        this.canvas = canvas;\n    16â†’        this.ctx = canvas.getContext('2d');\n    17â†’        this.input = new InputManager(canvas);\n    18â†’        this.state = 'loading'; // loading -> menu -> playing -> gameover\n    19â†’        this.score = 0;\n    20â†’        this.lastTime = 0;\n    21â†’\n    22â†’        // Demo: bouncing dot\n    23â†’        this._dotX = 0;\n    24â†’        this._dotY = 0;\n    25â†’        this._dotVX = 200;\n    26â†’        this._dotVY = 150;\n    27â†’\n    28â†’        this._boundLoop = this._loop.bind(this);\n    29â†’        this._resize = this._resize.bind(this);\n    30â†’        window.addEventListener('resize', this._resize);\n    31â†’    }\n    32â†’\n    33â†’    async init() {\n    34â†’        await Poki.init();\n    35â†’        this._resize();\n    36â†’        await this.loadAssets();\n    37â†’        Poki.gameLoadingFinished();\n    38â†’        this.state = 'menu';\n    39â†’        this.lastTime = performance.now();\n    40â†’        requestAnimationFrame(this._boundLoop);\n    41â†’    }\n    42â†’\n    43â†’    /** Override to load your game assets */\n    44â†’    async loadAssets() {\n    45â†’        // Example: GameAudio.sfxFiles = { jump: 'assets/audio/jump.mp3' };\n    46â†’        // await GameAudio.loadSFX();\n    47â†’    }\n    48â†’\n    49â†’    _resize() {\n    50â†’        this.canvas.width = window.innerWidth;\n    51â†’        this.canvas.height = window.innerHeight;\n    52â†’    }\n    53â†’\n    54â†’    _loop(now) {\n    55â†’        var dt = (now - this.lastTime) / 1000;\n    56â†’        if (dt > 0.1) dt = 0.1; // Clamp to avoid spiral of death\n    57â†’        this.lastTime = now;\n    58â†’\n    59â†’        this.update(dt);\n    60â†’        this.render();\n    61â†’        this.input.endFrame();\n    62â†’\n    63â†’        requestAnimationFrame(this._boundLoop);\n    64â†’    }\n    65â†’\n    66â†’    // -------------------------------------------------------\n    67â†’    // State transitions with Poki lifecycle\n    68â†’    // -------------------------------------------------------\n    69â†’\n    70â†’    start() {\n    71â†’        this.state = 'playing';\n    72â†’        this.score = 0;\n    73â†’        this._dotX = this.canvas.width / 2;\n    74â†’        this._dotY = this.canvas.height / 2;\n    75â†’        GameAudio.initContext();\n    76â†’        GameAudio.resume();\n    77â†’        Poki.gameplayStart();\n    78â†’    }\n    79â†’\n    80â†’    gameOver() {\n    81â†’        this.state = 'gameover';\n    82â†’        Poki.gameplayStop();\n    83â†’    }\n    84â†’\n    85â†’    async restart() {\n    86â†’        this.state = 'playing';\n    87â†’        this.score = 0;\n    88â†’        this._dotX = this.canvas.width / 2;\n    89â†’        this._dotY = this.canvas.height / 2;\n    90â†’        if (Config.adsEnabled) {\n    91â†’            await Poki.commercialBreak(\n    92â†’                () => GameAudio.muteAll(),\n    93â†’                () => GameAudio.unmuteAll()\n    94â†’            );\n    95â†’        }\n    96â†’        Poki.gameplayStart();\n    97â†’    }\n    98â†’\n    99â†’    // -------------------------------------------------------\n   100â†’    // Update\n   101â†’    // -------------------------------------------------------\n   102â†’\n   103â†’    update(dt) {\n   104â†’        var confirm = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n   105â†’\n   106â†’        if (this.state === 'menu') {\n   107â†’            if (confirm) this.start();\n   108â†’        } else if (this.state === 'playing') {\n   109â†’            this.updatePlaying(dt);\n   110â†’        } else if (this.state === 'gameover') {\n   111â†’            if (confirm) this.restart();\n   112â†’        }\n   113â†’    }\n   114â†’\n   115â†’    /** Override for actual gameplay logic */\n   116â†’    updatePlaying(dt) {\n   117â†’        // Demo: bounce a dot\n   118â†’        this._dotX += this._dotVX * dt;\n   119â†’        this._dotY += this._dotVY * dt;\n   120â†’        if (this._dotX < 10) { this._dotVX = Math.abs(this._dotVX); this._dotX = 10; }\n   121â†’        if (this._dotX > this.canvas.width - 10) { this._dotVX = -Math.abs(this._dotVX); this._dotX = this.canvas.width - 10; }\n   122â†’        if (this._dotY < 10) { this._dotVY = Math.abs(this._dotVY); this._dotY = 10; }\n   123â†’        if (this._dotY > this.canvas.height - 10) { this._dotVY = -Math.abs(this._dotVY); this._dotY = this.canvas.height - 10; }\n   124â†’        this.score += dt * 10;\n   125â†’\n   126â†’        // Demo: gameover after 10 seconds\n   127â†’        if (this.score >= 100) this.gameOver();\n   128â†’    }\n   129â†’\n   130â†’    // -------------------------------------------------------\n   131â†’    // Render\n   132â†’    // -------------------------------------------------------\n   133â†’\n   134â†’    render() {\n   135â†’        if (this.state === 'loading') this.renderLoading();\n   136â†’        else if (this.state === 'menu') this.renderMenu();\n   137â†’        else if (this.state === 'playing') this.renderPlaying();\n   138â†’        else if (this.state === 'gameover') this.renderGameOver();\n   139â†’    }\n   140â†’\n   141â†’    renderLoading() {\n   142â†’        var ctx = this.ctx;\n   143â†’        ctx.fillStyle = '#000';\n   144â†’        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n   145â†’        ctx.fillStyle = '#fff';\n   146â†’        ctx.font = '24px sans-serif';\n   147â†’        ctx.textAlign = 'center';\n   148â†’        ctx.fillText('Loading...', this.canvas.width / 2, this.canvas.height / 2);\n   149â†’    }\n   150â†’\n   151â†’    renderMenu() {\n   152â†’        var ctx = this.ctx;\n   153â†’        ctx.fillStyle = '#000';\n   154â†’        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n   155â†’        ctx.fillStyle = '#fff';\n   156â†’        ctx.font = 'bold 48px sans-serif';\n   157â†’        ctx.textAlign = 'center';\n   158â†’        ctx.fillText('GAME TITLE', this.canvas.width / 2, this.canvas.height / 2 - 40);\n   159â†’        ctx.font = '20px sans-serif';\n   160â†’        ctx.fillStyle = '#aaa';\n   161â†’        ctx.fillText('Press Enter or Tap to Start', this.canvas.width / 2, this.canvas.height / 2 + 20);\n   162â†’    }\n   163â†’\n   164â†’    renderPlaying() {\n   165â†’        var ctx = this.ctx;\n   166â†’        ctx.fillStyle = '#000';\n   167â†’        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n   168â†’\n   169â†’        // Bouncing dot\n   170â†’        ctx.beginPath();\n   171â†’        ctx.arc(this._dotX, this._dotY, 10, 0, Math.PI * 2);\n   172â†’        ctx.fillStyle = '#0f0';\n   173â†’        ctx.fill();\n   174â†’\n   175â†’        // Score\n   176â†’        ctx.fillStyle = '#fff';\n   177â†’        ctx.font = '20px sans-serif';\n   178â†’        ctx.textAlign = 'left';\n   179â†’        ctx.fillText('Score: ' + Math.floor(this.score), 20, 40);\n   180â†’    }\n   181â†’\n   182â†’    renderGameOver() {\n   183â†’        var ctx = this.ctx;\n   184â†’        ctx.fillStyle = '#000';\n   185â†’        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n   186â†’        ctx.fillStyle = '#f00';\n   187â†’        ctx.font = 'bold 48px sans-serif';\n   188â†’        ctx.textAlign = 'center';\n   189â†’        ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);\n   190â†’        ctx.fillStyle = '#fff';\n   191â†’        ctx.font = '24px sans-serif';\n   192â†’        ctx.fillText('Score: ' + Math.floor(this.score), this.canvas.width / 2, this.canvas.height / 2 + 10);\n   193â†’        ctx.font = '20px sans-serif';\n   194â†’        ctx.fillStyle = '#aaa';\n   195â†’        ctx.fillText('Press Enter or Tap to Restart', this.canvas.width / 2, this.canvas.height / 2 + 50);\n   196â†’    }\n   197â†’}\n   198â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"f1cc8ec2-c768-4867-bcc3-f2f089f6332f","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js","content":"/**\n * Game - State machine, rAF loop, Poki lifecycle\n * Override render/update methods for your actual game\n */\n\nimport { InputManager } from './input.js';\n\n/** Config â€“ tweak per game */\nexport const Config = {\n    adsEnabled: false,  // set true when ready for Poki ads\n};\n\nexport class Game {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.input = new InputManager(canvas);\n        this.state = 'loading'; // loading -> menu -> playing -> gameover\n        this.score = 0;\n        this.lastTime = 0;\n\n        // Demo: bouncing dot\n        this._dotX = 0;\n        this._dotY = 0;\n        this._dotVX = 200;\n        this._dotVY = 150;\n\n        this._boundLoop = this._loop.bind(this);\n        this._resize = this._resize.bind(this);\n        window.addEventListener('resize', this._resize);\n    }\n\n    async init() {\n        await Poki.init();\n        this._resize();\n        await this.loadAssets();\n        Poki.gameLoadingFinished();\n        this.state = 'menu';\n        this.lastTime = performance.now();\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    /** Override to load your game assets */\n    async loadAssets() {\n        // Example: GameAudio.sfxFiles = { jump: 'assets/audio/jump.mp3' };\n        // await GameAudio.loadSFX();\n    }\n\n    _resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n\n    _loop(now) {\n        var dt = (now - this.lastTime) / 1000;\n        if (dt > 0.1) dt = 0.1; // Clamp to avoid spiral of death\n        this.lastTime = now;\n\n        this.update(dt);\n        this.render();\n        this.input.endFrame();\n\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    // -------------------------------------------------------\n    // State transitions with Poki lifecycle\n    // -------------------------------------------------------\n\n    start() {\n        this.state = 'playing';\n        this.score = 0;\n        this._dotX = this.canvas.width / 2;\n        this._dotY = this.canvas.height / 2;\n        GameAudio.initContext();\n        GameAudio.resume();\n        Poki.gameplayStart();\n    }\n\n    gameOver() {\n        this.state = 'gameover';\n        Poki.gameplayStop();\n    }\n\n    async restart() {\n        this.state = 'playing';\n        this.score = 0;\n        this._dotX = this.canvas.width / 2;\n        this._dotY = this.canvas.height / 2;\n        if (Config.adsEnabled) {\n            await Poki.commercialBreak(\n                () => GameAudio.muteAll(),\n                () => GameAudio.unmuteAll()\n            );\n        }\n        Poki.gameplayStart();\n    }\n\n    // -------------------------------------------------------\n    // Update\n    // -------------------------------------------------------\n\n    update(dt) {\n        var confirm = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n\n        if (this.state === 'menu') {\n            if (confirm) this.start();\n        } else if (this.state === 'playing') {\n            this.updatePlaying(dt);\n        } else if (this.state === 'gameover') {\n            if (confirm) this.restart();\n        }\n    }\n\n    /** Override for actual gameplay logic */\n    updatePlaying(dt) {\n        // Demo: bounce a dot\n        this._dotX += this._dotVX * dt;\n        this._dotY += this._dotVY * dt;\n        if (this._dotX < 10) { this._dotVX = Math.abs(this._dotVX); this._dotX = 10; }\n        if (this._dotX > this.canvas.width - 10) { this._dotVX = -Math.abs(this._dotVX); this._dotX = this.canvas.width - 10; }\n        if (this._dotY < 10) { this._dotVY = Math.abs(this._dotVY); this._dotY = 10; }\n        if (this._dotY > this.canvas.height - 10) { this._dotVY = -Math.abs(this._dotVY); this._dotY = this.canvas.height - 10; }\n        this.score += dt * 10;\n\n        // Demo: gameover after 10 seconds\n        if (this.score >= 100) this.gameOver();\n    }\n\n    // -------------------------------------------------------\n    // Render\n    // -------------------------------------------------------\n\n    render() {\n        if (this.state === 'loading') this.renderLoading();\n        else if (this.state === 'menu') this.renderMenu();\n        else if (this.state === 'playing') this.renderPlaying();\n        else if (this.state === 'gameover') this.renderGameOver();\n    }\n\n    renderLoading() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#fff';\n        ctx.font = '24px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('Loading...', this.canvas.width / 2, this.canvas.height / 2);\n    }\n\n    renderMenu() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#fff';\n        ctx.font = 'bold 48px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME TITLE', this.canvas.width / 2, this.canvas.height / 2 - 40);\n        ctx.font = '20px sans-serif';\n        ctx.fillStyle = '#aaa';\n        ctx.fillText('Press Enter or Tap to Start', this.canvas.width / 2, this.canvas.height / 2 + 20);\n    }\n\n    renderPlaying() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Bouncing dot\n        ctx.beginPath();\n        ctx.arc(this._dotX, this._dotY, 10, 0, Math.PI * 2);\n        ctx.fillStyle = '#0f0';\n        ctx.fill();\n\n        // Score\n        ctx.fillStyle = '#fff';\n        ctx.font = '20px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('Score: ' + Math.floor(this.score), 20, 40);\n    }\n\n    renderGameOver() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#f00';\n        ctx.font = 'bold 48px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);\n        ctx.fillStyle = '#fff';\n        ctx.font = '24px sans-serif';\n        ctx.fillText('Score: ' + Math.floor(this.score), this.canvas.width / 2, this.canvas.height / 2 + 10);\n        ctx.font = '20px sans-serif';\n        ctx.fillStyle = '#aaa';\n        ctx.fillText('Press Enter or Tap to Restart', this.canvas.width / 2, this.canvas.height / 2 + 50);\n    }\n}\n","numLines":198,"startLine":1,"totalLines":198}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PrdhCHQbDKrHq2cMJ8TsoW","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"7eb56951-bea1-4c78-af62-6f3381bdc369"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PrdhCHQbDKrHq2cMJ8TsoW","type":"tool_result","content":"     1â†’<!DOCTYPE html>\n     2â†’<html lang=\"en\">\n     3â†’<head>\n     4â†’    <meta charset=\"UTF-8\">\n     5â†’    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n     6â†’    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n     7â†’    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n     8â†’    <title>Game</title>\n     9â†’    <link rel=\"stylesheet\" href=\"css/styles.css\">\n    10â†’</head>\n    11â†’<body>\n    12â†’    <div id=\"game-container\">\n    13â†’        <canvas id=\"game-canvas\"></canvas>\n    14â†’    </div>\n    15â†’\n    16â†’    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    17â†’    <script src=\"js/poki.js\"></script>\n    18â†’    <script src=\"js/audio.js\"></script>\n    19â†’    <script type=\"module\" src=\"js/main.js\"></script>\n    20â†’</body>\n    21â†’</html>\n    22â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"e1ba9ac1-ba4e-4dd0-b174-21b1ec9e3ebf","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <title>Game</title>\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n</head>\n<body>\n    <div id=\"game-container\">\n        <canvas id=\"game-canvas\"></canvas>\n    </div>\n\n    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    <script src=\"js/poki.js\"></script>\n    <script src=\"js/audio.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>\n</body>\n</html>\n","numLines":22,"startLine":1,"totalLines":22}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CKzEb422rH2qgZLTKBVpjT","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\input.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"b14840e8-7ad2-4248-92a7-2665c5aa80e7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CKzEb422rH2qgZLTKBVpjT","type":"tool_result","content":"     1â†’/**\n     2â†’ * Input Manager\n     3â†’ * Keyboard + touch input with edge-triggered and continuous detection\n     4â†’ */\n     5â†’\n     6â†’export class InputManager {\n     7â†’    constructor(canvas) {\n     8â†’        this._pressed = new Set();\n     9â†’        this._justPressed = new Set();\n    10â†’        this._tapped = false;\n    11â†’\n    12â†’        this._onKeyDown = (e) => {\n    13â†’            if (!this._pressed.has(e.code)) {\n    14â†’                this._justPressed.add(e.code);\n    15â†’            }\n    16â†’            this._pressed.add(e.code);\n    17â†’            // Prevent scrolling on game keys\n    18â†’            if (e.code.startsWith('Arrow') || e.code === 'Space') {\n    19â†’                e.preventDefault();\n    20â†’            }\n    21â†’        };\n    22â†’\n    23â†’        this._onKeyUp = (e) => {\n    24â†’            this._pressed.delete(e.code);\n    25â†’        };\n    26â†’\n    27â†’        this._onTap = (e) => {\n    28â†’            this._tapped = true;\n    29â†’        };\n    30â†’\n    31â†’        window.addEventListener('keydown', this._onKeyDown);\n    32â†’        window.addEventListener('keyup', this._onKeyUp);\n    33â†’        canvas.addEventListener('click', this._onTap);\n    34â†’        canvas.addEventListener('touchstart', this._onTap, { passive: true });\n    35â†’    }\n    36â†’\n    37â†’    /** Continuous hold detection */\n    38â†’    isDown(code) {\n    39â†’        return this._pressed.has(code);\n    40â†’    }\n    41â†’\n    42â†’    /** Edge-triggered: true once per press, consumed by endFrame() */\n    43â†’    wasPressed(code) {\n    44â†’        return this._justPressed.has(code);\n    45â†’    }\n    46â†’\n    47â†’    /** True if canvas was clicked/tapped this frame */\n    48â†’    wasTapped() {\n    49â†’        return this._tapped;\n    50â†’    }\n    51â†’\n    52â†’    isLeft() {\n    53â†’        return this._pressed.has('ArrowLeft') || this._pressed.has('KeyA');\n    54â†’    }\n    55â†’\n    56â†’    isRight() {\n    57â†’        return this._pressed.has('ArrowRight') || this._pressed.has('KeyD');\n    58â†’    }\n    59â†’\n    60â†’    isUp() {\n    61â†’        return this._pressed.has('ArrowUp') || this._pressed.has('KeyW');\n    62â†’    }\n    63â†’\n    64â†’    isDownKey() {\n    65â†’        return this._pressed.has('ArrowDown') || this._pressed.has('KeyS');\n    66â†’    }\n    67â†’\n    68â†’    /** Call at end of each frame to reset edge-triggered state */\n    69â†’    endFrame() {\n    70â†’        this._justPressed.clear();\n    71â†’        this._tapped = false;\n    72â†’    }\n    73â†’\n    74â†’    dispose() {\n    75â†’        window.removeEventListener('keydown', this._onKeyDown);\n    76â†’        window.removeEventListener('keyup', this._onKeyUp);\n    77â†’        this._pressed.clear();\n    78â†’        this._justPressed.clear();\n    79â†’    }\n    80â†’}\n    81â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"0a4e544b-1248-4a44-a4c4-b59f116430ea","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\input.js","content":"/**\n * Input Manager\n * Keyboard + touch input with edge-triggered and continuous detection\n */\n\nexport class InputManager {\n    constructor(canvas) {\n        this._pressed = new Set();\n        this._justPressed = new Set();\n        this._tapped = false;\n\n        this._onKeyDown = (e) => {\n            if (!this._pressed.has(e.code)) {\n                this._justPressed.add(e.code);\n            }\n            this._pressed.add(e.code);\n            // Prevent scrolling on game keys\n            if (e.code.startsWith('Arrow') || e.code === 'Space') {\n                e.preventDefault();\n            }\n        };\n\n        this._onKeyUp = (e) => {\n            this._pressed.delete(e.code);\n        };\n\n        this._onTap = (e) => {\n            this._tapped = true;\n        };\n\n        window.addEventListener('keydown', this._onKeyDown);\n        window.addEventListener('keyup', this._onKeyUp);\n        canvas.addEventListener('click', this._onTap);\n        canvas.addEventListener('touchstart', this._onTap, { passive: true });\n    }\n\n    /** Continuous hold detection */\n    isDown(code) {\n        return this._pressed.has(code);\n    }\n\n    /** Edge-triggered: true once per press, consumed by endFrame() */\n    wasPressed(code) {\n        return this._justPressed.has(code);\n    }\n\n    /** True if canvas was clicked/tapped this frame */\n    wasTapped() {\n        return this._tapped;\n    }\n\n    isLeft() {\n        return this._pressed.has('ArrowLeft') || this._pressed.has('KeyA');\n    }\n\n    isRight() {\n        return this._pressed.has('ArrowRight') || this._pressed.has('KeyD');\n    }\n\n    isUp() {\n        return this._pressed.has('ArrowUp') || this._pressed.has('KeyW');\n    }\n\n    isDownKey() {\n        return this._pressed.has('ArrowDown') || this._pressed.has('KeyS');\n    }\n\n    /** Call at end of each frame to reset edge-triggered state */\n    endFrame() {\n        this._justPressed.clear();\n        this._tapped = false;\n    }\n\n    dispose() {\n        window.removeEventListener('keydown', this._onKeyDown);\n        window.removeEventListener('keyup', this._onKeyUp);\n        this._pressed.clear();\n        this._justPressed.clear();\n    }\n}\n","numLines":81,"startLine":1,"totalLines":81}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017xaZ5DwZNPu14ZgXeZFE7j","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\audio.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"e8d29f99-6007-437a-a4cf-8cd6f03283d3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017xaZ5DwZNPu14ZgXeZFE7j","type":"tool_result","content":"     1â†’/**\n     2â†’ * Audio System\n     3â†’ * Web Audio API for SFX, HTML5 Audio for streaming music\n     4â†’ * Global object (non-module), loaded before game modules\n     5â†’ */\n     6â†’\n     7â†’const GameAudio = {\n     8â†’    ctx: null,\n     9â†’    buffers: {},\n    10â†’    loaded: false,\n    11â†’    enabled: true,\n    12â†’    masterVolume: 0.7,\n    13â†’    musicVolume: 0.4,\n    14â†’    sfxVolume: 0.6,\n    15â†’    musicMuted: false,\n    16â†’    musicElement: null,\n    17â†’    musicPlaying: false,\n    18â†’    sfxGain: null,\n    19â†’\n    20â†’    // Game fills this before calling loadSFX()\n    21â†’    // e.g. { jump: 'assets/audio/jump.mp3', hit: 'assets/audio/hit.mp3' }\n    22â†’    sfxFiles: {},\n    23â†’\n    24â†’    /**\n    25â†’     * Create AudioContext (call on first user interaction)\n    26â†’     */\n    27â†’    initContext() {\n    28â†’        if (this.ctx) return;\n    29â†’\n    30â†’        // Load saved mute state\n    31â†’        try { var saved = localStorage.getItem('musicMuted'); if (saved !== null) this.musicMuted = saved === '1'; } catch (e) {}\n    32â†’\n    33â†’        try {\n    34â†’            this.ctx = new (window.AudioContext || window.webkitAudioContext)();\n    35â†’            this.sfxGain = this.ctx.createGain();\n    36â†’            this.sfxGain.gain.value = this.sfxVolume * this.masterVolume;\n    37â†’            this.sfxGain.connect(this.ctx.destination);\n    38â†’        } catch (e) {\n    39â†’            console.warn('Web Audio API not supported:', e);\n    40â†’            this.enabled = false;\n    41â†’        }\n    42â†’    },\n    43â†’\n    44â†’    /**\n    45â†’     * Resume suspended AudioContext (required after user gesture)\n    46â†’     */\n    47â†’    resume() {\n    48â†’        if (this.ctx && this.ctx.state === 'suspended') {\n    49â†’            this.ctx.resume();\n    50â†’        }\n    51â†’    },\n    52â†’\n    53â†’    /**\n    54â†’     * Fetch and decode all SFX mp3s into buffers\n    55â†’     */\n    56â†’    async loadSFX() {\n    57â†’        if (!this.ctx || !this.enabled) return;\n    58â†’\n    59â†’        var promises = Object.entries(this.sfxFiles).map(async ([name, path]) => {\n    60â†’            try {\n    61â†’                var response = await fetch(path);\n    62â†’                var arrayBuffer = await response.arrayBuffer();\n    63â†’                this.buffers[name] = await this.ctx.decodeAudioData(arrayBuffer);\n    64â†’            } catch (e) {\n    65â†’                console.warn('Audio: Failed to load ' + name + ':', e);\n    66â†’            }\n    67â†’        });\n    68â†’\n    69â†’        await Promise.all(promises);\n    70â†’        this.loaded = true;\n    71â†’    },\n    72â†’\n    73â†’    /**\n    74â†’     * Play a named SFX from decoded buffer\n    75â†’     * @param {string} name - Key from sfxFiles\n    76â†’     * @param {object} options - { volume, pitch }\n    77â†’     */\n    78â†’    play(name, options) {\n    79â†’        if (!this.enabled || !this.ctx || !this.sfxGain) return;\n    80â†’\n    81â†’        var buffer = this.buffers[name];\n    82â†’        if (!buffer) return;\n    83â†’\n    84â†’        var opts = options || {};\n    85â†’        var volume = opts.volume !== undefined ? opts.volume : 1.0;\n    86â†’        var pitch = opts.pitch !== undefined ? opts.pitch : 1.0;\n    87â†’\n    88â†’        var source = this.ctx.createBufferSource();\n    89â†’        source.buffer = buffer;\n    90â†’        source.playbackRate.value = pitch;\n    91â†’\n    92â†’        var gainNode = this.ctx.createGain();\n    93â†’        gainNode.gain.value = volume * this.sfxVolume * this.masterVolume;\n    94â†’\n    95â†’        source.connect(gainNode);\n    96â†’        gainNode.connect(this.ctx.destination);\n    97â†’        source.start(0);\n    98â†’    },\n    99â†’\n   100â†’    /**\n   101â†’     * Start streaming music (HTML5 Audio, preload='none' for instant game load)\n   102â†’     * @param {string} src - Path to music file, e.g. 'assets/audio/music.mp3'\n   103â†’     */\n   104â†’    playMusic(src) {\n   105â†’        if (this.musicMuted || this.musicPlaying) return;\n   106â†’\n   107â†’        var audio = new Audio();\n   108â†’        audio.preload = 'none';\n   109â†’        audio.loop = true;\n   110â†’        audio.volume = this.musicVolume * this.masterVolume;\n   111â†’\n   112â†’        this.musicElement = audio;\n   113â†’        this.musicPlaying = true;\n   114â†’\n   115â†’        var started = false;\n   116â†’        var self = this;\n   117â†’\n   118â†’        var startPlay = function() {\n   119â†’            if (started) return;\n   120â†’            started = true;\n   121â†’            audio.play().catch(function() {\n   122â†’                self.musicPlaying = false;\n   123â†’                self.musicElement = null;\n   124â†’            });\n   125â†’        };\n   126â†’\n   127â†’        audio.addEventListener('canplaythrough', startPlay, { once: true });\n   128â†’\n   129â†’        // Timeout fallback - don't wait forever\n   130â†’        setTimeout(startPlay, 3000);\n   131â†’\n   132â†’        audio.src = src;\n   133â†’    },\n   134â†’\n   135â†’    /**\n   136â†’     * Fade out and stop music over 1 second\n   137â†’     */\n   138â†’    stopMusic() {\n   139â†’        var audio = this.musicElement;\n   140â†’        if (!audio) return;\n   141â†’\n   142â†’        this.musicPlaying = false;\n   143â†’        this.musicElement = null;\n   144â†’\n   145â†’        var startVol = audio.volume;\n   146â†’        var fadeStart = performance.now();\n   147â†’        var fadeDuration = 1000;\n   148â†’\n   149â†’        var fade = function() {\n   150â†’            var elapsed = performance.now() - fadeStart;\n   151â†’            var t = Math.min(elapsed / fadeDuration, 1);\n   152â†’            audio.volume = startVol * (1 - t);\n   153â†’            if (t < 1) {\n   154â†’                requestAnimationFrame(fade);\n   155â†’            } else {\n   156â†’                audio.pause();\n   157â†’                audio.src = '';\n   158â†’            }\n   159â†’        };\n   160â†’        requestAnimationFrame(fade);\n   161â†’    },\n   162â†’\n   163â†’    /**\n   164â†’     * Mute everything (for Poki ads)\n   165â†’     */\n   166â†’    muteAll() {\n   167â†’        if (this.sfxGain) this.sfxGain.gain.value = 0;\n   168â†’        if (this.musicElement) this.musicElement.volume = 0;\n   169â†’    },\n   170â†’\n   171â†’    /**\n   172â†’     * Unmute everything (after Poki ads)\n   173â†’     */\n   174â†’    unmuteAll() {\n   175â†’        if (this.sfxGain) this.sfxGain.gain.value = this.sfxVolume * this.masterVolume;\n   176â†’        if (this.musicElement && !this.musicMuted) {\n   177â†’            this.musicElement.volume = this.musicVolume * this.masterVolume;\n   178â†’        }\n   179â†’    },\n   180â†’\n   181â†’    /**\n   182â†’     * Toggle music on/off (user control)\n   183â†’     */\n   184â†’    toggleMusic() {\n   185â†’        this.musicMuted = !this.musicMuted;\n   186â†’        try { localStorage.setItem('musicMuted', this.musicMuted ? '1' : '0'); } catch (e) {}\n   187â†’\n   188â†’        if (this.musicMuted) {\n   189â†’            if (this.musicElement) this.musicElement.volume = 0;\n   190â†’        } else {\n   191â†’            if (this.musicElement) {\n   192â†’                this.musicElement.volume = this.musicVolume * this.masterVolume;\n   193â†’            }\n   194â†’        }\n   195â†’    },\n   196â†’};\n   197â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"2b0670fe-703c-4c52-a0c8-611fb151eba9","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\audio.js","content":"/**\n * Audio System\n * Web Audio API for SFX, HTML5 Audio for streaming music\n * Global object (non-module), loaded before game modules\n */\n\nconst GameAudio = {\n    ctx: null,\n    buffers: {},\n    loaded: false,\n    enabled: true,\n    masterVolume: 0.7,\n    musicVolume: 0.4,\n    sfxVolume: 0.6,\n    musicMuted: false,\n    musicElement: null,\n    musicPlaying: false,\n    sfxGain: null,\n\n    // Game fills this before calling loadSFX()\n    // e.g. { jump: 'assets/audio/jump.mp3', hit: 'assets/audio/hit.mp3' }\n    sfxFiles: {},\n\n    /**\n     * Create AudioContext (call on first user interaction)\n     */\n    initContext() {\n        if (this.ctx) return;\n\n        // Load saved mute state\n        try { var saved = localStorage.getItem('musicMuted'); if (saved !== null) this.musicMuted = saved === '1'; } catch (e) {}\n\n        try {\n            this.ctx = new (window.AudioContext || window.webkitAudioContext)();\n            this.sfxGain = this.ctx.createGain();\n            this.sfxGain.gain.value = this.sfxVolume * this.masterVolume;\n            this.sfxGain.connect(this.ctx.destination);\n        } catch (e) {\n            console.warn('Web Audio API not supported:', e);\n            this.enabled = false;\n        }\n    },\n\n    /**\n     * Resume suspended AudioContext (required after user gesture)\n     */\n    resume() {\n        if (this.ctx && this.ctx.state === 'suspended') {\n            this.ctx.resume();\n        }\n    },\n\n    /**\n     * Fetch and decode all SFX mp3s into buffers\n     */\n    async loadSFX() {\n        if (!this.ctx || !this.enabled) return;\n\n        var promises = Object.entries(this.sfxFiles).map(async ([name, path]) => {\n            try {\n                var response = await fetch(path);\n                var arrayBuffer = await response.arrayBuffer();\n                this.buffers[name] = await this.ctx.decodeAudioData(arrayBuffer);\n            } catch (e) {\n                console.warn('Audio: Failed to load ' + name + ':', e);\n            }\n        });\n\n        await Promise.all(promises);\n        this.loaded = true;\n    },\n\n    /**\n     * Play a named SFX from decoded buffer\n     * @param {string} name - Key from sfxFiles\n     * @param {object} options - { volume, pitch }\n     */\n    play(name, options) {\n        if (!this.enabled || !this.ctx || !this.sfxGain) return;\n\n        var buffer = this.buffers[name];\n        if (!buffer) return;\n\n        var opts = options || {};\n        var volume = opts.volume !== undefined ? opts.volume : 1.0;\n        var pitch = opts.pitch !== undefined ? opts.pitch : 1.0;\n\n        var source = this.ctx.createBufferSource();\n        source.buffer = buffer;\n        source.playbackRate.value = pitch;\n\n        var gainNode = this.ctx.createGain();\n        gainNode.gain.value = volume * this.sfxVolume * this.masterVolume;\n\n        source.connect(gainNode);\n        gainNode.connect(this.ctx.destination);\n        source.start(0);\n    },\n\n    /**\n     * Start streaming music (HTML5 Audio, preload='none' for instant game load)\n     * @param {string} src - Path to music file, e.g. 'assets/audio/music.mp3'\n     */\n    playMusic(src) {\n        if (this.musicMuted || this.musicPlaying) return;\n\n        var audio = new Audio();\n        audio.preload = 'none';\n        audio.loop = true;\n        audio.volume = this.musicVolume * this.masterVolume;\n\n        this.musicElement = audio;\n        this.musicPlaying = true;\n\n        var started = false;\n        var self = this;\n\n        var startPlay = function() {\n            if (started) return;\n            started = true;\n            audio.play().catch(function() {\n                self.musicPlaying = false;\n                self.musicElement = null;\n            });\n        };\n\n        audio.addEventListener('canplaythrough', startPlay, { once: true });\n\n        // Timeout fallback - don't wait forever\n        setTimeout(startPlay, 3000);\n\n        audio.src = src;\n    },\n\n    /**\n     * Fade out and stop music over 1 second\n     */\n    stopMusic() {\n        var audio = this.musicElement;\n        if (!audio) return;\n\n        this.musicPlaying = false;\n        this.musicElement = null;\n\n        var startVol = audio.volume;\n        var fadeStart = performance.now();\n        var fadeDuration = 1000;\n\n        var fade = function() {\n            var elapsed = performance.now() - fadeStart;\n            var t = Math.min(elapsed / fadeDuration, 1);\n            audio.volume = startVol * (1 - t);\n            if (t < 1) {\n                requestAnimationFrame(fade);\n            } else {\n                audio.pause();\n                audio.src = '';\n            }\n        };\n        requestAnimationFrame(fade);\n    },\n\n    /**\n     * Mute everything (for Poki ads)\n     */\n    muteAll() {\n        if (this.sfxGain) this.sfxGain.gain.value = 0;\n        if (this.musicElement) this.musicElement.volume = 0;\n    },\n\n    /**\n     * Unmute everything (after Poki ads)\n     */\n    unmuteAll() {\n        if (this.sfxGain) this.sfxGain.gain.value = this.sfxVolume * this.masterVolume;\n        if (this.musicElement && !this.musicMuted) {\n            this.musicElement.volume = this.musicVolume * this.masterVolume;\n        }\n    },\n\n    /**\n     * Toggle music on/off (user control)\n     */\n    toggleMusic() {\n        this.musicMuted = !this.musicMuted;\n        try { localStorage.setItem('musicMuted', this.musicMuted ? '1' : '0'); } catch (e) {}\n\n        if (this.musicMuted) {\n            if (this.musicElement) this.musicElement.volume = 0;\n        } else {\n            if (this.musicElement) {\n                this.musicElement.volume = this.musicVolume * this.masterVolume;\n            }\n        }\n    },\n};\n","numLines":197,"startLine":1,"totalLines":197}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VdmfayZw392ktepnfqnhR6","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\poki.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"a5be907c-a58e-47a9-9f87-31c7737576e0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VdmfayZw392ktepnfqnhR6","type":"tool_result","content":"     1â†’/**\n     2â†’ * Poki SDK Integration\n     3â†’ * Wrapper for Poki platform features: ads, analytics, gameplay tracking\n     4â†’ */\n     5â†’\n     6â†’const Poki = {\n     7â†’    initialized: false,\n     8â†’    enabled: true,  // Set false to disable all Poki calls (for local testing without SDK)\n     9â†’    isPlaying: false,  // Track if we're in active gameplay\n    10â†’\n    11â†’    /**\n    12â†’     * Initialize the Poki SDK\n    13â†’     * Call this before starting the game\n    14â†’     */\n    15â†’    async init() {\n    16â†’        if (!this.enabled || typeof PokiSDK === 'undefined') {\n    17â†’            console.log('Poki SDK not available, running in offline mode');\n    18â†’            this.initialized = false;\n    19â†’            return true;  // Continue game anyway\n    20â†’        }\n    21â†’\n    22â†’        try {\n    23â†’            await PokiSDK.init();\n    24â†’            this.initialized = true;\n    25â†’            this.initVisibilityHandler();\n    26â†’            console.log('Poki SDK initialized');\n    27â†’            return true;\n    28â†’        } catch (e) {\n    29â†’            console.log('Poki SDK init failed, continuing anyway:', e);\n    30â†’            this.initialized = false;\n    31â†’            return true;  // Continue game anyway\n    32â†’        }\n    33â†’    },\n    34â†’\n    35â†’    /**\n    36â†’     * Signal that game loading is complete\n    37â†’     * Call after all assets are loaded and game is ready to play\n    38â†’     */\n    39â†’    gameLoadingFinished() {\n    40â†’        if (!this.initialized) return;\n    41â†’        try {\n    42â†’            PokiSDK.gameLoadingFinished();\n    43â†’        } catch (e) {\n    44â†’            console.warn('Poki gameLoadingFinished error:', e);\n    45â†’        }\n    46â†’    },\n    47â†’\n    48â†’    /**\n    49â†’     * Signal that gameplay has started\n    50â†’     * Call when player enters active gameplay\n    51â†’     */\n    52â†’    gameplayStart() {\n    53â†’        if (this.isPlaying) return;  // Already playing, avoid duplicate\n    54â†’        this.isPlaying = true;\n    55â†’        if (!this.initialized) return;\n    56â†’        try {\n    57â†’            PokiSDK.gameplayStart();\n    58â†’        } catch (e) {\n    59â†’            console.warn('Poki gameplayStart error:', e);\n    60â†’        }\n    61â†’    },\n    62â†’\n    63â†’    /**\n    64â†’     * Signal that gameplay has stopped\n    65â†’     * Call when player leaves active gameplay (menus, pause, game over)\n    66â†’     */\n    67â†’    gameplayStop() {\n    68â†’        if (!this.isPlaying) return;  // Already stopped, avoid duplicate\n    69â†’        this.isPlaying = false;\n    70â†’        if (!this.initialized) return;\n    71â†’        try {\n    72â†’            PokiSDK.gameplayStop();\n    73â†’        } catch (e) {\n    74â†’            console.warn('Poki gameplayStop error:', e);\n    75â†’        }\n    76â†’    },\n    77â†’\n    78â†’    /**\n    79â†’     * Set up visibility change listener for tab switching\n    80â†’     * Pauses gameplay tracking when tab is hidden\n    81â†’     * Note: Calls SDK directly to bypass duplicate checks (re-sending state is intentional)\n    82â†’     */\n    83â†’    initVisibilityHandler() {\n    84â†’        document.addEventListener('visibilitychange', () => {\n    85â†’            if (!this.initialized || !this.isPlaying) return;\n    86â†’\n    87â†’            try {\n    88â†’                if (document.hidden) {\n    89â†’                    PokiSDK.gameplayStop();\n    90â†’                } else {\n    91â†’                    PokiSDK.gameplayStart();\n    92â†’                }\n    93â†’            } catch (e) {}\n    94â†’        });\n    95â†’    },\n    96â†’\n    97â†’    /**\n    98â†’     * Request a commercial break (video ad)\n    99â†’     * Returns a promise that resolves when the ad is done (or skipped/failed)\n   100â†’     * Call at natural break points: between rounds, after defeat, etc.\n   101â†’     */\n   102â†’    async commercialBreak(muteAudioFn, unmuteAudioFn) {\n   103â†’        if (!this.initialized) return;\n   104â†’        try {\n   105â†’            // Only stop if currently playing (avoid duplicate calls)\n   106â†’            if (this.isPlaying) {\n   107â†’                PokiSDK.gameplayStop();\n   108â†’                this.isPlaying = false;\n   109â†’            }\n   110â†’            await PokiSDK.commercialBreak(() => {\n   111â†’                // SDK calls this when ad starts - mute game audio\n   112â†’                if (muteAudioFn) muteAudioFn();\n   113â†’            });\n   114â†’            // Ad finished/skipped - unmute game audio\n   115â†’            if (unmuteAudioFn) unmuteAudioFn();\n   116â†’        } catch (e) {\n   117â†’            console.warn('Poki commercialBreak error:', e);\n   118â†’            if (unmuteAudioFn) unmuteAudioFn();\n   119â†’        }\n   120â†’    },\n   121â†’\n   122â†’    /**\n   123â†’     * Request a rewarded ad (player chooses to watch for reward)\n   124â†’     * Returns true if the ad was watched completely, false otherwise\n   125â†’     */\n   126â†’    async rewardedBreak(muteAudioFn, unmuteAudioFn) {\n   127â†’        if (!this.initialized) return false;\n   128â†’        try {\n   129â†’            PokiSDK.gameplayStop();\n   130â†’            const success = await PokiSDK.rewardedBreak(() => {\n   131â†’                if (muteAudioFn) muteAudioFn();\n   132â†’            });\n   133â†’            if (unmuteAudioFn) unmuteAudioFn();\n   134â†’            return success;\n   135â†’        } catch (e) {\n   136â†’            console.warn('Poki rewardedBreak error:', e);\n   137â†’            if (unmuteAudioFn) unmuteAudioFn();\n   138â†’            return false;\n   139â†’        }\n   140â†’    },\n   141â†’\n   142â†’    /**\n   143â†’     * Check if rewarded ads are available\n   144â†’     */\n   145â†’    isRewardedAvailable() {\n   146â†’        if (!this.initialized) return false;\n   147â†’        try {\n   148â†’            return PokiSDK.rewardedBreak.isAvailable?.() ?? true;\n   149â†’        } catch (e) {\n   150â†’            return false;\n   151â†’        }\n   152â†’    }\n   153â†’};\n   154â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"c016825f-88ca-4945-a924-3553abbccbe1","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\poki.js","content":"/**\n * Poki SDK Integration\n * Wrapper for Poki platform features: ads, analytics, gameplay tracking\n */\n\nconst Poki = {\n    initialized: false,\n    enabled: true,  // Set false to disable all Poki calls (for local testing without SDK)\n    isPlaying: false,  // Track if we're in active gameplay\n\n    /**\n     * Initialize the Poki SDK\n     * Call this before starting the game\n     */\n    async init() {\n        if (!this.enabled || typeof PokiSDK === 'undefined') {\n            console.log('Poki SDK not available, running in offline mode');\n            this.initialized = false;\n            return true;  // Continue game anyway\n        }\n\n        try {\n            await PokiSDK.init();\n            this.initialized = true;\n            this.initVisibilityHandler();\n            console.log('Poki SDK initialized');\n            return true;\n        } catch (e) {\n            console.log('Poki SDK init failed, continuing anyway:', e);\n            this.initialized = false;\n            return true;  // Continue game anyway\n        }\n    },\n\n    /**\n     * Signal that game loading is complete\n     * Call after all assets are loaded and game is ready to play\n     */\n    gameLoadingFinished() {\n        if (!this.initialized) return;\n        try {\n            PokiSDK.gameLoadingFinished();\n        } catch (e) {\n            console.warn('Poki gameLoadingFinished error:', e);\n        }\n    },\n\n    /**\n     * Signal that gameplay has started\n     * Call when player enters active gameplay\n     */\n    gameplayStart() {\n        if (this.isPlaying) return;  // Already playing, avoid duplicate\n        this.isPlaying = true;\n        if (!this.initialized) return;\n        try {\n            PokiSDK.gameplayStart();\n        } catch (e) {\n            console.warn('Poki gameplayStart error:', e);\n        }\n    },\n\n    /**\n     * Signal that gameplay has stopped\n     * Call when player leaves active gameplay (menus, pause, game over)\n     */\n    gameplayStop() {\n        if (!this.isPlaying) return;  // Already stopped, avoid duplicate\n        this.isPlaying = false;\n        if (!this.initialized) return;\n        try {\n            PokiSDK.gameplayStop();\n        } catch (e) {\n            console.warn('Poki gameplayStop error:', e);\n        }\n    },\n\n    /**\n     * Set up visibility change listener for tab switching\n     * Pauses gameplay tracking when tab is hidden\n     * Note: Calls SDK directly to bypass duplicate checks (re-sending state is intentional)\n     */\n    initVisibilityHandler() {\n        document.addEventListener('visibilitychange', () => {\n            if (!this.initialized || !this.isPlaying) return;\n\n            try {\n                if (document.hidden) {\n                    PokiSDK.gameplayStop();\n                } else {\n                    PokiSDK.gameplayStart();\n                }\n            } catch (e) {}\n        });\n    },\n\n    /**\n     * Request a commercial break (video ad)\n     * Returns a promise that resolves when the ad is done (or skipped/failed)\n     * Call at natural break points: between rounds, after defeat, etc.\n     */\n    async commercialBreak(muteAudioFn, unmuteAudioFn) {\n        if (!this.initialized) return;\n        try {\n            // Only stop if currently playing (avoid duplicate calls)\n            if (this.isPlaying) {\n                PokiSDK.gameplayStop();\n                this.isPlaying = false;\n            }\n            await PokiSDK.commercialBreak(() => {\n                // SDK calls this when ad starts - mute game audio\n                if (muteAudioFn) muteAudioFn();\n            });\n            // Ad finished/skipped - unmute game audio\n            if (unmuteAudioFn) unmuteAudioFn();\n        } catch (e) {\n            console.warn('Poki commercialBreak error:', e);\n            if (unmuteAudioFn) unmuteAudioFn();\n        }\n    },\n\n    /**\n     * Request a rewarded ad (player chooses to watch for reward)\n     * Returns true if the ad was watched completely, false otherwise\n     */\n    async rewardedBreak(muteAudioFn, unmuteAudioFn) {\n        if (!this.initialized) return false;\n        try {\n            PokiSDK.gameplayStop();\n            const success = await PokiSDK.rewardedBreak(() => {\n                if (muteAudioFn) muteAudioFn();\n            });\n            if (unmuteAudioFn) unmuteAudioFn();\n            return success;\n        } catch (e) {\n            console.warn('Poki rewardedBreak error:', e);\n            if (unmuteAudioFn) unmuteAudioFn();\n            return false;\n        }\n    },\n\n    /**\n     * Check if rewarded ads are available\n     */\n    isRewardedAvailable() {\n        if (!this.initialized) return false;\n        try {\n            return PokiSDK.rewardedBreak.isAvailable?.() ?? true;\n        } catch (e) {\n            return false;\n        }\n    }\n};\n","numLines":154,"startLine":1,"totalLines":154}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01WbvPDSmJTCUs4V52T2g7Pb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014XiZwbifsCSudxTRKiddS9","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\main.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":5622,"cache_read_input_tokens":21683,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5622},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"3cb4a8e9-1905-4596-bc07-e33cdaf73a14"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014XiZwbifsCSudxTRKiddS9","type":"tool_result","content":"     1â†’import { Game } from './game.js';\n     2â†’\n     3â†’document.addEventListener('DOMContentLoaded', () => {\n     4â†’    const game = new Game(document.getElementById('game-canvas'));\n     5â†’    game.init();\n     6â†’});\n     7â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"3925f7a0-11d6-416f-af36-9b427f5a798f","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\main.js","content":"import { Game } from './game.js';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const game = new Game(document.getElementById('game-canvas'));\n    game.init();\n});\n","numLines":7,"startLine":1,"totalLines":7}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01JhTtLXe21z7W7CyZUiytTJ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a complete picture. Let me also check the CSS file quickly and then build the game."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":9147,"cache_read_input_tokens":27305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9147},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"cb7f31b9-9c5c-47a5-af61-7d3264e5db3d"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01JhTtLXe21z7W7CyZUiytTJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012PKFCjVBenMMZpvFiaCM5y","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\css\\styles.css"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":9147,"cache_read_input_tokens":27305,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":9147},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"5304f6e9-2a65-4fc7-9f2c-b1ccb44a6aba"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012PKFCjVBenMMZpvFiaCM5y","type":"tool_result","content":"     1â†’* {\n     2â†’    margin: 0;\n     3â†’    padding: 0;\n     4â†’    box-sizing: border-box;\n     5â†’}\n     6â†’\n     7â†’html, body {\n     8â†’    width: 100%;\n     9â†’    height: 100vh;\n    10â†’    height: 100dvh;\n    11â†’    overflow: hidden;\n    12â†’    background: #000;\n    13â†’    user-select: none;\n    14â†’    -webkit-user-select: none;\n    15â†’    -webkit-tap-highlight-color: transparent;\n    16â†’}\n    17â†’\n    18â†’#game-container {\n    19â†’    width: 100%;\n    20â†’    height: 100%;\n    21â†’    display: flex;\n    22â†’    align-items: center;\n    23â†’    justify-content: center;\n    24â†’    touch-action: none;\n    25â†’}\n    26â†’\n    27â†’#game-canvas {\n    28â†’    display: block;\n    29â†’    width: 100%;\n    30â†’    height: 100%;\n    31â†’}\n    32â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"8e5114df-190e-4859-b6eb-d65c2711e398","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\css\\styles.css","content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nhtml, body {\n    width: 100%;\n    height: 100vh;\n    height: 100dvh;\n    overflow: hidden;\n    background: #000;\n    user-select: none;\n    -webkit-user-select: none;\n    -webkit-tap-highlight-color: transparent;\n}\n\n#game-container {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    touch-action: none;\n}\n\n#game-canvas {\n    display: block;\n    width: 100%;\n    height: 100%;\n}\n","numLines":32,"startLine":1,"totalLines":32}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01EKxhEWqoMnxcnRCWFBQ3tj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AFv4ypahuffNN6zxKiMmaz","name":"TodoWrite","input":{"todos":[{"content":"Create js/lava-rise.js with all game systems","status":"in_progress","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"pending","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"pending","activeForm":"Updating index.html with new script tag"},{"content":"Test and polish the complete game","status":"pending","activeForm":"Testing and polishing the game"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":499,"cache_read_input_tokens":36452,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":499},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"77956ad7-f8f5-4a35-b378-a52ed42c3fb7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AFv4ypahuffNN6zxKiMmaz","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"dc9d7d36-0e6e-48cf-a066-16ff7ef8cfd8","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"in_progress","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"pending","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"pending","activeForm":"Updating index.html with new script tag"},{"content":"Test and polish the complete game","status":"pending","activeForm":"Testing and polishing the game"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01Fzac11EudiuVL192XZqYBp","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me build the complete `lava-rise.js` file with all game systems."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":253,"cache_read_input_tokens":36951,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"ef51e487-2b9c-470e-9bd0-aa866f0691cf"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01Fzac11EudiuVL192XZqYBp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MShqhhNbioZnj8TL2p9Jcb","name":"Write","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","content":"/**\n * Lava Rise - Complete game logic\n * Wall-jump between narrowing walls to outrun rising lava\n */\n\nvar LavaRise = (function() {\n    'use strict';\n\n    // -------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------\n    var VIRTUAL_W = 400;\n    var PLAYER_W = 18;\n    var PLAYER_H = 24;\n    var GRAVITY = 1400;\n    var JUMP_VY = -520;\n    var JUMP_VX_BASE = 400;\n    var WALL_THICKNESS = 40;\n    var COIN_RADIUS = 10;\n    var SPIKE_W = 20;\n    var SPIKE_H = 16;\n    var PLATFORM_W = 50;\n    var PLATFORM_H = 10;\n    var PARTICLE_POOL_SIZE = 200;\n    var SLOW_MO_DURATION = 0.3;\n    var SLOW_MO_FACTOR = 0.4;\n    var SAFE_TIME = 5.0;\n    var GAME_OVER_LOCKOUT = 0.8;\n    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    var LAVA_SPEED_MIN = 60;\n    var LAVA_SPEED_MAX = 150;\n    var WALL_GAP_MAX = 400;\n    var WALL_GAP_MIN = 220;\n    var CAMERA_LEAD = 0.3;\n    var CAMERA_SMOOTH = 4.0;\n\n    // Colors\n    var COL_BG_TOP = '#1a0a2e';\n    var COL_BG_BOT = '#0d0015';\n    var COL_WALL_LEFT = '#3a2a5c';\n    var COL_WALL_RIGHT = '#3a2a5c';\n    var COL_WALL_EDGE = '#6a4a9a';\n    var COL_PLAYER = '#00e5ff';\n    var COL_PLAYER_EYE = '#ffffff';\n    var COL_COIN = '#ffd700';\n    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    var COL_SPIKE = '#ff3366';\n    var COL_LAVA_TOP = '#ff4400';\n    var COL_LAVA_MID = '#ff2200';\n    var COL_LAVA_BOT = '#cc1100';\n    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    var COL_PLATFORM = '#8866bb';\n    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    var COL_SCORE = '#ffffff';\n    var COL_HEIGHT = '#aaaaaa';\n\n    // -------------------------------------------------------\n    // Procedural Audio\n    // -------------------------------------------------------\n    var SFX = {\n        _ctx: null,\n\n        init: function() {\n            if (GameAudio.ctx) {\n                this._ctx = GameAudio.ctx;\n            }\n        },\n\n        _ensureCtx: function() {\n            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n            return this._ctx;\n        },\n\n        jump: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(300, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.1);\n        },\n\n        wallHit: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'triangle';\n            osc.frequency.setValueAtTime(150, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.08);\n        },\n\n        coin: function(streak) {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var baseFreq = 800 + Math.min(streak, 10) * 80;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.15);\n            // Harmonic\n            var osc2 = ctx.createOscillator();\n            var gain2 = ctx.createGain();\n            osc2.type = 'sine';\n            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n            osc2.connect(gain2);\n            gain2.connect(ctx.destination);\n            osc2.start(ctx.currentTime + 0.05);\n            osc2.stop(ctx.currentTime + 0.2);\n        },\n\n        die: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sawtooth';\n            osc.frequency.setValueAtTime(400, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.4);\n            // Noise burst\n            var bufSize = ctx.sampleRate * 0.3;\n            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n            var data = buf.getChannelData(0);\n            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n            var noise = ctx.createBufferSource();\n            noise.buffer = buf;\n            var ng = ctx.createGain();\n            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            noise.connect(ng);\n            ng.connect(ctx.destination);\n            noise.start(ctx.currentTime);\n            noise.stop(ctx.currentTime + 0.3);\n        },\n\n        lavaWarn: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(100, ctx.currentTime);\n            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.3);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Particle Pool\n    // -------------------------------------------------------\n    function ParticlePool(size) {\n        this.pool = [];\n        for (var i = 0; i < size; i++) {\n            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n        }\n    }\n\n    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) {\n                p.alive = true;\n                p.x = x; p.y = y;\n                p.vx = vx; p.vy = vy;\n                p.life = life; p.maxLife = life;\n                p.r = r; p.g = g; p.b = b;\n                p.size = size || 2;\n                return p;\n            }\n        }\n        return null;\n    };\n\n    ParticlePool.prototype.update = function(dt) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            p.life -= dt;\n            if (p.life <= 0) { p.alive = false; continue; }\n            p.x += p.vx * dt;\n            p.y += p.vy * dt;\n            p.vy += 200 * dt; // light gravity on particles\n        }\n    };\n\n    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            var sz = p.size * scale * alpha;\n            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    ParticlePool.prototype.clear = function() {\n        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n    };\n\n    // -------------------------------------------------------\n    // Score Popup Pool\n    // -------------------------------------------------------\n    function PopupPool() {\n        this.popups = [];\n    }\n\n    PopupPool.prototype.spawn = function(x, y, text, color) {\n        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n    };\n\n    PopupPool.prototype.update = function(dt) {\n        for (var i = this.popups.length - 1; i >= 0; i--) {\n            var p = this.popups[i];\n            p.life -= dt;\n            p.y -= 60 * dt;\n            if (p.life <= 0) this.popups.splice(i, 1);\n        }\n    };\n\n    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.popups.length; i++) {\n            var p = this.popups[i];\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = p.color;\n            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText(p.text, sx, sy);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    // -------------------------------------------------------\n    // Main Game State\n    // -------------------------------------------------------\n    function State() {\n        this.reset();\n        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n        this.popups = new PopupPool();\n        this.highScore = 0;\n        this.totalCoins = 0;\n        try {\n            var hs = localStorage.getItem('lavarise_hs');\n            if (hs) this.highScore = parseInt(hs, 10) || 0;\n            var tc = localStorage.getItem('lavarise_coins');\n            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n        } catch(e) {}\n    }\n\n    State.prototype.reset = function() {\n        this.playTime = 0;\n        this.difficultyLevel = 0;\n        this.score = 0;\n        this.heightScore = 0;\n        this.coinScore = 0;\n        this.coinStreak = 0;\n        this.coinStreakTimer = 0;\n\n        // Player\n        this.px = VIRTUAL_W * 0.25;\n        this.py = 0;\n        this.pvx = 0;\n        this.pvy = 0;\n        this.pOnWall = 'left'; // 'left', 'right', 'air'\n        this.pFacing = 1; // 1=right, -1=left\n        this.pAlive = true;\n        this.pInvincible = 0;\n        this.pSquash = 1.0; // squash-stretch factor\n\n        // Camera\n        this.camY = 0;\n        this.camTargetY = 0;\n\n        // Lava\n        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n        this.lavaSpeed = LAVA_SPEED_MIN;\n        this.lavaWarnTimer = 0;\n\n        // Walls\n        this.wallGap = WALL_GAP_MAX;\n        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n\n        // Obstacles and coins\n        this.obstacles = [];\n        this.coins = [];\n        this.lastSpawnY = 0;\n        this.spawnInterval = 120;\n\n        // Effects\n        this.slowMoTimer = 0;\n        this.shakeAmount = 0;\n        this.shakeTimer = 0;\n        this.gameOverTimer = 0;\n        this.flashAlpha = 0;\n\n        if (this.particles) this.particles.clear();\n        if (this.popups) this.popups = new PopupPool();\n    };\n\n    // -------------------------------------------------------\n    // Game Logic\n    // -------------------------------------------------------\n\n    State.prototype.initGame = function() {\n        this.reset();\n        // Player starts on left wall, slightly above where lava will begin\n        this.py = -50;\n        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n        this.pOnWall = 'left';\n        this.pFacing = 1;\n        this.pInvincible = SAFE_TIME;\n        this.camY = this.py - 200;\n        this.camTargetY = this.camY;\n        this.lavaY = 200; // starts below player\n\n        // Seed some coins in the safe zone\n        this._spawnCoin(-100);\n        this._spawnCoin(-220);\n        this._spawnCoin(-350);\n\n        SFX.init();\n    };\n\n    State.prototype._getWallGap = function() {\n        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n    };\n\n    State.prototype._getWallLeft = function() {\n        return (VIRTUAL_W - this._getWallGap()) / 2;\n    };\n\n    State.prototype._getWallRight = function() {\n        return (VIRTUAL_W + this._getWallGap()) / 2;\n    };\n\n    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });\n        } else {\n            // Crumbling ledge\n            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n            this.obstacles.push({\n                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n                side: side2, timer: 0, crumbling: false, fallen: false\n            });\n        }\n    };\n\n    State.prototype.update = function(dt, tapped) {\n        if (!this.pAlive) return;\n\n        // Slow-mo\n        var effectiveDt = dt;\n        if (this.slowMoTimer > 0) {\n            this.slowMoTimer -= dt;\n            effectiveDt = dt * SLOW_MO_FACTOR;\n        }\n\n        this.playTime += effectiveDt;\n        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n\n        // Invincibility\n        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n\n        // Coin streak timeout\n        if (this.coinStreakTimer > 0) {\n            this.coinStreakTimer -= effectiveDt;\n            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n        }\n\n        // Wall narrowing\n        this.wallGap = this._getWallGap();\n        this.wallLeft = this._getWallLeft();\n        this.wallRight = this._getWallRight();\n\n        // Lava rise\n        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n\n        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {\n            this.lavaWarnTimer -= effectiveDt;\n            if (this.lavaWarnTimer <= 0) {\n                SFX.lavaWarn();\n                this.lavaWarnTimer = 0.5;\n            }\n        }\n\n        // Jump input\n        if (tapped && this.pOnWall !== 'air') {\n            this._jump();\n        }\n\n        // Physics\n        if (this.pOnWall === 'air') {\n            this.pvy += GRAVITY * effectiveDt;\n            this.px += this.pvx * effectiveDt;\n            this.py += this.pvy * effectiveDt;\n\n            // Wall collision\n            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n\n            if (this.px <= leftEdge) {\n                this.px = leftEdge;\n                this.pOnWall = 'left';\n                this.pFacing = 1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('left');\n            } else if (this.px >= rightEdge) {\n                this.px = rightEdge;\n                this.pOnWall = 'right';\n                this.pFacing = -1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('right');\n            }\n\n            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n        } else {\n            // On wall - slide down slowly\n            this.pvy = 30; // gentle slide\n            this.py += this.pvy * effectiveDt;\n\n            // Keep within wall bounds\n            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n            if (this.pOnWall === 'left') this.px = le;\n            else this.px = re;\n        }\n\n        // Squash recovery\n        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n\n        // Obstacle updates\n        this._updateObstacles(effectiveDt);\n\n        // Coin collection\n        this._updateCoins(effectiveDt);\n\n        // Collision with obstacles\n        if (this.pInvincible <= 0) {\n            this._checkObstacleCollisions();\n        }\n\n        // Lava death\n        if (this.py > this.lavaY - PLAYER_H / 2) {\n            this._die('lava');\n            return;\n        }\n\n        // Spawn new content ahead\n        this._spawnContent();\n\n        // Height score (negative Y = higher)\n        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n        this.score = this.heightScore + this.coinScore;\n\n        // Camera\n        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n\n        // Cleanup off-screen objects\n        this._cleanup();\n\n        // Effects\n        this.shakeTimer -= effectiveDt;\n        if (this.shakeTimer < 0) this.shakeTimer = 0;\n        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n\n        this.flashAlpha -= effectiveDt * 3;\n        if (this.flashAlpha < 0) this.flashAlpha = 0;\n\n        // Particles\n        this.particles.update(effectiveDt);\n        this.popups.update(effectiveDt);\n\n        // Lava particles\n        this._spawnLavaParticles(effectiveDt);\n    };\n\n    State.prototype._jump = function() {\n        var dir = this.pOnWall === 'left' ? 1 : -1;\n        this.pvx = JUMP_VX_BASE * dir;\n        this.pvy = JUMP_VY;\n        this.pOnWall = 'air';\n        this.pFacing = dir;\n        this.pSquash = 1.4; // stretch on jump\n        SFX.jump();\n\n        // Jump particles\n        for (var i = 0; i < 5; i++) {\n            var angle = Math.random() * Math.PI - Math.PI / 2;\n            var speed = 50 + Math.random() * 80;\n            this.particles.spawn(\n                this.px, this.py,\n                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n                0.3 + Math.random() * 0.2,\n                0, 229, 255, 3\n            );\n        }\n    };\n\n    State.prototype._spawnWallParticles = function(side) {\n        for (var i = 0; i < 6; i++) {\n            var dir = side === 'left' ? 1 : -1;\n            this.particles.spawn(\n                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n                0.2 + Math.random() * 0.2,\n                100, 80, 160, 3\n            );\n        }\n    };\n\n    State.prototype._updateObstacles = function(dt) {\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'platform') {\n                obs.x += obs.speed * obs.dir * dt;\n                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n            }\n            if (obs.type === 'crumble' && obs.crumbling) {\n                obs.timer += dt;\n                if (obs.timer > 0.5) obs.fallen = true;\n            }\n        }\n    };\n\n    State.prototype._updateCoins = function(dt) {\n        var px = this.px, py = this.py;\n        for (var i = 0; i < this.coins.length; i++) {\n            var c = this.coins[i];\n            if (c.collected) continue;\n            c.bobPhase += dt * 3;\n\n            var dx = px - c.x;\n            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n            var dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n                c.collected = true;\n                this.coinStreak++;\n                this.coinStreakTimer = 2.0;\n                var points = 10 * Math.min(this.coinStreak, 10);\n                this.coinScore += points;\n                this.totalCoins++;\n                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n\n                // Slow-mo\n                this.slowMoTimer = SLOW_MO_DURATION;\n\n                // Effects\n                this.flashAlpha = 0.3;\n                SFX.coin(this.coinStreak);\n                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n\n                // Coin burst particles\n                for (var j = 0; j < 8; j++) {\n                    var angle = (j / 8) * Math.PI * 2;\n                    this.particles.spawn(\n                        c.x, c.y,\n                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n                        0.4, 255, 215, 0, 3\n                    );\n                }\n            }\n        }\n    };\n\n    State.prototype._checkObstacleCollisions = function() {\n        var px = this.px, py = this.py;\n        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'crumble' && obs.fallen) continue;\n\n            if (obs.type === 'spike') {\n                // AABB\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    this._die('spike');\n                    return;\n                }\n            }\n\n            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n                // Land on top\n                if (this.pvy > 0 && this.pOnWall === 'air') {\n                    if (pl < obs.x + obs.w && pr > obs.x &&\n                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n                        py - ph / 2 < obs.y) {\n                        // Landing on platform\n                        // For crumbling, start crumble timer\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n                // Side collision with platform acts like a small wall\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    // Push player out horizontally if mostly horizontal collision\n                    var overlapL = pr - obs.x;\n                    var overlapR = obs.x + obs.w - pl;\n                    var overlapT = pb - obs.y;\n                    var overlapB = obs.y + obs.h - pt;\n                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n                    if (minOverlap === overlapT && this.pvy > 0) {\n                        // Land on top\n                        this.py = obs.y - ph / 2;\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    State.prototype._die = function(cause) {\n        if (!this.pAlive) return;\n        this.pAlive = false;\n        SFX.die();\n        this.shakeAmount = 8;\n        this.shakeTimer = 0.4;\n        this.flashAlpha = 0.5;\n        this.gameOverTimer = 0;\n\n        // Death particles\n        for (var i = 0; i < 20; i++) {\n            var angle = (i / 20) * Math.PI * 2;\n            var speed = 80 + Math.random() * 120;\n            var r = cause === 'lava' ? 255 : 255;\n            var g = cause === 'lava' ? 68 : 51;\n            var b = cause === 'lava' ? 0 : 102;\n            this.particles.spawn(\n                this.px, this.py,\n                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n                0.5 + Math.random() * 0.3,\n                r, g, b, 4\n            );\n        }\n\n        // Save high score\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n        }\n    };\n\n    State.prototype._spawnContent = function() {\n        // Spawn ahead of camera (negative Y is up)\n        var spawnAhead = this.camY - 500;\n        while (this.lastSpawnY > spawnAhead) {\n            this.lastSpawnY -= this.spawnInterval;\n\n            // Don't spawn obstacles during safe time\n            if (this.playTime > SAFE_TIME) {\n                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n                if (Math.random() < obstacleChance) {\n                    this._spawnObstacle(this.lastSpawnY);\n                }\n            }\n\n            // Always spawn coins (good density)\n            if (Math.random() < 0.5) {\n                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n            }\n\n            // Decrease spawn interval with difficulty\n            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n        }\n    };\n\n    var _lavaParticleTimer = 0;\n    State.prototype._spawnLavaParticles = function(dt) {\n        _lavaParticleTimer += dt;\n        if (_lavaParticleTimer < 0.05) return;\n        _lavaParticleTimer = 0;\n\n        // Spawn bubbles along lava surface\n        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n        this.particles.spawn(\n            x, this.lavaY,\n            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n            0.5 + Math.random() * 0.5,\n            255, Math.floor(40 + Math.random() * 60), 0, 4\n        );\n    };\n\n    State.prototype._cleanup = function() {\n        var below = this.lavaY + 100;\n        // Remove coins below lava\n        for (var i = this.coins.length - 1; i >= 0; i--) {\n            if (this.coins[i].y > below || this.coins[i].collected) {\n                this.coins.splice(i, 1);\n            }\n        }\n        // Remove obstacles below lava\n        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n            if (this.obstacles[j].y > below) {\n                this.obstacles.splice(j, 1);\n            }\n        }\n    };\n\n    // -------------------------------------------------------\n    // Rendering\n    // -------------------------------------------------------\n\n    function Renderer() {}\n\n    Renderer.prototype.render = function(ctx, canvas, state) {\n        var cw = canvas.width;\n        var ch = canvas.height;\n\n        // Virtual coordinate mapping\n        var scale = cw / VIRTUAL_W;\n        var virtualH = ch / scale;\n        var offsetX = 0;\n\n        // Screen shake\n        var shakeX = 0, shakeY = 0;\n        if (state.shakeTimer > 0) {\n            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n        }\n\n        ctx.save();\n        ctx.translate(shakeX, shakeY);\n\n        // Background gradient\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, COL_BG_BOT);\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n\n        // Background stars (parallax)\n        this._renderStars(ctx, cw, ch, state.camY);\n\n        // Walls\n        this._renderWalls(ctx, state, scale, offsetX, ch);\n\n        // Obstacles\n        this._renderObstacles(ctx, state, scale, offsetX);\n\n        // Coins\n        this._renderCoins(ctx, state, scale, offsetX);\n\n        // Player\n        if (state.pAlive) {\n            this._renderPlayer(ctx, state, scale, offsetX);\n        }\n\n        // Particles\n        state.particles.render(ctx, state.camY, scale, offsetX);\n\n        // Lava\n        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n\n        // Popups\n        state.popups.render(ctx, state.camY, scale, offsetX);\n\n        ctx.restore();\n\n        // Flash overlay\n        if (state.flashAlpha > 0) {\n            ctx.globalAlpha = state.flashAlpha;\n            ctx.fillStyle = '#fff';\n            ctx.fillRect(0, 0, cw, ch);\n            ctx.globalAlpha = 1;\n        }\n\n        // HUD (not affected by shake)\n        this._renderHUD(ctx, cw, ch, state);\n    };\n\n    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n        // Simple deterministic stars\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        var seed = 42;\n        for (var i = 0; i < 40; i++) {\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sx = (seed % cw);\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sy = (seed % (ch * 3));\n            var parallax = 0.05;\n            var screenY = (sy - camY * parallax) % (ch * 3);\n            if (screenY < 0) screenY += ch * 3;\n            if (screenY < ch) {\n                var size = 1 + (i % 3);\n                ctx.fillRect(sx, screenY, size, size);\n            }\n        }\n    };\n\n    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n        var camY = state.camY;\n        var topY = 0;\n        var botY = ch;\n\n        // Left wall\n        var lwScreen = state.wallLeft * scale + offsetX;\n        var lwWidth = (WALL_THICKNESS) * scale;\n        ctx.fillStyle = COL_WALL_LEFT;\n        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n\n        // Right wall\n        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n        ctx.fillStyle = COL_WALL_RIGHT;\n        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n\n        // Wall bricks pattern\n        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n        var brickH = 20 * scale;\n        var startBrickY = Math.floor(camY / 20) * 20;\n        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n            var sy = (by - camY) * scale;\n            var offset = ((by / 20) % 2) * 10 * scale;\n            // Left wall bricks\n            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n                ctx.fillRect(bx + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n            // Right wall bricks\n            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n        }\n    };\n\n    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.obstacles.length; i++) {\n            var obs = state.obstacles[i];\n            var sx = obs.x * scale + offsetX;\n            var sy = (obs.y - camY) * scale;\n            var sw = obs.w * scale;\n            var sh = obs.h * scale;\n\n            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n\n            if (obs.type === 'spike') {\n                ctx.fillStyle = COL_SPIKE;\n                ctx.beginPath();\n                if (obs.side === 'left') {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                } else {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowColor = COL_SPIKE;\n                ctx.shadowBlur = 6 * scale;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            } else if (obs.type === 'platform') {\n                ctx.fillStyle = COL_PLATFORM;\n                ctx.fillRect(sx, sy, sw, sh);\n                // Top highlight\n                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n                ctx.fillRect(sx, sy, sw, 2 * scale);\n            } else if (obs.type === 'crumble') {\n                if (obs.fallen) continue;\n                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n                // Shake if crumbling\n                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n                ctx.globalAlpha = 1;\n            }\n        }\n    };\n\n    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.coins.length; i++) {\n            var c = state.coins[i];\n            if (c.collected) continue;\n            var sx = c.x * scale + offsetX;\n            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n            var sr = COIN_RADIUS * scale;\n\n            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n\n            // Glow\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN_GLOW;\n            ctx.fill();\n\n            // Coin body\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN;\n            ctx.fill();\n\n            // Shine\n            ctx.beginPath();\n            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.fill();\n        }\n    };\n\n    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n        var sx = state.px * scale + offsetX;\n        var sy = (state.py - state.camY) * scale;\n        var sw = PLAYER_W * scale;\n        var sh = PLAYER_H * scale;\n\n        // Invincibility blink\n        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n            ctx.globalAlpha = 0.5;\n        }\n\n        // Squash-stretch\n        var squashX = 1 / state.pSquash;\n        var squashY = state.pSquash;\n\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.scale(squashX, squashY);\n\n        // Body\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 8 * scale;\n        var bodyW = sw;\n        var bodyH = sh;\n        // Rounded rectangle body\n        var r = 4 * scale;\n        ctx.beginPath();\n        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Eyes\n        var eyeOffX = state.pFacing * 3 * scale;\n        var eyeY = -3 * scale;\n        ctx.fillStyle = COL_PLAYER_EYE;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils (look in movement direction)\n        ctx.fillStyle = '#222';\n        var pupilOff = state.pFacing * 1 * scale;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n        ctx.globalAlpha = 1;\n    };\n\n    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n        var lavaScreenY = (state.lavaY - state.camY) * scale;\n        if (lavaScreenY > ch + 50) return;\n\n        var topY = Math.max(0, lavaScreenY - 10 * scale);\n\n        // Lava glow above surface\n        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n\n        // Lava surface wave\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        ctx.lineTo(0, lavaScreenY);\n        var waveTime = state.playTime * 2;\n        for (var x = 0; x <= cw; x += 4) {\n            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n            ctx.lineTo(x, waveY);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n\n        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Surface highlight\n        ctx.strokeStyle = '#ff8800';\n        ctx.lineWidth = 2 * scale;\n        ctx.beginPath();\n        for (var x2 = 0; x2 <= cw; x2 += 4) {\n            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n            if (x2 === 0) ctx.moveTo(x2, waveY2);\n            else ctx.lineTo(x2, waveY2);\n        }\n        ctx.stroke();\n    };\n\n    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n        var pad = Math.max(12, cw * 0.03);\n        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n\n        // Score\n        ctx.fillStyle = COL_SCORE;\n        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n\n        // Height indicator\n        ctx.fillStyle = COL_HEIGHT;\n        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n\n        // Coin streak\n        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n            ctx.globalAlpha = 1;\n        }\n\n        // High score (small, top right)\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n        }\n\n        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Menu / Game Over rendering\n    // -------------------------------------------------------\n\n    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n        // Background\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, '#1a0505');\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(0, 0, cw, ch);\n\n        // Decorative lava at bottom\n        var lavaH = ch * 0.25;\n        var lavaTop = ch - lavaH;\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        for (var x = 0; x <= cw; x += 4) {\n            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n            ctx.lineTo(x, wy);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Glow\n        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n\n        // Title\n        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n        var centerY = ch * 0.32;\n        ctx.fillStyle = COL_LAVA_TOP;\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.shadowColor = '#ff4400';\n        ctx.shadowBlur = 20;\n        ctx.fillText('LAVA RISE', cw / 2, centerY);\n        ctx.shadowBlur = 0;\n\n        // Subtitle\n        ctx.fillStyle = COL_PLAYER;\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n\n        // Tap prompt (pulsing)\n        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n        ctx.globalAlpha = pulseAlpha;\n        ctx.fillStyle = '#ffffff';\n        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n        ctx.globalAlpha = 1;\n\n        // High score\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n        }\n\n        // Small player character preview (bouncing)\n        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n        var ps = Math.max(1, cw / VIRTUAL_W);\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 10;\n        var pw = PLAYER_W * ps;\n        var ph = PLAYER_H * ps;\n        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n        ctx.shadowBlur = 0;\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n    };\n\n    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n        // Darken\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, cw, ch);\n\n        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n        var centerY = ch * 0.3;\n\n        // Game over text\n        ctx.fillStyle = '#ff3333';\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', cw / 2, centerY);\n\n        // Score\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n\n        // Height and coins\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n\n        // New high score?\n        if (state.score >= state.highScore && state.score > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n        }\n\n        // Restart prompt\n        if (canRestart) {\n            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n            ctx.globalAlpha = pulseAlpha;\n            ctx.fillStyle = '#ffffff';\n            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n            ctx.globalAlpha = 1;\n        }\n    };\n\n    // -------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------\n    return {\n        State: State,\n        Renderer: Renderer,\n        SFX: SFX,\n        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n    };\n\n})();\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":253,"cache_read_input_tokens":36951,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"200db05d-cf04-4e04-bb1a-7a83ee04c46c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MShqhhNbioZnj8TL2p9Jcb","type":"tool_result","content":"File created successfully at: F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"3feb370e-3e54-42ee-8b00-6326b80d1f2b","tool_use_result":{"type":"create","filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","content":"/**\n * Lava Rise - Complete game logic\n * Wall-jump between narrowing walls to outrun rising lava\n */\n\nvar LavaRise = (function() {\n    'use strict';\n\n    // -------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------\n    var VIRTUAL_W = 400;\n    var PLAYER_W = 18;\n    var PLAYER_H = 24;\n    var GRAVITY = 1400;\n    var JUMP_VY = -520;\n    var JUMP_VX_BASE = 400;\n    var WALL_THICKNESS = 40;\n    var COIN_RADIUS = 10;\n    var SPIKE_W = 20;\n    var SPIKE_H = 16;\n    var PLATFORM_W = 50;\n    var PLATFORM_H = 10;\n    var PARTICLE_POOL_SIZE = 200;\n    var SLOW_MO_DURATION = 0.3;\n    var SLOW_MO_FACTOR = 0.4;\n    var SAFE_TIME = 5.0;\n    var GAME_OVER_LOCKOUT = 0.8;\n    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    var LAVA_SPEED_MIN = 60;\n    var LAVA_SPEED_MAX = 150;\n    var WALL_GAP_MAX = 400;\n    var WALL_GAP_MIN = 220;\n    var CAMERA_LEAD = 0.3;\n    var CAMERA_SMOOTH = 4.0;\n\n    // Colors\n    var COL_BG_TOP = '#1a0a2e';\n    var COL_BG_BOT = '#0d0015';\n    var COL_WALL_LEFT = '#3a2a5c';\n    var COL_WALL_RIGHT = '#3a2a5c';\n    var COL_WALL_EDGE = '#6a4a9a';\n    var COL_PLAYER = '#00e5ff';\n    var COL_PLAYER_EYE = '#ffffff';\n    var COL_COIN = '#ffd700';\n    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    var COL_SPIKE = '#ff3366';\n    var COL_LAVA_TOP = '#ff4400';\n    var COL_LAVA_MID = '#ff2200';\n    var COL_LAVA_BOT = '#cc1100';\n    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    var COL_PLATFORM = '#8866bb';\n    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    var COL_SCORE = '#ffffff';\n    var COL_HEIGHT = '#aaaaaa';\n\n    // -------------------------------------------------------\n    // Procedural Audio\n    // -------------------------------------------------------\n    var SFX = {\n        _ctx: null,\n\n        init: function() {\n            if (GameAudio.ctx) {\n                this._ctx = GameAudio.ctx;\n            }\n        },\n\n        _ensureCtx: function() {\n            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n            return this._ctx;\n        },\n\n        jump: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(300, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.1);\n        },\n\n        wallHit: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'triangle';\n            osc.frequency.setValueAtTime(150, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.08);\n        },\n\n        coin: function(streak) {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var baseFreq = 800 + Math.min(streak, 10) * 80;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.15);\n            // Harmonic\n            var osc2 = ctx.createOscillator();\n            var gain2 = ctx.createGain();\n            osc2.type = 'sine';\n            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n            osc2.connect(gain2);\n            gain2.connect(ctx.destination);\n            osc2.start(ctx.currentTime + 0.05);\n            osc2.stop(ctx.currentTime + 0.2);\n        },\n\n        die: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sawtooth';\n            osc.frequency.setValueAtTime(400, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.4);\n            // Noise burst\n            var bufSize = ctx.sampleRate * 0.3;\n            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n            var data = buf.getChannelData(0);\n            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n            var noise = ctx.createBufferSource();\n            noise.buffer = buf;\n            var ng = ctx.createGain();\n            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            noise.connect(ng);\n            ng.connect(ctx.destination);\n            noise.start(ctx.currentTime);\n            noise.stop(ctx.currentTime + 0.3);\n        },\n\n        lavaWarn: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(100, ctx.currentTime);\n            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.3);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Particle Pool\n    // -------------------------------------------------------\n    function ParticlePool(size) {\n        this.pool = [];\n        for (var i = 0; i < size; i++) {\n            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n        }\n    }\n\n    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) {\n                p.alive = true;\n                p.x = x; p.y = y;\n                p.vx = vx; p.vy = vy;\n                p.life = life; p.maxLife = life;\n                p.r = r; p.g = g; p.b = b;\n                p.size = size || 2;\n                return p;\n            }\n        }\n        return null;\n    };\n\n    ParticlePool.prototype.update = function(dt) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            p.life -= dt;\n            if (p.life <= 0) { p.alive = false; continue; }\n            p.x += p.vx * dt;\n            p.y += p.vy * dt;\n            p.vy += 200 * dt; // light gravity on particles\n        }\n    };\n\n    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            var sz = p.size * scale * alpha;\n            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    ParticlePool.prototype.clear = function() {\n        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n    };\n\n    // -------------------------------------------------------\n    // Score Popup Pool\n    // -------------------------------------------------------\n    function PopupPool() {\n        this.popups = [];\n    }\n\n    PopupPool.prototype.spawn = function(x, y, text, color) {\n        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n    };\n\n    PopupPool.prototype.update = function(dt) {\n        for (var i = this.popups.length - 1; i >= 0; i--) {\n            var p = this.popups[i];\n            p.life -= dt;\n            p.y -= 60 * dt;\n            if (p.life <= 0) this.popups.splice(i, 1);\n        }\n    };\n\n    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.popups.length; i++) {\n            var p = this.popups[i];\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = p.color;\n            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText(p.text, sx, sy);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    // -------------------------------------------------------\n    // Main Game State\n    // -------------------------------------------------------\n    function State() {\n        this.reset();\n        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n        this.popups = new PopupPool();\n        this.highScore = 0;\n        this.totalCoins = 0;\n        try {\n            var hs = localStorage.getItem('lavarise_hs');\n            if (hs) this.highScore = parseInt(hs, 10) || 0;\n            var tc = localStorage.getItem('lavarise_coins');\n            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n        } catch(e) {}\n    }\n\n    State.prototype.reset = function() {\n        this.playTime = 0;\n        this.difficultyLevel = 0;\n        this.score = 0;\n        this.heightScore = 0;\n        this.coinScore = 0;\n        this.coinStreak = 0;\n        this.coinStreakTimer = 0;\n\n        // Player\n        this.px = VIRTUAL_W * 0.25;\n        this.py = 0;\n        this.pvx = 0;\n        this.pvy = 0;\n        this.pOnWall = 'left'; // 'left', 'right', 'air'\n        this.pFacing = 1; // 1=right, -1=left\n        this.pAlive = true;\n        this.pInvincible = 0;\n        this.pSquash = 1.0; // squash-stretch factor\n\n        // Camera\n        this.camY = 0;\n        this.camTargetY = 0;\n\n        // Lava\n        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n        this.lavaSpeed = LAVA_SPEED_MIN;\n        this.lavaWarnTimer = 0;\n\n        // Walls\n        this.wallGap = WALL_GAP_MAX;\n        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n\n        // Obstacles and coins\n        this.obstacles = [];\n        this.coins = [];\n        this.lastSpawnY = 0;\n        this.spawnInterval = 120;\n\n        // Effects\n        this.slowMoTimer = 0;\n        this.shakeAmount = 0;\n        this.shakeTimer = 0;\n        this.gameOverTimer = 0;\n        this.flashAlpha = 0;\n\n        if (this.particles) this.particles.clear();\n        if (this.popups) this.popups = new PopupPool();\n    };\n\n    // -------------------------------------------------------\n    // Game Logic\n    // -------------------------------------------------------\n\n    State.prototype.initGame = function() {\n        this.reset();\n        // Player starts on left wall, slightly above where lava will begin\n        this.py = -50;\n        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n        this.pOnWall = 'left';\n        this.pFacing = 1;\n        this.pInvincible = SAFE_TIME;\n        this.camY = this.py - 200;\n        this.camTargetY = this.camY;\n        this.lavaY = 200; // starts below player\n\n        // Seed some coins in the safe zone\n        this._spawnCoin(-100);\n        this._spawnCoin(-220);\n        this._spawnCoin(-350);\n\n        SFX.init();\n    };\n\n    State.prototype._getWallGap = function() {\n        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n    };\n\n    State.prototype._getWallLeft = function() {\n        return (VIRTUAL_W - this._getWallGap()) / 2;\n    };\n\n    State.prototype._getWallRight = function() {\n        return (VIRTUAL_W + this._getWallGap()) / 2;\n    };\n\n    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });\n        } else {\n            // Crumbling ledge\n            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n            this.obstacles.push({\n                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n                side: side2, timer: 0, crumbling: false, fallen: false\n            });\n        }\n    };\n\n    State.prototype.update = function(dt, tapped) {\n        if (!this.pAlive) return;\n\n        // Slow-mo\n        var effectiveDt = dt;\n        if (this.slowMoTimer > 0) {\n            this.slowMoTimer -= dt;\n            effectiveDt = dt * SLOW_MO_FACTOR;\n        }\n\n        this.playTime += effectiveDt;\n        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n\n        // Invincibility\n        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n\n        // Coin streak timeout\n        if (this.coinStreakTimer > 0) {\n            this.coinStreakTimer -= effectiveDt;\n            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n        }\n\n        // Wall narrowing\n        this.wallGap = this._getWallGap();\n        this.wallLeft = this._getWallLeft();\n        this.wallRight = this._getWallRight();\n\n        // Lava rise\n        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n\n        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {\n            this.lavaWarnTimer -= effectiveDt;\n            if (this.lavaWarnTimer <= 0) {\n                SFX.lavaWarn();\n                this.lavaWarnTimer = 0.5;\n            }\n        }\n\n        // Jump input\n        if (tapped && this.pOnWall !== 'air') {\n            this._jump();\n        }\n\n        // Physics\n        if (this.pOnWall === 'air') {\n            this.pvy += GRAVITY * effectiveDt;\n            this.px += this.pvx * effectiveDt;\n            this.py += this.pvy * effectiveDt;\n\n            // Wall collision\n            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n\n            if (this.px <= leftEdge) {\n                this.px = leftEdge;\n                this.pOnWall = 'left';\n                this.pFacing = 1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('left');\n            } else if (this.px >= rightEdge) {\n                this.px = rightEdge;\n                this.pOnWall = 'right';\n                this.pFacing = -1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('right');\n            }\n\n            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n        } else {\n            // On wall - slide down slowly\n            this.pvy = 30; // gentle slide\n            this.py += this.pvy * effectiveDt;\n\n            // Keep within wall bounds\n            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n            if (this.pOnWall === 'left') this.px = le;\n            else this.px = re;\n        }\n\n        // Squash recovery\n        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n\n        // Obstacle updates\n        this._updateObstacles(effectiveDt);\n\n        // Coin collection\n        this._updateCoins(effectiveDt);\n\n        // Collision with obstacles\n        if (this.pInvincible <= 0) {\n            this._checkObstacleCollisions();\n        }\n\n        // Lava death\n        if (this.py > this.lavaY - PLAYER_H / 2) {\n            this._die('lava');\n            return;\n        }\n\n        // Spawn new content ahead\n        this._spawnContent();\n\n        // Height score (negative Y = higher)\n        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n        this.score = this.heightScore + this.coinScore;\n\n        // Camera\n        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n\n        // Cleanup off-screen objects\n        this._cleanup();\n\n        // Effects\n        this.shakeTimer -= effectiveDt;\n        if (this.shakeTimer < 0) this.shakeTimer = 0;\n        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n\n        this.flashAlpha -= effectiveDt * 3;\n        if (this.flashAlpha < 0) this.flashAlpha = 0;\n\n        // Particles\n        this.particles.update(effectiveDt);\n        this.popups.update(effectiveDt);\n\n        // Lava particles\n        this._spawnLavaParticles(effectiveDt);\n    };\n\n    State.prototype._jump = function() {\n        var dir = this.pOnWall === 'left' ? 1 : -1;\n        this.pvx = JUMP_VX_BASE * dir;\n        this.pvy = JUMP_VY;\n        this.pOnWall = 'air';\n        this.pFacing = dir;\n        this.pSquash = 1.4; // stretch on jump\n        SFX.jump();\n\n        // Jump particles\n        for (var i = 0; i < 5; i++) {\n            var angle = Math.random() * Math.PI - Math.PI / 2;\n            var speed = 50 + Math.random() * 80;\n            this.particles.spawn(\n                this.px, this.py,\n                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n                0.3 + Math.random() * 0.2,\n                0, 229, 255, 3\n            );\n        }\n    };\n\n    State.prototype._spawnWallParticles = function(side) {\n        for (var i = 0; i < 6; i++) {\n            var dir = side === 'left' ? 1 : -1;\n            this.particles.spawn(\n                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n                0.2 + Math.random() * 0.2,\n                100, 80, 160, 3\n            );\n        }\n    };\n\n    State.prototype._updateObstacles = function(dt) {\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'platform') {\n                obs.x += obs.speed * obs.dir * dt;\n                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n            }\n            if (obs.type === 'crumble' && obs.crumbling) {\n                obs.timer += dt;\n                if (obs.timer > 0.5) obs.fallen = true;\n            }\n        }\n    };\n\n    State.prototype._updateCoins = function(dt) {\n        var px = this.px, py = this.py;\n        for (var i = 0; i < this.coins.length; i++) {\n            var c = this.coins[i];\n            if (c.collected) continue;\n            c.bobPhase += dt * 3;\n\n            var dx = px - c.x;\n            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n            var dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n                c.collected = true;\n                this.coinStreak++;\n                this.coinStreakTimer = 2.0;\n                var points = 10 * Math.min(this.coinStreak, 10);\n                this.coinScore += points;\n                this.totalCoins++;\n                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n\n                // Slow-mo\n                this.slowMoTimer = SLOW_MO_DURATION;\n\n                // Effects\n                this.flashAlpha = 0.3;\n                SFX.coin(this.coinStreak);\n                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n\n                // Coin burst particles\n                for (var j = 0; j < 8; j++) {\n                    var angle = (j / 8) * Math.PI * 2;\n                    this.particles.spawn(\n                        c.x, c.y,\n                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n                        0.4, 255, 215, 0, 3\n                    );\n                }\n            }\n        }\n    };\n\n    State.prototype._checkObstacleCollisions = function() {\n        var px = this.px, py = this.py;\n        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'crumble' && obs.fallen) continue;\n\n            if (obs.type === 'spike') {\n                // AABB\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    this._die('spike');\n                    return;\n                }\n            }\n\n            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n                // Land on top\n                if (this.pvy > 0 && this.pOnWall === 'air') {\n                    if (pl < obs.x + obs.w && pr > obs.x &&\n                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n                        py - ph / 2 < obs.y) {\n                        // Landing on platform\n                        // For crumbling, start crumble timer\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n                // Side collision with platform acts like a small wall\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    // Push player out horizontally if mostly horizontal collision\n                    var overlapL = pr - obs.x;\n                    var overlapR = obs.x + obs.w - pl;\n                    var overlapT = pb - obs.y;\n                    var overlapB = obs.y + obs.h - pt;\n                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n                    if (minOverlap === overlapT && this.pvy > 0) {\n                        // Land on top\n                        this.py = obs.y - ph / 2;\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    State.prototype._die = function(cause) {\n        if (!this.pAlive) return;\n        this.pAlive = false;\n        SFX.die();\n        this.shakeAmount = 8;\n        this.shakeTimer = 0.4;\n        this.flashAlpha = 0.5;\n        this.gameOverTimer = 0;\n\n        // Death particles\n        for (var i = 0; i < 20; i++) {\n            var angle = (i / 20) * Math.PI * 2;\n            var speed = 80 + Math.random() * 120;\n            var r = cause === 'lava' ? 255 : 255;\n            var g = cause === 'lava' ? 68 : 51;\n            var b = cause === 'lava' ? 0 : 102;\n            this.particles.spawn(\n                this.px, this.py,\n                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n                0.5 + Math.random() * 0.3,\n                r, g, b, 4\n            );\n        }\n\n        // Save high score\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n        }\n    };\n\n    State.prototype._spawnContent = function() {\n        // Spawn ahead of camera (negative Y is up)\n        var spawnAhead = this.camY - 500;\n        while (this.lastSpawnY > spawnAhead) {\n            this.lastSpawnY -= this.spawnInterval;\n\n            // Don't spawn obstacles during safe time\n            if (this.playTime > SAFE_TIME) {\n                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n                if (Math.random() < obstacleChance) {\n                    this._spawnObstacle(this.lastSpawnY);\n                }\n            }\n\n            // Always spawn coins (good density)\n            if (Math.random() < 0.5) {\n                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n            }\n\n            // Decrease spawn interval with difficulty\n            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n        }\n    };\n\n    var _lavaParticleTimer = 0;\n    State.prototype._spawnLavaParticles = function(dt) {\n        _lavaParticleTimer += dt;\n        if (_lavaParticleTimer < 0.05) return;\n        _lavaParticleTimer = 0;\n\n        // Spawn bubbles along lava surface\n        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n        this.particles.spawn(\n            x, this.lavaY,\n            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n            0.5 + Math.random() * 0.5,\n            255, Math.floor(40 + Math.random() * 60), 0, 4\n        );\n    };\n\n    State.prototype._cleanup = function() {\n        var below = this.lavaY + 100;\n        // Remove coins below lava\n        for (var i = this.coins.length - 1; i >= 0; i--) {\n            if (this.coins[i].y > below || this.coins[i].collected) {\n                this.coins.splice(i, 1);\n            }\n        }\n        // Remove obstacles below lava\n        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n            if (this.obstacles[j].y > below) {\n                this.obstacles.splice(j, 1);\n            }\n        }\n    };\n\n    // -------------------------------------------------------\n    // Rendering\n    // -------------------------------------------------------\n\n    function Renderer() {}\n\n    Renderer.prototype.render = function(ctx, canvas, state) {\n        var cw = canvas.width;\n        var ch = canvas.height;\n\n        // Virtual coordinate mapping\n        var scale = cw / VIRTUAL_W;\n        var virtualH = ch / scale;\n        var offsetX = 0;\n\n        // Screen shake\n        var shakeX = 0, shakeY = 0;\n        if (state.shakeTimer > 0) {\n            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n        }\n\n        ctx.save();\n        ctx.translate(shakeX, shakeY);\n\n        // Background gradient\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, COL_BG_BOT);\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n\n        // Background stars (parallax)\n        this._renderStars(ctx, cw, ch, state.camY);\n\n        // Walls\n        this._renderWalls(ctx, state, scale, offsetX, ch);\n\n        // Obstacles\n        this._renderObstacles(ctx, state, scale, offsetX);\n\n        // Coins\n        this._renderCoins(ctx, state, scale, offsetX);\n\n        // Player\n        if (state.pAlive) {\n            this._renderPlayer(ctx, state, scale, offsetX);\n        }\n\n        // Particles\n        state.particles.render(ctx, state.camY, scale, offsetX);\n\n        // Lava\n        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n\n        // Popups\n        state.popups.render(ctx, state.camY, scale, offsetX);\n\n        ctx.restore();\n\n        // Flash overlay\n        if (state.flashAlpha > 0) {\n            ctx.globalAlpha = state.flashAlpha;\n            ctx.fillStyle = '#fff';\n            ctx.fillRect(0, 0, cw, ch);\n            ctx.globalAlpha = 1;\n        }\n\n        // HUD (not affected by shake)\n        this._renderHUD(ctx, cw, ch, state);\n    };\n\n    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n        // Simple deterministic stars\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        var seed = 42;\n        for (var i = 0; i < 40; i++) {\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sx = (seed % cw);\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sy = (seed % (ch * 3));\n            var parallax = 0.05;\n            var screenY = (sy - camY * parallax) % (ch * 3);\n            if (screenY < 0) screenY += ch * 3;\n            if (screenY < ch) {\n                var size = 1 + (i % 3);\n                ctx.fillRect(sx, screenY, size, size);\n            }\n        }\n    };\n\n    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n        var camY = state.camY;\n        var topY = 0;\n        var botY = ch;\n\n        // Left wall\n        var lwScreen = state.wallLeft * scale + offsetX;\n        var lwWidth = (WALL_THICKNESS) * scale;\n        ctx.fillStyle = COL_WALL_LEFT;\n        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n\n        // Right wall\n        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n        ctx.fillStyle = COL_WALL_RIGHT;\n        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n\n        // Wall bricks pattern\n        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n        var brickH = 20 * scale;\n        var startBrickY = Math.floor(camY / 20) * 20;\n        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n            var sy = (by - camY) * scale;\n            var offset = ((by / 20) % 2) * 10 * scale;\n            // Left wall bricks\n            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n                ctx.fillRect(bx + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n            // Right wall bricks\n            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n        }\n    };\n\n    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.obstacles.length; i++) {\n            var obs = state.obstacles[i];\n            var sx = obs.x * scale + offsetX;\n            var sy = (obs.y - camY) * scale;\n            var sw = obs.w * scale;\n            var sh = obs.h * scale;\n\n            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n\n            if (obs.type === 'spike') {\n                ctx.fillStyle = COL_SPIKE;\n                ctx.beginPath();\n                if (obs.side === 'left') {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                } else {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowColor = COL_SPIKE;\n                ctx.shadowBlur = 6 * scale;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            } else if (obs.type === 'platform') {\n                ctx.fillStyle = COL_PLATFORM;\n                ctx.fillRect(sx, sy, sw, sh);\n                // Top highlight\n                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n                ctx.fillRect(sx, sy, sw, 2 * scale);\n            } else if (obs.type === 'crumble') {\n                if (obs.fallen) continue;\n                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n                // Shake if crumbling\n                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n                ctx.globalAlpha = 1;\n            }\n        }\n    };\n\n    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.coins.length; i++) {\n            var c = state.coins[i];\n            if (c.collected) continue;\n            var sx = c.x * scale + offsetX;\n            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n            var sr = COIN_RADIUS * scale;\n\n            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n\n            // Glow\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN_GLOW;\n            ctx.fill();\n\n            // Coin body\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN;\n            ctx.fill();\n\n            // Shine\n            ctx.beginPath();\n            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.fill();\n        }\n    };\n\n    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n        var sx = state.px * scale + offsetX;\n        var sy = (state.py - state.camY) * scale;\n        var sw = PLAYER_W * scale;\n        var sh = PLAYER_H * scale;\n\n        // Invincibility blink\n        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n            ctx.globalAlpha = 0.5;\n        }\n\n        // Squash-stretch\n        var squashX = 1 / state.pSquash;\n        var squashY = state.pSquash;\n\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.scale(squashX, squashY);\n\n        // Body\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 8 * scale;\n        var bodyW = sw;\n        var bodyH = sh;\n        // Rounded rectangle body\n        var r = 4 * scale;\n        ctx.beginPath();\n        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Eyes\n        var eyeOffX = state.pFacing * 3 * scale;\n        var eyeY = -3 * scale;\n        ctx.fillStyle = COL_PLAYER_EYE;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils (look in movement direction)\n        ctx.fillStyle = '#222';\n        var pupilOff = state.pFacing * 1 * scale;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n        ctx.globalAlpha = 1;\n    };\n\n    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n        var lavaScreenY = (state.lavaY - state.camY) * scale;\n        if (lavaScreenY > ch + 50) return;\n\n        var topY = Math.max(0, lavaScreenY - 10 * scale);\n\n        // Lava glow above surface\n        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n\n        // Lava surface wave\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        ctx.lineTo(0, lavaScreenY);\n        var waveTime = state.playTime * 2;\n        for (var x = 0; x <= cw; x += 4) {\n            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n            ctx.lineTo(x, waveY);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n\n        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Surface highlight\n        ctx.strokeStyle = '#ff8800';\n        ctx.lineWidth = 2 * scale;\n        ctx.beginPath();\n        for (var x2 = 0; x2 <= cw; x2 += 4) {\n            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n            if (x2 === 0) ctx.moveTo(x2, waveY2);\n            else ctx.lineTo(x2, waveY2);\n        }\n        ctx.stroke();\n    };\n\n    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n        var pad = Math.max(12, cw * 0.03);\n        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n\n        // Score\n        ctx.fillStyle = COL_SCORE;\n        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n\n        // Height indicator\n        ctx.fillStyle = COL_HEIGHT;\n        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n\n        // Coin streak\n        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n            ctx.globalAlpha = 1;\n        }\n\n        // High score (small, top right)\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n        }\n\n        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Menu / Game Over rendering\n    // -------------------------------------------------------\n\n    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n        // Background\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, '#1a0505');\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(0, 0, cw, ch);\n\n        // Decorative lava at bottom\n        var lavaH = ch * 0.25;\n        var lavaTop = ch - lavaH;\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        for (var x = 0; x <= cw; x += 4) {\n            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n            ctx.lineTo(x, wy);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Glow\n        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n\n        // Title\n        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n        var centerY = ch * 0.32;\n        ctx.fillStyle = COL_LAVA_TOP;\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.shadowColor = '#ff4400';\n        ctx.shadowBlur = 20;\n        ctx.fillText('LAVA RISE', cw / 2, centerY);\n        ctx.shadowBlur = 0;\n\n        // Subtitle\n        ctx.fillStyle = COL_PLAYER;\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n\n        // Tap prompt (pulsing)\n        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n        ctx.globalAlpha = pulseAlpha;\n        ctx.fillStyle = '#ffffff';\n        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n        ctx.globalAlpha = 1;\n\n        // High score\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n        }\n\n        // Small player character preview (bouncing)\n        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n        var ps = Math.max(1, cw / VIRTUAL_W);\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 10;\n        var pw = PLAYER_W * ps;\n        var ph = PLAYER_H * ps;\n        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n        ctx.shadowBlur = 0;\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n    };\n\n    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n        // Darken\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, cw, ch);\n\n        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n        var centerY = ch * 0.3;\n\n        // Game over text\n        ctx.fillStyle = '#ff3333';\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', cw / 2, centerY);\n\n        // Score\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n\n        // Height and coins\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n\n        // New high score?\n        if (state.score >= state.highScore && state.score > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n        }\n\n        // Restart prompt\n        if (canRestart) {\n            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n            ctx.globalAlpha = pulseAlpha;\n            ctx.fillStyle = '#ffffff';\n            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n            ctx.globalAlpha = 1;\n        }\n    };\n\n    // -------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------\n    return {\n        State: State,\n        Renderer: Renderer,\n        SFX: SFX,\n        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n    };\n\n})();\n","structuredPatch":[],"originalFile":null}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01RJqrRgeVGHYbV96U9Qw33v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ExvguAPvyN92Va8HKuyGSs","name":"TodoWrite","input":{"todos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"in_progress","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"pending","activeForm":"Updating index.html with new script tag"},{"content":"Test and polish the complete game","status":"pending","activeForm":"Testing and polishing the game"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":16362,"cache_read_input_tokens":37204,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":16362},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"928961c6-30b0-44ff-bfdf-6202d5e772f8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ExvguAPvyN92Va8HKuyGSs","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"00e4e7a5-aaf0-407a-8262-fcddcb615017","tool_use_result":{"oldTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"in_progress","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"pending","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"pending","activeForm":"Updating index.html with new script tag"},{"content":"Test and polish the complete game","status":"pending","activeForm":"Testing and polishing the game"}],"newTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"in_progress","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"pending","activeForm":"Updating index.html with new script tag"},{"content":"Test and polish the complete game","status":"pending","activeForm":"Testing and polishing the game"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01JFKKBP3swJ4zPJ2g73Xn55","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me rewrite `game.js` to integrate the LavaRise systems."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":253,"cache_read_input_tokens":53566,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"22911b5a-f4cf-4903-9b7a-8b8b19aaf7f3"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01JFKKBP3swJ4zPJ2g73Xn55","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01D3PGZ6zoEcc8oCGwqEtHsw","name":"Write","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js","content":"/**\n * Game - Lava Rise integration\n * State machine, rAF loop, Poki lifecycle\n */\n\nimport { InputManager } from './input.js';\n\n/** Config */\nexport const Config = {\n    adsEnabled: false,\n};\n\nexport class Game {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.input = new InputManager(canvas);\n        this.state = 'loading';\n        this.score = 0;\n        this.lastTime = 0;\n        this.menuTime = 0;\n        this.gameOverTime = 0;\n\n        // Lava Rise systems\n        this.gs = new LavaRise.State();\n        this.renderer = new LavaRise.Renderer();\n\n        this._boundLoop = this._loop.bind(this);\n        this._resize = this._resize.bind(this);\n        window.addEventListener('resize', this._resize);\n    }\n\n    async init() {\n        await Poki.init();\n        this._resize();\n        await this.loadAssets();\n        Poki.gameLoadingFinished();\n        this.state = 'menu';\n        this.lastTime = performance.now();\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    async loadAssets() {\n        // No assets to load - all procedural\n    }\n\n    _resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n\n    _loop(now) {\n        var dt = (now - this.lastTime) / 1000;\n        if (dt > 0.1) dt = 0.1;\n        this.lastTime = now;\n\n        this.update(dt);\n        this.render();\n        this.input.endFrame();\n\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    // -------------------------------------------------------\n    // State transitions\n    // -------------------------------------------------------\n\n    start() {\n        this.state = 'playing';\n        this.gs.initGame();\n        GameAudio.initContext();\n        GameAudio.resume();\n        LavaRise.SFX.init();\n        Poki.gameplayStart();\n    }\n\n    gameOver() {\n        this.state = 'gameover';\n        this.score = this.gs.score;\n        this.gameOverTime = 0;\n        Poki.gameplayStop();\n    }\n\n    async restart() {\n        if (Config.adsEnabled) {\n            await Poki.commercialBreak(\n                () => GameAudio.muteAll(),\n                () => GameAudio.unmuteAll()\n            );\n        }\n        this.state = 'playing';\n        this.gs.initGame();\n        Poki.gameplayStart();\n    }\n\n    // -------------------------------------------------------\n    // Update\n    // -------------------------------------------------------\n\n    update(dt) {\n        var tapped = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n\n        if (this.state === 'menu') {\n            this.menuTime += dt;\n            if (tapped) this.start();\n        } else if (this.state === 'playing') {\n            this.updatePlaying(dt, tapped);\n        } else if (this.state === 'gameover') {\n            this.gameOverTime += dt;\n            // Update particles/effects even after death\n            this.gs.particles.update(dt);\n            this.gs.popups.update(dt);\n            this.gs.shakeTimer -= dt;\n            if (this.gs.shakeTimer < 0) this.gs.shakeTimer = 0;\n            this.gs.shakeAmount *= Math.max(0, 1 - 8 * dt);\n            this.gs.flashAlpha -= dt * 3;\n            if (this.gs.flashAlpha < 0) this.gs.flashAlpha = 0;\n\n            if (tapped && this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT) {\n                this.restart();\n            }\n        }\n    }\n\n    updatePlaying(dt, tapped) {\n        this.gs.update(dt, tapped);\n        this.score = this.gs.score;\n\n        if (!this.gs.pAlive) {\n            this.gameOver();\n        }\n    }\n\n    // -------------------------------------------------------\n    // Render\n    // -------------------------------------------------------\n\n    render() {\n        var ctx = this.ctx;\n        var cw = this.canvas.width;\n        var ch = this.canvas.height;\n\n        if (this.state === 'loading') {\n            this.renderLoading();\n        } else if (this.state === 'menu') {\n            this.renderer.renderMenu(ctx, cw, ch, this.gs, this.menuTime);\n        } else if (this.state === 'playing') {\n            this.renderer.render(ctx, this.canvas, this.gs);\n        } else if (this.state === 'gameover') {\n            // Render the game state frozen in background\n            this.renderer.render(ctx, this.canvas, this.gs);\n            // Overlay game over screen\n            var canRestart = this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT;\n            this.renderer.renderGameOver(ctx, cw, ch, this.gs, this.gameOverTime, canRestart);\n        }\n    }\n\n    renderLoading() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#1a0a2e';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#ff4400';\n        ctx.font = 'bold 24px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('LAVA RISE', this.canvas.width / 2, this.canvas.height / 2);\n    }\n}\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":253,"cache_read_input_tokens":53566,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":253},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"7c314d57-7487-4050-8d14-c8dd67a8a569"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01D3PGZ6zoEcc8oCGwqEtHsw","type":"tool_result","content":"The file F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js has been overwritten successfully."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"512bfeee-618e-477e-96d9-e823dd904a3e","tool_use_result":{"type":"update","filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js","content":"/**\n * Game - Lava Rise integration\n * State machine, rAF loop, Poki lifecycle\n */\n\nimport { InputManager } from './input.js';\n\n/** Config */\nexport const Config = {\n    adsEnabled: false,\n};\n\nexport class Game {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.input = new InputManager(canvas);\n        this.state = 'loading';\n        this.score = 0;\n        this.lastTime = 0;\n        this.menuTime = 0;\n        this.gameOverTime = 0;\n\n        // Lava Rise systems\n        this.gs = new LavaRise.State();\n        this.renderer = new LavaRise.Renderer();\n\n        this._boundLoop = this._loop.bind(this);\n        this._resize = this._resize.bind(this);\n        window.addEventListener('resize', this._resize);\n    }\n\n    async init() {\n        await Poki.init();\n        this._resize();\n        await this.loadAssets();\n        Poki.gameLoadingFinished();\n        this.state = 'menu';\n        this.lastTime = performance.now();\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    async loadAssets() {\n        // No assets to load - all procedural\n    }\n\n    _resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n\n    _loop(now) {\n        var dt = (now - this.lastTime) / 1000;\n        if (dt > 0.1) dt = 0.1;\n        this.lastTime = now;\n\n        this.update(dt);\n        this.render();\n        this.input.endFrame();\n\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    // -------------------------------------------------------\n    // State transitions\n    // -------------------------------------------------------\n\n    start() {\n        this.state = 'playing';\n        this.gs.initGame();\n        GameAudio.initContext();\n        GameAudio.resume();\n        LavaRise.SFX.init();\n        Poki.gameplayStart();\n    }\n\n    gameOver() {\n        this.state = 'gameover';\n        this.score = this.gs.score;\n        this.gameOverTime = 0;\n        Poki.gameplayStop();\n    }\n\n    async restart() {\n        if (Config.adsEnabled) {\n            await Poki.commercialBreak(\n                () => GameAudio.muteAll(),\n                () => GameAudio.unmuteAll()\n            );\n        }\n        this.state = 'playing';\n        this.gs.initGame();\n        Poki.gameplayStart();\n    }\n\n    // -------------------------------------------------------\n    // Update\n    // -------------------------------------------------------\n\n    update(dt) {\n        var tapped = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n\n        if (this.state === 'menu') {\n            this.menuTime += dt;\n            if (tapped) this.start();\n        } else if (this.state === 'playing') {\n            this.updatePlaying(dt, tapped);\n        } else if (this.state === 'gameover') {\n            this.gameOverTime += dt;\n            // Update particles/effects even after death\n            this.gs.particles.update(dt);\n            this.gs.popups.update(dt);\n            this.gs.shakeTimer -= dt;\n            if (this.gs.shakeTimer < 0) this.gs.shakeTimer = 0;\n            this.gs.shakeAmount *= Math.max(0, 1 - 8 * dt);\n            this.gs.flashAlpha -= dt * 3;\n            if (this.gs.flashAlpha < 0) this.gs.flashAlpha = 0;\n\n            if (tapped && this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT) {\n                this.restart();\n            }\n        }\n    }\n\n    updatePlaying(dt, tapped) {\n        this.gs.update(dt, tapped);\n        this.score = this.gs.score;\n\n        if (!this.gs.pAlive) {\n            this.gameOver();\n        }\n    }\n\n    // -------------------------------------------------------\n    // Render\n    // -------------------------------------------------------\n\n    render() {\n        var ctx = this.ctx;\n        var cw = this.canvas.width;\n        var ch = this.canvas.height;\n\n        if (this.state === 'loading') {\n            this.renderLoading();\n        } else if (this.state === 'menu') {\n            this.renderer.renderMenu(ctx, cw, ch, this.gs, this.menuTime);\n        } else if (this.state === 'playing') {\n            this.renderer.render(ctx, this.canvas, this.gs);\n        } else if (this.state === 'gameover') {\n            // Render the game state frozen in background\n            this.renderer.render(ctx, this.canvas, this.gs);\n            // Overlay game over screen\n            var canRestart = this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT;\n            this.renderer.renderGameOver(ctx, cw, ch, this.gs, this.gameOverTime, canRestart);\n        }\n    }\n\n    renderLoading() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#1a0a2e';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#ff4400';\n        ctx.font = 'bold 24px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('LAVA RISE', this.canvas.width / 2, this.canvas.height / 2);\n    }\n}\n","structuredPatch":[{"oldStart":1,"oldLines":13,"newStart":1,"newLines":13,"lines":[" /**","- * Game - State machine, rAF loop, Poki lifecycle","- * Override render/update methods for your actual game","+ * Game - Lava Rise integration","+ * State machine, rAF loop, Poki lifecycle","  */"," "," import { InputManager } from './input.js';"," ","-/** Config â€“ tweak per game */","+/** Config */"," export const Config = {","-    adsEnabled: false,  // set true when ready for Poki ads","+    adsEnabled: false,"," };"," "," export class Game {"]},{"oldStart":15,"oldLines":15,"newStart":15,"newLines":15,"lines":["         this.canvas = canvas;","         this.ctx = canvas.getContext('2d');","         this.input = new InputManager(canvas);","-        this.state = 'loading'; // loading -> menu -> playing -> gameover","+        this.state = 'loading';","         this.score = 0;","         this.lastTime = 0;","+        this.menuTime = 0;","+        this.gameOverTime = 0;"," ","-        // Demo: bouncing dot","-        this._dotX = 0;","-        this._dotY = 0;","-        this._dotVX = 200;","-        this._dotVY = 150;","+        // Lava Rise systems","+        this.gs = new LavaRise.State();","+        this.renderer = new LavaRise.Renderer();"," ","         this._boundLoop = this._loop.bind(this);","         this._resize = this._resize.bind(this);"]},{"oldStart":40,"oldLines":10,"newStart":40,"newLines":8,"lines":["         requestAnimationFrame(this._boundLoop);","     }"," ","-    /** Override to load your game assets */","     async loadAssets() {","-        // Example: GameAudio.sfxFiles = { jump: 'assets/audio/jump.mp3' };","-        // await GameAudio.loadSFX();","+        // No assets to load - all procedural","     }"," ","     _resize() {"]},{"oldStart":53,"oldLines":7,"newStart":51,"newLines":7,"lines":[" ","     _loop(now) {","         var dt = (now - this.lastTime) / 1000;","-        if (dt > 0.1) dt = 0.1; // Clamp to avoid spiral of death","+        if (dt > 0.1) dt = 0.1;","         this.lastTime = now;"," ","         this.update(dt);"]},{"oldStart":64,"oldLines":35,"newStart":62,"newLines":34,"lines":["     }"," ","     // -------------------------------------------------------","-    // State transitions with Poki lifecycle","+    // State transitions","     // -------------------------------------------------------"," ","     start() {","         this.state = 'playing';","-        this.score = 0;","-        this._dotX = this.canvas.width / 2;","-        this._dotY = this.canvas.height / 2;","+        this.gs.initGame();","         GameAudio.initContext();","         GameAudio.resume();","+        LavaRise.SFX.init();","         Poki.gameplayStart();","     }"," ","     gameOver() {","         this.state = 'gameover';","+        this.score = this.gs.score;","+        this.gameOverTime = 0;","         Poki.gameplayStop();","     }"," ","     async restart() {","-        this.state = 'playing';","-        this.score = 0;","-        this._dotX = this.canvas.width / 2;","-        this._dotY = this.canvas.height / 2;","         if (Config.adsEnabled) {","             await Poki.commercialBreak(","                 () => GameAudio.muteAll(),","                 () => GameAudio.unmuteAll()","             );","         }","+        this.state = 'playing';","+        this.gs.initGame();","         Poki.gameplayStart();","     }"," "]},{"oldStart":101,"oldLines":30,"newStart":98,"newLines":37,"lines":["     // -------------------------------------------------------"," ","     update(dt) {","-        var confirm = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();","+        var tapped = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();"," ","         if (this.state === 'menu') {","-            if (confirm) this.start();","+            this.menuTime += dt;","+            if (tapped) this.start();","         } else if (this.state === 'playing') {","-            this.updatePlaying(dt);","+            this.updatePlaying(dt, tapped);","         } else if (this.state === 'gameover') {","-            if (confirm) this.restart();","+            this.gameOverTime += dt;","+            // Update particles/effects even after death","+            this.gs.particles.update(dt);","+            this.gs.popups.update(dt);","+            this.gs.shakeTimer -= dt;","+            if (this.gs.shakeTimer < 0) this.gs.shakeTimer = 0;","+            this.gs.shakeAmount *= Math.max(0, 1 - 8 * dt);","+            this.gs.flashAlpha -= dt * 3;","+            if (this.gs.flashAlpha < 0) this.gs.flashAlpha = 0;","+","+            if (tapped && this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT) {","+                this.restart();","+            }","         }","     }"," ","-    /** Override for actual gameplay logic */","-    updatePlaying(dt) {","-        // Demo: bounce a dot","-        this._dotX += this._dotVX * dt;","-        this._dotY += this._dotVY * dt;","-        if (this._dotX < 10) { this._dotVX = Math.abs(this._dotVX); this._dotX = 10; }","-        if (this._dotX > this.canvas.width - 10) { this._dotVX = -Math.abs(this._dotVX); this._dotX = this.canvas.width - 10; }","-        if (this._dotY < 10) { this._dotVY = Math.abs(this._dotVY); this._dotY = 10; }","-        if (this._dotY > this.canvas.height - 10) { this._dotVY = -Math.abs(this._dotVY); this._dotY = this.canvas.height - 10; }","-        this.score += dt * 10;","+    updatePlaying(dt, tapped) {","+        this.gs.update(dt, tapped);","+        this.score = this.gs.score;"," ","-        // Demo: gameover after 10 seconds","-        if (this.score >= 100) this.gameOver();","+        if (!this.gs.pAlive) {","+            this.gameOver();","+        }","     }"," ","     // -------------------------------------------------------"]},{"oldStart":132,"oldLines":66,"newStart":136,"newLines":32,"lines":["     // -------------------------------------------------------"," ","     render() {","-        if (this.state === 'loading') this.renderLoading();","-        else if (this.state === 'menu') this.renderMenu();","-        else if (this.state === 'playing') this.renderPlaying();","-        else if (this.state === 'gameover') this.renderGameOver();","-    }","-","-    renderLoading() {","         var ctx = this.ctx;","-        ctx.fillStyle = '#000';","-        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);","-        ctx.fillStyle = '#fff';","-        ctx.font = '24px sans-serif';","-        ctx.textAlign = 'center';","-        ctx.fillText('Loading...', this.canvas.width / 2, this.canvas.height / 2);","-    }","+        var cw = this.canvas.width;","+        var ch = this.canvas.height;"," ","-    renderMenu() {","-        var ctx = this.ctx;","-        ctx.fillStyle = '#000';","-        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);","-        ctx.fillStyle = '#fff';","-        ctx.font = 'bold 48px sans-serif';","-        ctx.textAlign = 'center';","-        ctx.fillText('GAME TITLE', this.canvas.width / 2, this.canvas.height / 2 - 40);","-        ctx.font = '20px sans-serif';","-        ctx.fillStyle = '#aaa';","-        ctx.fillText('Press Enter or Tap to Start', this.canvas.width / 2, this.canvas.height / 2 + 20);","+        if (this.state === 'loading') {","+            this.renderLoading();","+        } else if (this.state === 'menu') {","+            this.renderer.renderMenu(ctx, cw, ch, this.gs, this.menuTime);","+        } else if (this.state === 'playing') {","+            this.renderer.render(ctx, this.canvas, this.gs);","+        } else if (this.state === 'gameover') {","+            // Render the game state frozen in background","+            this.renderer.render(ctx, this.canvas, this.gs);","+            // Overlay game over screen","+            var canRestart = this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT;","+            this.renderer.renderGameOver(ctx, cw, ch, this.gs, this.gameOverTime, canRestart);","+        }","     }"," ","-    renderPlaying() {","+    renderLoading() {","         var ctx = this.ctx;","-        ctx.fillStyle = '#000';","+        ctx.fillStyle = '#1a0a2e';","         ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);","-","-        // Bouncing dot","-        ctx.beginPath();","-        ctx.arc(this._dotX, this._dotY, 10, 0, Math.PI * 2);","-        ctx.fillStyle = '#0f0';","-        ctx.fill();","-","-        // Score","-        ctx.fillStyle = '#fff';","-        ctx.font = '20px sans-serif';","-        ctx.textAlign = 'left';","-        ctx.fillText('Score: ' + Math.floor(this.score), 20, 40);","-    }","-","-    renderGameOver() {","-        var ctx = this.ctx;","-        ctx.fillStyle = '#000';","-        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);","-        ctx.fillStyle = '#f00';","-        ctx.font = 'bold 48px sans-serif';","+        ctx.fillStyle = '#ff4400';","+        ctx.font = 'bold 24px sans-serif';","         ctx.textAlign = 'center';","-        ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);","-        ctx.fillStyle = '#fff';","-        ctx.font = '24px sans-serif';","-        ctx.fillText('Score: ' + Math.floor(this.score), this.canvas.width / 2, this.canvas.height / 2 + 10);","-        ctx.font = '20px sans-serif';","-        ctx.fillStyle = '#aaa';","-        ctx.fillText('Press Enter or Tap to Restart', this.canvas.width / 2, this.canvas.height / 2 + 50);","+        ctx.fillText('LAVA RISE', this.canvas.width / 2, this.canvas.height / 2);","     }"," }"]}],"originalFile":"/**\n * Game - State machine, rAF loop, Poki lifecycle\n * Override render/update methods for your actual game\n */\n\nimport { InputManager } from './input.js';\n\n/** Config â€“ tweak per game */\nexport const Config = {\n    adsEnabled: false,  // set true when ready for Poki ads\n};\n\nexport class Game {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.input = new InputManager(canvas);\n        this.state = 'loading'; // loading -> menu -> playing -> gameover\n        this.score = 0;\n        this.lastTime = 0;\n\n        // Demo: bouncing dot\n        this._dotX = 0;\n        this._dotY = 0;\n        this._dotVX = 200;\n        this._dotVY = 150;\n\n        this._boundLoop = this._loop.bind(this);\n        this._resize = this._resize.bind(this);\n        window.addEventListener('resize', this._resize);\n    }\n\n    async init() {\n        await Poki.init();\n        this._resize();\n        await this.loadAssets();\n        Poki.gameLoadingFinished();\n        this.state = 'menu';\n        this.lastTime = performance.now();\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    /** Override to load your game assets */\n    async loadAssets() {\n        // Example: GameAudio.sfxFiles = { jump: 'assets/audio/jump.mp3' };\n        // await GameAudio.loadSFX();\n    }\n\n    _resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n\n    _loop(now) {\n        var dt = (now - this.lastTime) / 1000;\n        if (dt > 0.1) dt = 0.1; // Clamp to avoid spiral of death\n        this.lastTime = now;\n\n        this.update(dt);\n        this.render();\n        this.input.endFrame();\n\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    // -------------------------------------------------------\n    // State transitions with Poki lifecycle\n    // -------------------------------------------------------\n\n    start() {\n        this.state = 'playing';\n        this.score = 0;\n        this._dotX = this.canvas.width / 2;\n        this._dotY = this.canvas.height / 2;\n        GameAudio.initContext();\n        GameAudio.resume();\n        Poki.gameplayStart();\n    }\n\n    gameOver() {\n        this.state = 'gameover';\n        Poki.gameplayStop();\n    }\n\n    async restart() {\n        this.state = 'playing';\n        this.score = 0;\n        this._dotX = this.canvas.width / 2;\n        this._dotY = this.canvas.height / 2;\n        if (Config.adsEnabled) {\n            await Poki.commercialBreak(\n                () => GameAudio.muteAll(),\n                () => GameAudio.unmuteAll()\n            );\n        }\n        Poki.gameplayStart();\n    }\n\n    // -------------------------------------------------------\n    // Update\n    // -------------------------------------------------------\n\n    update(dt) {\n        var confirm = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n\n        if (this.state === 'menu') {\n            if (confirm) this.start();\n        } else if (this.state === 'playing') {\n            this.updatePlaying(dt);\n        } else if (this.state === 'gameover') {\n            if (confirm) this.restart();\n        }\n    }\n\n    /** Override for actual gameplay logic */\n    updatePlaying(dt) {\n        // Demo: bounce a dot\n        this._dotX += this._dotVX * dt;\n        this._dotY += this._dotVY * dt;\n        if (this._dotX < 10) { this._dotVX = Math.abs(this._dotVX); this._dotX = 10; }\n        if (this._dotX > this.canvas.width - 10) { this._dotVX = -Math.abs(this._dotVX); this._dotX = this.canvas.width - 10; }\n        if (this._dotY < 10) { this._dotVY = Math.abs(this._dotVY); this._dotY = 10; }\n        if (this._dotY > this.canvas.height - 10) { this._dotVY = -Math.abs(this._dotVY); this._dotY = this.canvas.height - 10; }\n        this.score += dt * 10;\n\n        // Demo: gameover after 10 seconds\n        if (this.score >= 100) this.gameOver();\n    }\n\n    // -------------------------------------------------------\n    // Render\n    // -------------------------------------------------------\n\n    render() {\n        if (this.state === 'loading') this.renderLoading();\n        else if (this.state === 'menu') this.renderMenu();\n        else if (this.state === 'playing') this.renderPlaying();\n        else if (this.state === 'gameover') this.renderGameOver();\n    }\n\n    renderLoading() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#fff';\n        ctx.font = '24px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('Loading...', this.canvas.width / 2, this.canvas.height / 2);\n    }\n\n    renderMenu() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#fff';\n        ctx.font = 'bold 48px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME TITLE', this.canvas.width / 2, this.canvas.height / 2 - 40);\n        ctx.font = '20px sans-serif';\n        ctx.fillStyle = '#aaa';\n        ctx.fillText('Press Enter or Tap to Start', this.canvas.width / 2, this.canvas.height / 2 + 20);\n    }\n\n    renderPlaying() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Bouncing dot\n        ctx.beginPath();\n        ctx.arc(this._dotX, this._dotY, 10, 0, Math.PI * 2);\n        ctx.fillStyle = '#0f0';\n        ctx.fill();\n\n        // Score\n        ctx.fillStyle = '#fff';\n        ctx.font = '20px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('Score: ' + Math.floor(this.score), 20, 40);\n    }\n\n    renderGameOver() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#f00';\n        ctx.font = 'bold 48px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);\n        ctx.fillStyle = '#fff';\n        ctx.font = '24px sans-serif';\n        ctx.fillText('Score: ' + Math.floor(this.score), this.canvas.width / 2, this.canvas.height / 2 + 10);\n        ctx.font = '20px sans-serif';\n        ctx.fillStyle = '#aaa';\n        ctx.fillText('Press Enter or Tap to Restart', this.canvas.width / 2, this.canvas.height / 2 + 50);\n    }\n}\n"}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01PMNFwfH6iUQ9KTCaGbM8Wh","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `index.html` to include the `lava-rise.js` script tag before `main.js`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1642,"cache_read_input_tokens":53819,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1642},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"6b3c9aad-07f8-4bcb-885f-6b6b33629236"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01PMNFwfH6iUQ9KTCaGbM8Wh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LP3sgj8GZ5J1gvkMTnvYFq","name":"Edit","input":{"replace_all":false,"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","old_string":"    <title>Game</title>","new_string":"    <title>Lava Rise</title>"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1642,"cache_read_input_tokens":53819,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1642},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"7b6b660e-d579-403e-bdad-ae60f9eda7ec"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LP3sgj8GZ5J1gvkMTnvYFq","type":"tool_result","content":"The file F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"a4c3efad-5f9e-4d3d-bdd5-5455d662bc9a","tool_use_result":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","oldString":"    <title>Game</title>","newString":"    <title>Lava Rise</title>","originalFile":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <title>Game</title>\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n</head>\n<body>\n    <div id=\"game-container\">\n        <canvas id=\"game-canvas\"></canvas>\n    </div>\n\n    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    <script src=\"js/poki.js\"></script>\n    <script src=\"js/audio.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>\n</body>\n</html>\n","structuredPatch":[{"oldStart":5,"oldLines":7,"newStart":5,"newLines":7,"lines":["     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">","     <meta name=\"mobile-web-app-capable\" content=\"yes\">","     <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">","-    <title>Game</title>","+    <title>Lava Rise</title>","     <link rel=\"stylesheet\" href=\"css/styles.css\">"," </head>"," <body>"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01XrwWrCnoAbpGd483dGbWoW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0185qBPuaULBd5dAbraR3opM","name":"Edit","input":{"replace_all":false,"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","old_string":"    <script src=\"js/audio.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>","new_string":"    <script src=\"js/audio.js\"></script>\n    <script src=\"js/lava-rise.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":219,"cache_read_input_tokens":55461,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":219},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"db34820a-f0da-4fc3-96da-3c37904a343f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0185qBPuaULBd5dAbraR3opM","type":"tool_result","content":"The file F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"ee7303a8-1349-4a27-8303-099f4b0556c9","tool_use_result":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","oldString":"    <script src=\"js/audio.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>","newString":"    <script src=\"js/audio.js\"></script>\n    <script src=\"js/lava-rise.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>","originalFile":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <title>Lava Rise</title>\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n</head>\n<body>\n    <div id=\"game-container\">\n        <canvas id=\"game-canvas\"></canvas>\n    </div>\n\n    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    <script src=\"js/poki.js\"></script>\n    <script src=\"js/audio.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>\n</body>\n</html>\n","structuredPatch":[{"oldStart":16,"oldLines":6,"newStart":16,"newLines":7,"lines":["     <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>","     <script src=\"js/poki.js\"></script>","     <script src=\"js/audio.js\"></script>","+    <script src=\"js/lava-rise.js\"></script>","     <script type=\"module\" src=\"js/main.js\"></script>"," </body>"," </html>"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01NCdWTDsgcfqe32MVkHgEKZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JHhrADpuPMdnGYyMfm615a","name":"TodoWrite","input":{"todos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"completed","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"completed","activeForm":"Updating index.html with new script tag"},{"content":"Review and polish the complete game","status":"in_progress","activeForm":"Reviewing and polishing the game"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":252,"cache_read_input_tokens":55680,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":252},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"72a3ca14-7241-4b32-a872-e598b5241ce4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JHhrADpuPMdnGYyMfm615a","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"eee08eda-2134-459e-a914-a88be25be674","tool_use_result":{"oldTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"in_progress","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"pending","activeForm":"Updating index.html with new script tag"},{"content":"Test and polish the complete game","status":"pending","activeForm":"Testing and polishing the game"}],"newTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"completed","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"completed","activeForm":"Updating index.html with new script tag"},{"content":"Review and polish the complete game","status":"in_progress","activeForm":"Reviewing and polishing the game"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01GJgn6cSrgBETEV8GKjFaJX","type":"message","role":"assistant","content":[{"type":"text","text":"Let me review the complete game for any issues - checking the game logic flow, coordinate system, and edge cases."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":254,"cache_read_input_tokens":55932,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":254},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"e5f03e39-2d6f-4527-b09b-143b0f955925"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01GJgn6cSrgBETEV8GKjFaJX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HiKULoWDrsz8QWctpV3tua","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":254,"cache_read_input_tokens":55932,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":254},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"fab1d9ee-fcb1-4ac9-819d-25ec04207555"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HiKULoWDrsz8QWctpV3tua","type":"tool_result","content":"     1â†’/**\n     2â†’ * Lava Rise - Complete game logic\n     3â†’ * Wall-jump between narrowing walls to outrun rising lava\n     4â†’ */\n     5â†’\n     6â†’var LavaRise = (function() {\n     7â†’    'use strict';\n     8â†’\n     9â†’    // -------------------------------------------------------\n    10â†’    // Constants\n    11â†’    // -------------------------------------------------------\n    12â†’    var VIRTUAL_W = 400;\n    13â†’    var PLAYER_W = 18;\n    14â†’    var PLAYER_H = 24;\n    15â†’    var GRAVITY = 1400;\n    16â†’    var JUMP_VY = -520;\n    17â†’    var JUMP_VX_BASE = 400;\n    18â†’    var WALL_THICKNESS = 40;\n    19â†’    var COIN_RADIUS = 10;\n    20â†’    var SPIKE_W = 20;\n    21â†’    var SPIKE_H = 16;\n    22â†’    var PLATFORM_W = 50;\n    23â†’    var PLATFORM_H = 10;\n    24â†’    var PARTICLE_POOL_SIZE = 200;\n    25â†’    var SLOW_MO_DURATION = 0.3;\n    26â†’    var SLOW_MO_FACTOR = 0.4;\n    27â†’    var SAFE_TIME = 5.0;\n    28â†’    var GAME_OVER_LOCKOUT = 0.8;\n    29â†’    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    30â†’    var LAVA_SPEED_MIN = 60;\n    31â†’    var LAVA_SPEED_MAX = 150;\n    32â†’    var WALL_GAP_MAX = 400;\n    33â†’    var WALL_GAP_MIN = 220;\n    34â†’    var CAMERA_LEAD = 0.3;\n    35â†’    var CAMERA_SMOOTH = 4.0;\n    36â†’\n    37â†’    // Colors\n    38â†’    var COL_BG_TOP = '#1a0a2e';\n    39â†’    var COL_BG_BOT = '#0d0015';\n    40â†’    var COL_WALL_LEFT = '#3a2a5c';\n    41â†’    var COL_WALL_RIGHT = '#3a2a5c';\n    42â†’    var COL_WALL_EDGE = '#6a4a9a';\n    43â†’    var COL_PLAYER = '#00e5ff';\n    44â†’    var COL_PLAYER_EYE = '#ffffff';\n    45â†’    var COL_COIN = '#ffd700';\n    46â†’    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    47â†’    var COL_SPIKE = '#ff3366';\n    48â†’    var COL_LAVA_TOP = '#ff4400';\n    49â†’    var COL_LAVA_MID = '#ff2200';\n    50â†’    var COL_LAVA_BOT = '#cc1100';\n    51â†’    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    52â†’    var COL_PLATFORM = '#8866bb';\n    53â†’    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    54â†’    var COL_SCORE = '#ffffff';\n    55â†’    var COL_HEIGHT = '#aaaaaa';\n    56â†’\n    57â†’    // -------------------------------------------------------\n    58â†’    // Procedural Audio\n    59â†’    // -------------------------------------------------------\n    60â†’    var SFX = {\n    61â†’        _ctx: null,\n    62â†’\n    63â†’        init: function() {\n    64â†’            if (GameAudio.ctx) {\n    65â†’                this._ctx = GameAudio.ctx;\n    66â†’            }\n    67â†’        },\n    68â†’\n    69â†’        _ensureCtx: function() {\n    70â†’            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n    71â†’            return this._ctx;\n    72â†’        },\n    73â†’\n    74â†’        jump: function() {\n    75â†’            var ctx = this._ensureCtx();\n    76â†’            if (!ctx) return;\n    77â†’            var osc = ctx.createOscillator();\n    78â†’            var gain = ctx.createGain();\n    79â†’            osc.type = 'square';\n    80â†’            osc.frequency.setValueAtTime(300, ctx.currentTime);\n    81â†’            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n    82â†’            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n    83â†’            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n    84â†’            osc.connect(gain);\n    85â†’            gain.connect(ctx.destination);\n    86â†’            osc.start(ctx.currentTime);\n    87â†’            osc.stop(ctx.currentTime + 0.1);\n    88â†’        },\n    89â†’\n    90â†’        wallHit: function() {\n    91â†’            var ctx = this._ensureCtx();\n    92â†’            if (!ctx) return;\n    93â†’            var osc = ctx.createOscillator();\n    94â†’            var gain = ctx.createGain();\n    95â†’            osc.type = 'triangle';\n    96â†’            osc.frequency.setValueAtTime(150, ctx.currentTime);\n    97â†’            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n    98â†’            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n    99â†’            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n   100â†’            osc.connect(gain);\n   101â†’            gain.connect(ctx.destination);\n   102â†’            osc.start(ctx.currentTime);\n   103â†’            osc.stop(ctx.currentTime + 0.08);\n   104â†’        },\n   105â†’\n   106â†’        coin: function(streak) {\n   107â†’            var ctx = this._ensureCtx();\n   108â†’            if (!ctx) return;\n   109â†’            var baseFreq = 800 + Math.min(streak, 10) * 80;\n   110â†’            var osc = ctx.createOscillator();\n   111â†’            var gain = ctx.createGain();\n   112â†’            osc.type = 'sine';\n   113â†’            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n   114â†’            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n   115â†’            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n   116â†’            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n   117â†’            osc.connect(gain);\n   118â†’            gain.connect(ctx.destination);\n   119â†’            osc.start(ctx.currentTime);\n   120â†’            osc.stop(ctx.currentTime + 0.15);\n   121â†’            // Harmonic\n   122â†’            var osc2 = ctx.createOscillator();\n   123â†’            var gain2 = ctx.createGain();\n   124â†’            osc2.type = 'sine';\n   125â†’            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n   126â†’            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n   127â†’            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n   128â†’            osc2.connect(gain2);\n   129â†’            gain2.connect(ctx.destination);\n   130â†’            osc2.start(ctx.currentTime + 0.05);\n   131â†’            osc2.stop(ctx.currentTime + 0.2);\n   132â†’        },\n   133â†’\n   134â†’        die: function() {\n   135â†’            var ctx = this._ensureCtx();\n   136â†’            if (!ctx) return;\n   137â†’            var osc = ctx.createOscillator();\n   138â†’            var gain = ctx.createGain();\n   139â†’            osc.type = 'sawtooth';\n   140â†’            osc.frequency.setValueAtTime(400, ctx.currentTime);\n   141â†’            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n   142â†’            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n   143â†’            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n   144â†’            osc.connect(gain);\n   145â†’            gain.connect(ctx.destination);\n   146â†’            osc.start(ctx.currentTime);\n   147â†’            osc.stop(ctx.currentTime + 0.4);\n   148â†’            // Noise burst\n   149â†’            var bufSize = ctx.sampleRate * 0.3;\n   150â†’            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n   151â†’            var data = buf.getChannelData(0);\n   152â†’            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n   153â†’            var noise = ctx.createBufferSource();\n   154â†’            noise.buffer = buf;\n   155â†’            var ng = ctx.createGain();\n   156â†’            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n   157â†’            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n   158â†’            noise.connect(ng);\n   159â†’            ng.connect(ctx.destination);\n   160â†’            noise.start(ctx.currentTime);\n   161â†’            noise.stop(ctx.currentTime + 0.3);\n   162â†’        },\n   163â†’\n   164â†’        lavaWarn: function() {\n   165â†’            var ctx = this._ensureCtx();\n   166â†’            if (!ctx) return;\n   167â†’            var osc = ctx.createOscillator();\n   168â†’            var gain = ctx.createGain();\n   169â†’            osc.type = 'sine';\n   170â†’            osc.frequency.setValueAtTime(100, ctx.currentTime);\n   171â†’            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n   172â†’            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n   173â†’            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n   174â†’            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n   175â†’            osc.connect(gain);\n   176â†’            gain.connect(ctx.destination);\n   177â†’            osc.start(ctx.currentTime);\n   178â†’            osc.stop(ctx.currentTime + 0.3);\n   179â†’        }\n   180â†’    };\n   181â†’\n   182â†’    // -------------------------------------------------------\n   183â†’    // Particle Pool\n   184â†’    // -------------------------------------------------------\n   185â†’    function ParticlePool(size) {\n   186â†’        this.pool = [];\n   187â†’        for (var i = 0; i < size; i++) {\n   188â†’            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n   189â†’        }\n   190â†’    }\n   191â†’\n   192â†’    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n   193â†’        for (var i = 0; i < this.pool.length; i++) {\n   194â†’            var p = this.pool[i];\n   195â†’            if (!p.alive) {\n   196â†’                p.alive = true;\n   197â†’                p.x = x; p.y = y;\n   198â†’                p.vx = vx; p.vy = vy;\n   199â†’                p.life = life; p.maxLife = life;\n   200â†’                p.r = r; p.g = g; p.b = b;\n   201â†’                p.size = size || 2;\n   202â†’                return p;\n   203â†’            }\n   204â†’        }\n   205â†’        return null;\n   206â†’    };\n   207â†’\n   208â†’    ParticlePool.prototype.update = function(dt) {\n   209â†’        for (var i = 0; i < this.pool.length; i++) {\n   210â†’            var p = this.pool[i];\n   211â†’            if (!p.alive) continue;\n   212â†’            p.life -= dt;\n   213â†’            if (p.life <= 0) { p.alive = false; continue; }\n   214â†’            p.x += p.vx * dt;\n   215â†’            p.y += p.vy * dt;\n   216â†’            p.vy += 200 * dt; // light gravity on particles\n   217â†’        }\n   218â†’    };\n   219â†’\n   220â†’    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n   221â†’        for (var i = 0; i < this.pool.length; i++) {\n   222â†’            var p = this.pool[i];\n   223â†’            if (!p.alive) continue;\n   224â†’            var alpha = p.life / p.maxLife;\n   225â†’            var sx = p.x * scale + offsetX;\n   226â†’            var sy = (p.y - camY) * scale;\n   227â†’            var sz = p.size * scale * alpha;\n   228â†’            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n   229â†’            ctx.globalAlpha = alpha;\n   230â†’            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n   231â†’            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n   232â†’        }\n   233â†’        ctx.globalAlpha = 1.0;\n   234â†’    };\n   235â†’\n   236â†’    ParticlePool.prototype.clear = function() {\n   237â†’        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n   238â†’    };\n   239â†’\n   240â†’    // -------------------------------------------------------\n   241â†’    // Score Popup Pool\n   242â†’    // -------------------------------------------------------\n   243â†’    function PopupPool() {\n   244â†’        this.popups = [];\n   245â†’    }\n   246â†’\n   247â†’    PopupPool.prototype.spawn = function(x, y, text, color) {\n   248â†’        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n   249â†’    };\n   250â†’\n   251â†’    PopupPool.prototype.update = function(dt) {\n   252â†’        for (var i = this.popups.length - 1; i >= 0; i--) {\n   253â†’            var p = this.popups[i];\n   254â†’            p.life -= dt;\n   255â†’            p.y -= 60 * dt;\n   256â†’            if (p.life <= 0) this.popups.splice(i, 1);\n   257â†’        }\n   258â†’    };\n   259â†’\n   260â†’    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n   261â†’        for (var i = 0; i < this.popups.length; i++) {\n   262â†’            var p = this.popups[i];\n   263â†’            var alpha = p.life / p.maxLife;\n   264â†’            var sx = p.x * scale + offsetX;\n   265â†’            var sy = (p.y - camY) * scale;\n   266â†’            ctx.globalAlpha = alpha;\n   267â†’            ctx.fillStyle = p.color;\n   268â†’            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n   269â†’            ctx.textAlign = 'center';\n   270â†’            ctx.fillText(p.text, sx, sy);\n   271â†’        }\n   272â†’        ctx.globalAlpha = 1.0;\n   273â†’    };\n   274â†’\n   275â†’    // -------------------------------------------------------\n   276â†’    // Main Game State\n   277â†’    // -------------------------------------------------------\n   278â†’    function State() {\n   279â†’        this.reset();\n   280â†’        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n   281â†’        this.popups = new PopupPool();\n   282â†’        this.highScore = 0;\n   283â†’        this.totalCoins = 0;\n   284â†’        try {\n   285â†’            var hs = localStorage.getItem('lavarise_hs');\n   286â†’            if (hs) this.highScore = parseInt(hs, 10) || 0;\n   287â†’            var tc = localStorage.getItem('lavarise_coins');\n   288â†’            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n   289â†’        } catch(e) {}\n   290â†’    }\n   291â†’\n   292â†’    State.prototype.reset = function() {\n   293â†’        this.playTime = 0;\n   294â†’        this.difficultyLevel = 0;\n   295â†’        this.score = 0;\n   296â†’        this.heightScore = 0;\n   297â†’        this.coinScore = 0;\n   298â†’        this.coinStreak = 0;\n   299â†’        this.coinStreakTimer = 0;\n   300â†’\n   301â†’        // Player\n   302â†’        this.px = VIRTUAL_W * 0.25;\n   303â†’        this.py = 0;\n   304â†’        this.pvx = 0;\n   305â†’        this.pvy = 0;\n   306â†’        this.pOnWall = 'left'; // 'left', 'right', 'air'\n   307â†’        this.pFacing = 1; // 1=right, -1=left\n   308â†’        this.pAlive = true;\n   309â†’        this.pInvincible = 0;\n   310â†’        this.pSquash = 1.0; // squash-stretch factor\n   311â†’\n   312â†’        // Camera\n   313â†’        this.camY = 0;\n   314â†’        this.camTargetY = 0;\n   315â†’\n   316â†’        // Lava\n   317â†’        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n   318â†’        this.lavaSpeed = LAVA_SPEED_MIN;\n   319â†’        this.lavaWarnTimer = 0;\n   320â†’\n   321â†’        // Walls\n   322â†’        this.wallGap = WALL_GAP_MAX;\n   323â†’        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n   324â†’        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n   325â†’\n   326â†’        // Obstacles and coins\n   327â†’        this.obstacles = [];\n   328â†’        this.coins = [];\n   329â†’        this.lastSpawnY = 0;\n   330â†’        this.spawnInterval = 120;\n   331â†’\n   332â†’        // Effects\n   333â†’        this.slowMoTimer = 0;\n   334â†’        this.shakeAmount = 0;\n   335â†’        this.shakeTimer = 0;\n   336â†’        this.gameOverTimer = 0;\n   337â†’        this.flashAlpha = 0;\n   338â†’\n   339â†’        if (this.particles) this.particles.clear();\n   340â†’        if (this.popups) this.popups = new PopupPool();\n   341â†’    };\n   342â†’\n   343â†’    // -------------------------------------------------------\n   344â†’    // Game Logic\n   345â†’    // -------------------------------------------------------\n   346â†’\n   347â†’    State.prototype.initGame = function() {\n   348â†’        this.reset();\n   349â†’        // Player starts on left wall, slightly above where lava will begin\n   350â†’        this.py = -50;\n   351â†’        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n   352â†’        this.pOnWall = 'left';\n   353â†’        this.pFacing = 1;\n   354â†’        this.pInvincible = SAFE_TIME;\n   355â†’        this.camY = this.py - 200;\n   356â†’        this.camTargetY = this.camY;\n   357â†’        this.lavaY = 200; // starts below player\n   358â†’\n   359â†’        // Seed some coins in the safe zone\n   360â†’        this._spawnCoin(-100);\n   361â†’        this._spawnCoin(-220);\n   362â†’        this._spawnCoin(-350);\n   363â†’\n   364â†’        SFX.init();\n   365â†’    };\n   366â†’\n   367â†’    State.prototype._getWallGap = function() {\n   368â†’        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n   369â†’    };\n   370â†’\n   371â†’    State.prototype._getWallLeft = function() {\n   372â†’        return (VIRTUAL_W - this._getWallGap()) / 2;\n   373â†’    };\n   374â†’\n   375â†’    State.prototype._getWallRight = function() {\n   376â†’        return (VIRTUAL_W + this._getWallGap()) / 2;\n   377â†’    };\n   378â†’\n   379â†’    State.prototype._spawnCoin = function(y) {\n   380â†’        var gap = this._getWallGap();\n   381â†’        var wl = this._getWallLeft();\n   382â†’        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n   383â†’        this.coins.push({\n   384â†’            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n   385â†’        });\n   386â†’    };\n   387â†’\n   388â†’    State.prototype._spawnObstacle = function(y) {\n   389â†’        var type = Math.random();\n   390â†’        var wl = this._getWallLeft();\n   391â†’        var wr = this._getWallRight();\n   392â†’\n   393â†’        if (type < 0.4) {\n   394â†’            // Spike on wall\n   395â†’            var side = Math.random() < 0.5 ? 'left' : 'right';\n   396â†’            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n   397â†’            this.obstacles.push({\n   398â†’                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n   399â†’            });\n   400â†’        } else if (type < 0.7) {\n   401â†’            // Moving platform\n   402â†’            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n   403â†’            var speed = 40 + Math.random() * 60;\n   404â†’            this.obstacles.push({\n   405â†’                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n   406â†’                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n   407â†’                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n   408â†’            });\n   409â†’        } else {\n   410â†’            // Crumbling ledge\n   411â†’            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n   412â†’            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n   413â†’            this.obstacles.push({\n   414â†’                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n   415â†’                side: side2, timer: 0, crumbling: false, fallen: false\n   416â†’            });\n   417â†’        }\n   418â†’    };\n   419â†’\n   420â†’    State.prototype.update = function(dt, tapped) {\n   421â†’        if (!this.pAlive) return;\n   422â†’\n   423â†’        // Slow-mo\n   424â†’        var effectiveDt = dt;\n   425â†’        if (this.slowMoTimer > 0) {\n   426â†’            this.slowMoTimer -= dt;\n   427â†’            effectiveDt = dt * SLOW_MO_FACTOR;\n   428â†’        }\n   429â†’\n   430â†’        this.playTime += effectiveDt;\n   431â†’        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n   432â†’\n   433â†’        // Invincibility\n   434â†’        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n   435â†’\n   436â†’        // Coin streak timeout\n   437â†’        if (this.coinStreakTimer > 0) {\n   438â†’            this.coinStreakTimer -= effectiveDt;\n   439â†’            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n   440â†’        }\n   441â†’\n   442â†’        // Wall narrowing\n   443â†’        this.wallGap = this._getWallGap();\n   444â†’        this.wallLeft = this._getWallLeft();\n   445â†’        this.wallRight = this._getWallRight();\n   446â†’\n   447â†’        // Lava rise\n   448â†’        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n   449â†’        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n   450â†’\n   451â†’        // Lava warning\n   452â†’        var lavaDistance = this.py - this.lavaY;\n   453â†’        if (lavaDistance < 150 && lavaDistance > 0) {\n   454â†’            this.lavaWarnTimer -= effectiveDt;\n   455â†’            if (this.lavaWarnTimer <= 0) {\n   456â†’                SFX.lavaWarn();\n   457â†’                this.lavaWarnTimer = 0.5;\n   458â†’            }\n   459â†’        }\n   460â†’\n   461â†’        // Jump input\n   462â†’        if (tapped && this.pOnWall !== 'air') {\n   463â†’            this._jump();\n   464â†’        }\n   465â†’\n   466â†’        // Physics\n   467â†’        if (this.pOnWall === 'air') {\n   468â†’            this.pvy += GRAVITY * effectiveDt;\n   469â†’            this.px += this.pvx * effectiveDt;\n   470â†’            this.py += this.pvy * effectiveDt;\n   471â†’\n   472â†’            // Wall collision\n   473â†’            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n   474â†’            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n   475â†’\n   476â†’            if (this.px <= leftEdge) {\n   477â†’                this.px = leftEdge;\n   478â†’                this.pOnWall = 'left';\n   479â†’                this.pFacing = 1;\n   480â†’                this.pvx = 0;\n   481â†’                this.pvy = 0;\n   482â†’                this.pSquash = 0.6;\n   483â†’                SFX.wallHit();\n   484â†’                this._spawnWallParticles('left');\n   485â†’            } else if (this.px >= rightEdge) {\n   486â†’                this.px = rightEdge;\n   487â†’                this.pOnWall = 'right';\n   488â†’                this.pFacing = -1;\n   489â†’                this.pvx = 0;\n   490â†’                this.pvy = 0;\n   491â†’                this.pSquash = 0.6;\n   492â†’                SFX.wallHit();\n   493â†’                this._spawnWallParticles('right');\n   494â†’            }\n   495â†’\n   496â†’            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n   497â†’        } else {\n   498â†’            // On wall - slide down slowly\n   499â†’            this.pvy = 30; // gentle slide\n   500â†’            this.py += this.pvy * effectiveDt;\n   501â†’\n   502â†’            // Keep within wall bounds\n   503â†’            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n   504â†’            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n   505â†’            if (this.pOnWall === 'left') this.px = le;\n   506â†’            else this.px = re;\n   507â†’        }\n   508â†’\n   509â†’        // Squash recovery\n   510â†’        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n   511â†’\n   512â†’        // Obstacle updates\n   513â†’        this._updateObstacles(effectiveDt);\n   514â†’\n   515â†’        // Coin collection\n   516â†’        this._updateCoins(effectiveDt);\n   517â†’\n   518â†’        // Collision with obstacles\n   519â†’        if (this.pInvincible <= 0) {\n   520â†’            this._checkObstacleCollisions();\n   521â†’        }\n   522â†’\n   523â†’        // Lava death\n   524â†’        if (this.py > this.lavaY - PLAYER_H / 2) {\n   525â†’            this._die('lava');\n   526â†’            return;\n   527â†’        }\n   528â†’\n   529â†’        // Spawn new content ahead\n   530â†’        this._spawnContent();\n   531â†’\n   532â†’        // Height score (negative Y = higher)\n   533â†’        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n   534â†’        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n   535â†’        this.score = this.heightScore + this.coinScore;\n   536â†’\n   537â†’        // Camera\n   538â†’        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n   539â†’        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n   540â†’\n   541â†’        // Cleanup off-screen objects\n   542â†’        this._cleanup();\n   543â†’\n   544â†’        // Effects\n   545â†’        this.shakeTimer -= effectiveDt;\n   546â†’        if (this.shakeTimer < 0) this.shakeTimer = 0;\n   547â†’        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n   548â†’\n   549â†’        this.flashAlpha -= effectiveDt * 3;\n   550â†’        if (this.flashAlpha < 0) this.flashAlpha = 0;\n   551â†’\n   552â†’        // Particles\n   553â†’        this.particles.update(effectiveDt);\n   554â†’        this.popups.update(effectiveDt);\n   555â†’\n   556â†’        // Lava particles\n   557â†’        this._spawnLavaParticles(effectiveDt);\n   558â†’    };\n   559â†’\n   560â†’    State.prototype._jump = function() {\n   561â†’        var dir = this.pOnWall === 'left' ? 1 : -1;\n   562â†’        this.pvx = JUMP_VX_BASE * dir;\n   563â†’        this.pvy = JUMP_VY;\n   564â†’        this.pOnWall = 'air';\n   565â†’        this.pFacing = dir;\n   566â†’        this.pSquash = 1.4; // stretch on jump\n   567â†’        SFX.jump();\n   568â†’\n   569â†’        // Jump particles\n   570â†’        for (var i = 0; i < 5; i++) {\n   571â†’            var angle = Math.random() * Math.PI - Math.PI / 2;\n   572â†’            var speed = 50 + Math.random() * 80;\n   573â†’            this.particles.spawn(\n   574â†’                this.px, this.py,\n   575â†’                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n   576â†’                0.3 + Math.random() * 0.2,\n   577â†’                0, 229, 255, 3\n   578â†’            );\n   579â†’        }\n   580â†’    };\n   581â†’\n   582â†’    State.prototype._spawnWallParticles = function(side) {\n   583â†’        for (var i = 0; i < 6; i++) {\n   584â†’            var dir = side === 'left' ? 1 : -1;\n   585â†’            this.particles.spawn(\n   586â†’                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n   587â†’                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n   588â†’                0.2 + Math.random() * 0.2,\n   589â†’                100, 80, 160, 3\n   590â†’            );\n   591â†’        }\n   592â†’    };\n   593â†’\n   594â†’    State.prototype._updateObstacles = function(dt) {\n   595â†’        for (var i = 0; i < this.obstacles.length; i++) {\n   596â†’            var obs = this.obstacles[i];\n   597â†’            if (obs.type === 'platform') {\n   598â†’                obs.x += obs.speed * obs.dir * dt;\n   599â†’                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n   600â†’                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n   601â†’            }\n   602â†’            if (obs.type === 'crumble' && obs.crumbling) {\n   603â†’                obs.timer += dt;\n   604â†’                if (obs.timer > 0.5) obs.fallen = true;\n   605â†’            }\n   606â†’        }\n   607â†’    };\n   608â†’\n   609â†’    State.prototype._updateCoins = function(dt) {\n   610â†’        var px = this.px, py = this.py;\n   611â†’        for (var i = 0; i < this.coins.length; i++) {\n   612â†’            var c = this.coins[i];\n   613â†’            if (c.collected) continue;\n   614â†’            c.bobPhase += dt * 3;\n   615â†’\n   616â†’            var dx = px - c.x;\n   617â†’            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n   618â†’            var dist = Math.sqrt(dx * dx + dy * dy);\n   619â†’            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n   620â†’                c.collected = true;\n   621â†’                this.coinStreak++;\n   622â†’                this.coinStreakTimer = 2.0;\n   623â†’                var points = 10 * Math.min(this.coinStreak, 10);\n   624â†’                this.coinScore += points;\n   625â†’                this.totalCoins++;\n   626â†’                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n   627â†’\n   628â†’                // Slow-mo\n   629â†’                this.slowMoTimer = SLOW_MO_DURATION;\n   630â†’\n   631â†’                // Effects\n   632â†’                this.flashAlpha = 0.3;\n   633â†’                SFX.coin(this.coinStreak);\n   634â†’                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n   635â†’\n   636â†’                // Coin burst particles\n   637â†’                for (var j = 0; j < 8; j++) {\n   638â†’                    var angle = (j / 8) * Math.PI * 2;\n   639â†’                    this.particles.spawn(\n   640â†’                        c.x, c.y,\n   641â†’                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n   642â†’                        0.4, 255, 215, 0, 3\n   643â†’                    );\n   644â†’                }\n   645â†’            }\n   646â†’        }\n   647â†’    };\n   648â†’\n   649â†’    State.prototype._checkObstacleCollisions = function() {\n   650â†’        var px = this.px, py = this.py;\n   651â†’        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n   652â†’        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n   653â†’\n   654â†’        for (var i = 0; i < this.obstacles.length; i++) {\n   655â†’            var obs = this.obstacles[i];\n   656â†’            if (obs.type === 'crumble' && obs.fallen) continue;\n   657â†’\n   658â†’            if (obs.type === 'spike') {\n   659â†’                // AABB\n   660â†’                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n   661â†’                    this._die('spike');\n   662â†’                    return;\n   663â†’                }\n   664â†’            }\n   665â†’\n   666â†’            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n   667â†’                // Land on top\n   668â†’                if (this.pvy > 0 && this.pOnWall === 'air') {\n   669â†’                    if (pl < obs.x + obs.w && pr > obs.x &&\n   670â†’                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n   671â†’                        py - ph / 2 < obs.y) {\n   672â†’                        // Landing on platform\n   673â†’                        // For crumbling, start crumble timer\n   674â†’                        if (obs.type === 'crumble' && !obs.crumbling) {\n   675â†’                            obs.crumbling = true;\n   676â†’                            obs.timer = 0;\n   677â†’                        }\n   678â†’                    }\n   679â†’                }\n   680â†’                // Side collision with platform acts like a small wall\n   681â†’                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n   682â†’                    // Push player out horizontally if mostly horizontal collision\n   683â†’                    var overlapL = pr - obs.x;\n   684â†’                    var overlapR = obs.x + obs.w - pl;\n   685â†’                    var overlapT = pb - obs.y;\n   686â†’                    var overlapB = obs.y + obs.h - pt;\n   687â†’                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n   688â†’                    if (minOverlap === overlapT && this.pvy > 0) {\n   689â†’                        // Land on top\n   690â†’                        this.py = obs.y - ph / 2;\n   691â†’                        if (obs.type === 'crumble' && !obs.crumbling) {\n   692â†’                            obs.crumbling = true;\n   693â†’                            obs.timer = 0;\n   694â†’                        }\n   695â†’                    }\n   696â†’                }\n   697â†’            }\n   698â†’        }\n   699â†’    };\n   700â†’\n   701â†’    State.prototype._die = function(cause) {\n   702â†’        if (!this.pAlive) return;\n   703â†’        this.pAlive = false;\n   704â†’        SFX.die();\n   705â†’        this.shakeAmount = 8;\n   706â†’        this.shakeTimer = 0.4;\n   707â†’        this.flashAlpha = 0.5;\n   708â†’        this.gameOverTimer = 0;\n   709â†’\n   710â†’        // Death particles\n   711â†’        for (var i = 0; i < 20; i++) {\n   712â†’            var angle = (i / 20) * Math.PI * 2;\n   713â†’            var speed = 80 + Math.random() * 120;\n   714â†’            var r = cause === 'lava' ? 255 : 255;\n   715â†’            var g = cause === 'lava' ? 68 : 51;\n   716â†’            var b = cause === 'lava' ? 0 : 102;\n   717â†’            this.particles.spawn(\n   718â†’                this.px, this.py,\n   719â†’                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n   720â†’                0.5 + Math.random() * 0.3,\n   721â†’                r, g, b, 4\n   722â†’            );\n   723â†’        }\n   724â†’\n   725â†’        // Save high score\n   726â†’        if (this.score > this.highScore) {\n   727â†’            this.highScore = this.score;\n   728â†’            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n   729â†’        }\n   730â†’    };\n   731â†’\n   732â†’    State.prototype._spawnContent = function() {\n   733â†’        // Spawn ahead of camera (negative Y is up)\n   734â†’        var spawnAhead = this.camY - 500;\n   735â†’        while (this.lastSpawnY > spawnAhead) {\n   736â†’            this.lastSpawnY -= this.spawnInterval;\n   737â†’\n   738â†’            // Don't spawn obstacles during safe time\n   739â†’            if (this.playTime > SAFE_TIME) {\n   740â†’                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n   741â†’                if (Math.random() < obstacleChance) {\n   742â†’                    this._spawnObstacle(this.lastSpawnY);\n   743â†’                }\n   744â†’            }\n   745â†’\n   746â†’            // Always spawn coins (good density)\n   747â†’            if (Math.random() < 0.5) {\n   748â†’                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n   749â†’            }\n   750â†’\n   751â†’            // Decrease spawn interval with difficulty\n   752â†’            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n   753â†’        }\n   754â†’    };\n   755â†’\n   756â†’    var _lavaParticleTimer = 0;\n   757â†’    State.prototype._spawnLavaParticles = function(dt) {\n   758â†’        _lavaParticleTimer += dt;\n   759â†’        if (_lavaParticleTimer < 0.05) return;\n   760â†’        _lavaParticleTimer = 0;\n   761â†’\n   762â†’        // Spawn bubbles along lava surface\n   763â†’        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n   764â†’        this.particles.spawn(\n   765â†’            x, this.lavaY,\n   766â†’            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n   767â†’            0.5 + Math.random() * 0.5,\n   768â†’            255, Math.floor(40 + Math.random() * 60), 0, 4\n   769â†’        );\n   770â†’    };\n   771â†’\n   772â†’    State.prototype._cleanup = function() {\n   773â†’        var below = this.lavaY + 100;\n   774â†’        // Remove coins below lava\n   775â†’        for (var i = this.coins.length - 1; i >= 0; i--) {\n   776â†’            if (this.coins[i].y > below || this.coins[i].collected) {\n   777â†’                this.coins.splice(i, 1);\n   778â†’            }\n   779â†’        }\n   780â†’        // Remove obstacles below lava\n   781â†’        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n   782â†’            if (this.obstacles[j].y > below) {\n   783â†’                this.obstacles.splice(j, 1);\n   784â†’            }\n   785â†’        }\n   786â†’    };\n   787â†’\n   788â†’    // -------------------------------------------------------\n   789â†’    // Rendering\n   790â†’    // -------------------------------------------------------\n   791â†’\n   792â†’    function Renderer() {}\n   793â†’\n   794â†’    Renderer.prototype.render = function(ctx, canvas, state) {\n   795â†’        var cw = canvas.width;\n   796â†’        var ch = canvas.height;\n   797â†’\n   798â†’        // Virtual coordinate mapping\n   799â†’        var scale = cw / VIRTUAL_W;\n   800â†’        var virtualH = ch / scale;\n   801â†’        var offsetX = 0;\n   802â†’\n   803â†’        // Screen shake\n   804â†’        var shakeX = 0, shakeY = 0;\n   805â†’        if (state.shakeTimer > 0) {\n   806â†’            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n   807â†’            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n   808â†’        }\n   809â†’\n   810â†’        ctx.save();\n   811â†’        ctx.translate(shakeX, shakeY);\n   812â†’\n   813â†’        // Background gradient\n   814â†’        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n   815â†’        bgGrad.addColorStop(0, COL_BG_TOP);\n   816â†’        bgGrad.addColorStop(1, COL_BG_BOT);\n   817â†’        ctx.fillStyle = bgGrad;\n   818â†’        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n   819â†’\n   820â†’        // Background stars (parallax)\n   821â†’        this._renderStars(ctx, cw, ch, state.camY);\n   822â†’\n   823â†’        // Walls\n   824â†’        this._renderWalls(ctx, state, scale, offsetX, ch);\n   825â†’\n   826â†’        // Obstacles\n   827â†’        this._renderObstacles(ctx, state, scale, offsetX);\n   828â†’\n   829â†’        // Coins\n   830â†’        this._renderCoins(ctx, state, scale, offsetX);\n   831â†’\n   832â†’        // Player\n   833â†’        if (state.pAlive) {\n   834â†’            this._renderPlayer(ctx, state, scale, offsetX);\n   835â†’        }\n   836â†’\n   837â†’        // Particles\n   838â†’        state.particles.render(ctx, state.camY, scale, offsetX);\n   839â†’\n   840â†’        // Lava\n   841â†’        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n   842â†’\n   843â†’        // Popups\n   844â†’        state.popups.render(ctx, state.camY, scale, offsetX);\n   845â†’\n   846â†’        ctx.restore();\n   847â†’\n   848â†’        // Flash overlay\n   849â†’        if (state.flashAlpha > 0) {\n   850â†’            ctx.globalAlpha = state.flashAlpha;\n   851â†’            ctx.fillStyle = '#fff';\n   852â†’            ctx.fillRect(0, 0, cw, ch);\n   853â†’            ctx.globalAlpha = 1;\n   854â†’        }\n   855â†’\n   856â†’        // HUD (not affected by shake)\n   857â†’        this._renderHUD(ctx, cw, ch, state);\n   858â†’    };\n   859â†’\n   860â†’    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n   861â†’        // Simple deterministic stars\n   862â†’        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n   863â†’        var seed = 42;\n   864â†’        for (var i = 0; i < 40; i++) {\n   865â†’            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n   866â†’            var sx = (seed % cw);\n   867â†’            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n   868â†’            var sy = (seed % (ch * 3));\n   869â†’            var parallax = 0.05;\n   870â†’            var screenY = (sy - camY * parallax) % (ch * 3);\n   871â†’            if (screenY < 0) screenY += ch * 3;\n   872â†’            if (screenY < ch) {\n   873â†’                var size = 1 + (i % 3);\n   874â†’                ctx.fillRect(sx, screenY, size, size);\n   875â†’            }\n   876â†’        }\n   877â†’    };\n   878â†’\n   879â†’    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n   880â†’        var camY = state.camY;\n   881â†’        var topY = 0;\n   882â†’        var botY = ch;\n   883â†’\n   884â†’        // Left wall\n   885â†’        var lwScreen = state.wallLeft * scale + offsetX;\n   886â†’        var lwWidth = (WALL_THICKNESS) * scale;\n   887â†’        ctx.fillStyle = COL_WALL_LEFT;\n   888â†’        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n   889â†’        // Edge highlight\n   890â†’        ctx.fillStyle = COL_WALL_EDGE;\n   891â†’        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n   892â†’\n   893â†’        // Right wall\n   894â†’        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n   895â†’        ctx.fillStyle = COL_WALL_RIGHT;\n   896â†’        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n   897â†’        // Edge highlight\n   898â†’        ctx.fillStyle = COL_WALL_EDGE;\n   899â†’        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n   900â†’\n   901â†’        // Wall bricks pattern\n   902â†’        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n   903â†’        var brickH = 20 * scale;\n   904â†’        var startBrickY = Math.floor(camY / 20) * 20;\n   905â†’        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n   906â†’            var sy = (by - camY) * scale;\n   907â†’            var offset = ((by / 20) % 2) * 10 * scale;\n   908â†’            // Left wall bricks\n   909â†’            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n   910â†’                ctx.fillRect(bx + offset, sy, 1, brickH);\n   911â†’            }\n   912â†’            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n   913â†’            // Right wall bricks\n   914â†’            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n   915â†’                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n   916â†’            }\n   917â†’            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n   918â†’        }\n   919â†’    };\n   920â†’\n   921â†’    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n   922â†’        var camY = state.camY;\n   923â†’        for (var i = 0; i < state.obstacles.length; i++) {\n   924â†’            var obs = state.obstacles[i];\n   925â†’            var sx = obs.x * scale + offsetX;\n   926â†’            var sy = (obs.y - camY) * scale;\n   927â†’            var sw = obs.w * scale;\n   928â†’            var sh = obs.h * scale;\n   929â†’\n   930â†’            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n   931â†’\n   932â†’            if (obs.type === 'spike') {\n   933â†’                ctx.fillStyle = COL_SPIKE;\n   934â†’                ctx.beginPath();\n   935â†’                if (obs.side === 'left') {\n   936â†’                    ctx.moveTo(sx, sy + sh);\n   937â†’                    ctx.lineTo(sx + sw, sy + sh);\n   938â†’                    ctx.lineTo(sx + sw / 2, sy);\n   939â†’                } else {\n   940â†’                    ctx.moveTo(sx, sy + sh);\n   941â†’                    ctx.lineTo(sx + sw, sy + sh);\n   942â†’                    ctx.lineTo(sx + sw / 2, sy);\n   943â†’                }\n   944â†’                ctx.closePath();\n   945â†’                ctx.fill();\n   946â†’                // Glow\n   947â†’                ctx.shadowColor = COL_SPIKE;\n   948â†’                ctx.shadowBlur = 6 * scale;\n   949â†’                ctx.fill();\n   950â†’                ctx.shadowBlur = 0;\n   951â†’            } else if (obs.type === 'platform') {\n   952â†’                ctx.fillStyle = COL_PLATFORM;\n   953â†’                ctx.fillRect(sx, sy, sw, sh);\n   954â†’                // Top highlight\n   955â†’                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n   956â†’                ctx.fillRect(sx, sy, sw, 2 * scale);\n   957â†’            } else if (obs.type === 'crumble') {\n   958â†’                if (obs.fallen) continue;\n   959â†’                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n   960â†’                ctx.globalAlpha = alpha;\n   961â†’                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n   962â†’                // Shake if crumbling\n   963â†’                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n   964â†’                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n   965â†’                ctx.globalAlpha = 1;\n   966â†’            }\n   967â†’        }\n   968â†’    };\n   969â†’\n   970â†’    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n   971â†’        var camY = state.camY;\n   972â†’        for (var i = 0; i < state.coins.length; i++) {\n   973â†’            var c = state.coins[i];\n   974â†’            if (c.collected) continue;\n   975â†’            var sx = c.x * scale + offsetX;\n   976â†’            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n   977â†’            var sr = COIN_RADIUS * scale;\n   978â†’\n   979â†’            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n   980â†’\n   981â†’            // Glow\n   982â†’            ctx.beginPath();\n   983â†’            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n   984â†’            ctx.fillStyle = COL_COIN_GLOW;\n   985â†’            ctx.fill();\n   986â†’\n   987â†’            // Coin body\n   988â†’            ctx.beginPath();\n   989â†’            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n   990â†’            ctx.fillStyle = COL_COIN;\n   991â†’            ctx.fill();\n   992â†’\n   993â†’            // Shine\n   994â†’            ctx.beginPath();\n   995â†’            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n   996â†’            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n   997â†’            ctx.fill();\n   998â†’        }\n   999â†’    };\n  1000â†’\n  1001â†’    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n  1002â†’        var sx = state.px * scale + offsetX;\n  1003â†’        var sy = (state.py - state.camY) * scale;\n  1004â†’        var sw = PLAYER_W * scale;\n  1005â†’        var sh = PLAYER_H * scale;\n  1006â†’\n  1007â†’        // Invincibility blink\n  1008â†’        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n  1009â†’            ctx.globalAlpha = 0.5;\n  1010â†’        }\n  1011â†’\n  1012â†’        // Squash-stretch\n  1013â†’        var squashX = 1 / state.pSquash;\n  1014â†’        var squashY = state.pSquash;\n  1015â†’\n  1016â†’        ctx.save();\n  1017â†’        ctx.translate(sx, sy);\n  1018â†’        ctx.scale(squashX, squashY);\n  1019â†’\n  1020â†’        // Body\n  1021â†’        ctx.fillStyle = COL_PLAYER;\n  1022â†’        ctx.shadowColor = COL_PLAYER;\n  1023â†’        ctx.shadowBlur = 8 * scale;\n  1024â†’        var bodyW = sw;\n  1025â†’        var bodyH = sh;\n  1026â†’        // Rounded rectangle body\n  1027â†’        var r = 4 * scale;\n  1028â†’        ctx.beginPath();\n  1029â†’        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n  1030â†’        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n  1031â†’        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n  1032â†’        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n  1033â†’        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n  1034â†’        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n  1035â†’        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n  1036â†’        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n  1037â†’        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n  1038â†’        ctx.closePath();\n  1039â†’        ctx.fill();\n  1040â†’        ctx.shadowBlur = 0;\n  1041â†’\n  1042â†’        // Eyes\n  1043â†’        var eyeOffX = state.pFacing * 3 * scale;\n  1044â†’        var eyeY = -3 * scale;\n  1045â†’        ctx.fillStyle = COL_PLAYER_EYE;\n  1046â†’        ctx.beginPath();\n  1047â†’        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n  1048â†’        ctx.fill();\n  1049â†’        ctx.beginPath();\n  1050â†’        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n  1051â†’        ctx.fill();\n  1052â†’\n  1053â†’        // Pupils (look in movement direction)\n  1054â†’        ctx.fillStyle = '#222';\n  1055â†’        var pupilOff = state.pFacing * 1 * scale;\n  1056â†’        ctx.beginPath();\n  1057â†’        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n  1058â†’        ctx.fill();\n  1059â†’        ctx.beginPath();\n  1060â†’        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n  1061â†’        ctx.fill();\n  1062â†’\n  1063â†’        ctx.restore();\n  1064â†’        ctx.globalAlpha = 1;\n  1065â†’    };\n  1066â†’\n  1067â†’    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n  1068â†’        var lavaScreenY = (state.lavaY - state.camY) * scale;\n  1069â†’        if (lavaScreenY > ch + 50) return;\n  1070â†’\n  1071â†’        var topY = Math.max(0, lavaScreenY - 10 * scale);\n  1072â†’\n  1073â†’        // Lava glow above surface\n  1074â†’        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n  1075â†’        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n  1076â†’        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n  1077â†’        ctx.fillStyle = glowGrad;\n  1078â†’        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n  1079â†’\n  1080â†’        // Lava surface wave\n  1081â†’        ctx.beginPath();\n  1082â†’        ctx.moveTo(0, ch);\n  1083â†’        ctx.lineTo(0, lavaScreenY);\n  1084â†’        var waveTime = state.playTime * 2;\n  1085â†’        for (var x = 0; x <= cw; x += 4) {\n  1086â†’            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n  1087â†’                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n  1088â†’            ctx.lineTo(x, waveY);\n  1089â†’        }\n  1090â†’        ctx.lineTo(cw, ch);\n  1091â†’        ctx.closePath();\n  1092â†’\n  1093â†’        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n  1094â†’        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n  1095â†’        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n  1096â†’        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n  1097â†’        ctx.fillStyle = lavaGrad;\n  1098â†’        ctx.fill();\n  1099â†’\n  1100â†’        // Surface highlight\n  1101â†’        ctx.strokeStyle = '#ff8800';\n  1102â†’        ctx.lineWidth = 2 * scale;\n  1103â†’        ctx.beginPath();\n  1104â†’        for (var x2 = 0; x2 <= cw; x2 += 4) {\n  1105â†’            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n  1106â†’                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n  1107â†’            if (x2 === 0) ctx.moveTo(x2, waveY2);\n  1108â†’            else ctx.lineTo(x2, waveY2);\n  1109â†’        }\n  1110â†’        ctx.stroke();\n  1111â†’    };\n  1112â†’\n  1113â†’    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n  1114â†’        var pad = Math.max(12, cw * 0.03);\n  1115â†’        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n  1116â†’\n  1117â†’        // Score\n  1118â†’        ctx.fillStyle = COL_SCORE;\n  1119â†’        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n  1120â†’        ctx.textAlign = 'left';\n  1121â†’        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n  1122â†’\n  1123â†’        // Height indicator\n  1124â†’        ctx.fillStyle = COL_HEIGHT;\n  1125â†’        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n  1126â†’        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n  1127â†’\n  1128â†’        // Coin streak\n  1129â†’        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n  1130â†’            ctx.fillStyle = COL_COIN;\n  1131â†’            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n  1132â†’            ctx.textAlign = 'right';\n  1133â†’            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n  1134â†’            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n  1135â†’            ctx.globalAlpha = 1;\n  1136â†’        }\n  1137â†’\n  1138â†’        // High score (small, top right)\n  1139â†’        if (state.highScore > 0) {\n  1140â†’            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n  1141â†’            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n  1142â†’            ctx.textAlign = 'right';\n  1143â†’            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n  1144â†’        }\n  1145â†’\n  1146â†’        // Lava proximity warning\n  1147â†’        var lavaDist = state.py - state.lavaY;\n  1148â†’        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n  1149â†’            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n  1150â†’            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n  1151â†’            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n  1152â†’        }\n  1153â†’    };\n  1154â†’\n  1155â†’    // -------------------------------------------------------\n  1156â†’    // Menu / Game Over rendering\n  1157â†’    // -------------------------------------------------------\n  1158â†’\n  1159â†’    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n  1160â†’        // Background\n  1161â†’        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n  1162â†’        bgGrad.addColorStop(0, COL_BG_TOP);\n  1163â†’        bgGrad.addColorStop(1, '#1a0505');\n  1164â†’        ctx.fillStyle = bgGrad;\n  1165â†’        ctx.fillRect(0, 0, cw, ch);\n  1166â†’\n  1167â†’        // Decorative lava at bottom\n  1168â†’        var lavaH = ch * 0.25;\n  1169â†’        var lavaTop = ch - lavaH;\n  1170â†’        ctx.beginPath();\n  1171â†’        ctx.moveTo(0, ch);\n  1172â†’        for (var x = 0; x <= cw; x += 4) {\n  1173â†’            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n  1174â†’            ctx.lineTo(x, wy);\n  1175â†’        }\n  1176â†’        ctx.lineTo(cw, ch);\n  1177â†’        ctx.closePath();\n  1178â†’        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n  1179â†’        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n  1180â†’        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n  1181â†’        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n  1182â†’        ctx.fillStyle = lavaGrad;\n  1183â†’        ctx.fill();\n  1184â†’\n  1185â†’        // Glow\n  1186â†’        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n  1187â†’        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n  1188â†’        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n  1189â†’        ctx.fillStyle = glowGrad;\n  1190â†’        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n  1191â†’\n  1192â†’        // Title\n  1193â†’        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n  1194â†’        var centerY = ch * 0.32;\n  1195â†’        ctx.fillStyle = COL_LAVA_TOP;\n  1196â†’        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n  1197â†’        ctx.textAlign = 'center';\n  1198â†’        ctx.shadowColor = '#ff4400';\n  1199â†’        ctx.shadowBlur = 20;\n  1200â†’        ctx.fillText('LAVA RISE', cw / 2, centerY);\n  1201â†’        ctx.shadowBlur = 0;\n  1202â†’\n  1203â†’        // Subtitle\n  1204â†’        ctx.fillStyle = COL_PLAYER;\n  1205â†’        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n  1206â†’        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n  1207â†’\n  1208â†’        // Tap prompt (pulsing)\n  1209â†’        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n  1210â†’        ctx.globalAlpha = pulseAlpha;\n  1211â†’        ctx.fillStyle = '#ffffff';\n  1212â†’        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n  1213â†’        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n  1214â†’        ctx.globalAlpha = 1;\n  1215â†’\n  1216â†’        // High score\n  1217â†’        if (state.highScore > 0) {\n  1218â†’            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n  1219â†’            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n  1220â†’            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n  1221â†’        }\n  1222â†’\n  1223â†’        // Small player character preview (bouncing)\n  1224â†’        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n  1225â†’        var ps = Math.max(1, cw / VIRTUAL_W);\n  1226â†’        ctx.fillStyle = COL_PLAYER;\n  1227â†’        ctx.shadowColor = COL_PLAYER;\n  1228â†’        ctx.shadowBlur = 10;\n  1229â†’        var pw = PLAYER_W * ps;\n  1230â†’        var ph = PLAYER_H * ps;\n  1231â†’        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n  1232â†’        ctx.shadowBlur = 0;\n  1233â†’        // Eyes\n  1234â†’        ctx.fillStyle = '#fff';\n  1235â†’        ctx.beginPath();\n  1236â†’        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n  1237â†’        ctx.fill();\n  1238â†’        ctx.beginPath();\n  1239â†’        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n  1240â†’        ctx.fill();\n  1241â†’    };\n  1242â†’\n  1243â†’    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n  1244â†’        // Darken\n  1245â†’        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n  1246â†’        ctx.fillRect(0, 0, cw, ch);\n  1247â†’\n  1248â†’        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n  1249â†’        var centerY = ch * 0.3;\n  1250â†’\n  1251â†’        // Game over text\n  1252â†’        ctx.fillStyle = '#ff3333';\n  1253â†’        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n  1254â†’        ctx.textAlign = 'center';\n  1255â†’        ctx.fillText('GAME OVER', cw / 2, centerY);\n  1256â†’\n  1257â†’        // Score\n  1258â†’        ctx.fillStyle = '#ffffff';\n  1259â†’        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n  1260â†’        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n  1261â†’\n  1262â†’        // Height and coins\n  1263â†’        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n  1264â†’        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n  1265â†’        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n  1266â†’\n  1267â†’        // New high score?\n  1268â†’        if (state.score >= state.highScore && state.score > 0) {\n  1269â†’            ctx.fillStyle = COL_COIN;\n  1270â†’            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n  1271â†’            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n  1272â†’        }\n  1273â†’\n  1274â†’        // Restart prompt\n  1275â†’        if (canRestart) {\n  1276â†’            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n  1277â†’            ctx.globalAlpha = pulseAlpha;\n  1278â†’            ctx.fillStyle = '#ffffff';\n  1279â†’            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n  1280â†’            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n  1281â†’            ctx.globalAlpha = 1;\n  1282â†’        }\n  1283â†’    };\n  1284â†’\n  1285â†’    // -------------------------------------------------------\n  1286â†’    // Public API\n  1287â†’    // -------------------------------------------------------\n  1288â†’    return {\n  1289â†’        State: State,\n  1290â†’        Renderer: Renderer,\n  1291â†’        SFX: SFX,\n  1292â†’        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n  1293â†’    };\n  1294â†’\n  1295â†’})();\n  1296â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"c30b8f00-ebe7-43f4-98cf-1232cf828127","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","content":"/**\n * Lava Rise - Complete game logic\n * Wall-jump between narrowing walls to outrun rising lava\n */\n\nvar LavaRise = (function() {\n    'use strict';\n\n    // -------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------\n    var VIRTUAL_W = 400;\n    var PLAYER_W = 18;\n    var PLAYER_H = 24;\n    var GRAVITY = 1400;\n    var JUMP_VY = -520;\n    var JUMP_VX_BASE = 400;\n    var WALL_THICKNESS = 40;\n    var COIN_RADIUS = 10;\n    var SPIKE_W = 20;\n    var SPIKE_H = 16;\n    var PLATFORM_W = 50;\n    var PLATFORM_H = 10;\n    var PARTICLE_POOL_SIZE = 200;\n    var SLOW_MO_DURATION = 0.3;\n    var SLOW_MO_FACTOR = 0.4;\n    var SAFE_TIME = 5.0;\n    var GAME_OVER_LOCKOUT = 0.8;\n    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    var LAVA_SPEED_MIN = 60;\n    var LAVA_SPEED_MAX = 150;\n    var WALL_GAP_MAX = 400;\n    var WALL_GAP_MIN = 220;\n    var CAMERA_LEAD = 0.3;\n    var CAMERA_SMOOTH = 4.0;\n\n    // Colors\n    var COL_BG_TOP = '#1a0a2e';\n    var COL_BG_BOT = '#0d0015';\n    var COL_WALL_LEFT = '#3a2a5c';\n    var COL_WALL_RIGHT = '#3a2a5c';\n    var COL_WALL_EDGE = '#6a4a9a';\n    var COL_PLAYER = '#00e5ff';\n    var COL_PLAYER_EYE = '#ffffff';\n    var COL_COIN = '#ffd700';\n    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    var COL_SPIKE = '#ff3366';\n    var COL_LAVA_TOP = '#ff4400';\n    var COL_LAVA_MID = '#ff2200';\n    var COL_LAVA_BOT = '#cc1100';\n    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    var COL_PLATFORM = '#8866bb';\n    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    var COL_SCORE = '#ffffff';\n    var COL_HEIGHT = '#aaaaaa';\n\n    // -------------------------------------------------------\n    // Procedural Audio\n    // -------------------------------------------------------\n    var SFX = {\n        _ctx: null,\n\n        init: function() {\n            if (GameAudio.ctx) {\n                this._ctx = GameAudio.ctx;\n            }\n        },\n\n        _ensureCtx: function() {\n            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n            return this._ctx;\n        },\n\n        jump: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(300, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.1);\n        },\n\n        wallHit: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'triangle';\n            osc.frequency.setValueAtTime(150, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.08);\n        },\n\n        coin: function(streak) {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var baseFreq = 800 + Math.min(streak, 10) * 80;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.15);\n            // Harmonic\n            var osc2 = ctx.createOscillator();\n            var gain2 = ctx.createGain();\n            osc2.type = 'sine';\n            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n            osc2.connect(gain2);\n            gain2.connect(ctx.destination);\n            osc2.start(ctx.currentTime + 0.05);\n            osc2.stop(ctx.currentTime + 0.2);\n        },\n\n        die: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sawtooth';\n            osc.frequency.setValueAtTime(400, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.4);\n            // Noise burst\n            var bufSize = ctx.sampleRate * 0.3;\n            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n            var data = buf.getChannelData(0);\n            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n            var noise = ctx.createBufferSource();\n            noise.buffer = buf;\n            var ng = ctx.createGain();\n            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            noise.connect(ng);\n            ng.connect(ctx.destination);\n            noise.start(ctx.currentTime);\n            noise.stop(ctx.currentTime + 0.3);\n        },\n\n        lavaWarn: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(100, ctx.currentTime);\n            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.3);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Particle Pool\n    // -------------------------------------------------------\n    function ParticlePool(size) {\n        this.pool = [];\n        for (var i = 0; i < size; i++) {\n            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n        }\n    }\n\n    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) {\n                p.alive = true;\n                p.x = x; p.y = y;\n                p.vx = vx; p.vy = vy;\n                p.life = life; p.maxLife = life;\n                p.r = r; p.g = g; p.b = b;\n                p.size = size || 2;\n                return p;\n            }\n        }\n        return null;\n    };\n\n    ParticlePool.prototype.update = function(dt) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            p.life -= dt;\n            if (p.life <= 0) { p.alive = false; continue; }\n            p.x += p.vx * dt;\n            p.y += p.vy * dt;\n            p.vy += 200 * dt; // light gravity on particles\n        }\n    };\n\n    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            var sz = p.size * scale * alpha;\n            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    ParticlePool.prototype.clear = function() {\n        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n    };\n\n    // -------------------------------------------------------\n    // Score Popup Pool\n    // -------------------------------------------------------\n    function PopupPool() {\n        this.popups = [];\n    }\n\n    PopupPool.prototype.spawn = function(x, y, text, color) {\n        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n    };\n\n    PopupPool.prototype.update = function(dt) {\n        for (var i = this.popups.length - 1; i >= 0; i--) {\n            var p = this.popups[i];\n            p.life -= dt;\n            p.y -= 60 * dt;\n            if (p.life <= 0) this.popups.splice(i, 1);\n        }\n    };\n\n    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.popups.length; i++) {\n            var p = this.popups[i];\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = p.color;\n            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText(p.text, sx, sy);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    // -------------------------------------------------------\n    // Main Game State\n    // -------------------------------------------------------\n    function State() {\n        this.reset();\n        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n        this.popups = new PopupPool();\n        this.highScore = 0;\n        this.totalCoins = 0;\n        try {\n            var hs = localStorage.getItem('lavarise_hs');\n            if (hs) this.highScore = parseInt(hs, 10) || 0;\n            var tc = localStorage.getItem('lavarise_coins');\n            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n        } catch(e) {}\n    }\n\n    State.prototype.reset = function() {\n        this.playTime = 0;\n        this.difficultyLevel = 0;\n        this.score = 0;\n        this.heightScore = 0;\n        this.coinScore = 0;\n        this.coinStreak = 0;\n        this.coinStreakTimer = 0;\n\n        // Player\n        this.px = VIRTUAL_W * 0.25;\n        this.py = 0;\n        this.pvx = 0;\n        this.pvy = 0;\n        this.pOnWall = 'left'; // 'left', 'right', 'air'\n        this.pFacing = 1; // 1=right, -1=left\n        this.pAlive = true;\n        this.pInvincible = 0;\n        this.pSquash = 1.0; // squash-stretch factor\n\n        // Camera\n        this.camY = 0;\n        this.camTargetY = 0;\n\n        // Lava\n        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n        this.lavaSpeed = LAVA_SPEED_MIN;\n        this.lavaWarnTimer = 0;\n\n        // Walls\n        this.wallGap = WALL_GAP_MAX;\n        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n\n        // Obstacles and coins\n        this.obstacles = [];\n        this.coins = [];\n        this.lastSpawnY = 0;\n        this.spawnInterval = 120;\n\n        // Effects\n        this.slowMoTimer = 0;\n        this.shakeAmount = 0;\n        this.shakeTimer = 0;\n        this.gameOverTimer = 0;\n        this.flashAlpha = 0;\n\n        if (this.particles) this.particles.clear();\n        if (this.popups) this.popups = new PopupPool();\n    };\n\n    // -------------------------------------------------------\n    // Game Logic\n    // -------------------------------------------------------\n\n    State.prototype.initGame = function() {\n        this.reset();\n        // Player starts on left wall, slightly above where lava will begin\n        this.py = -50;\n        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n        this.pOnWall = 'left';\n        this.pFacing = 1;\n        this.pInvincible = SAFE_TIME;\n        this.camY = this.py - 200;\n        this.camTargetY = this.camY;\n        this.lavaY = 200; // starts below player\n\n        // Seed some coins in the safe zone\n        this._spawnCoin(-100);\n        this._spawnCoin(-220);\n        this._spawnCoin(-350);\n\n        SFX.init();\n    };\n\n    State.prototype._getWallGap = function() {\n        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n    };\n\n    State.prototype._getWallLeft = function() {\n        return (VIRTUAL_W - this._getWallGap()) / 2;\n    };\n\n    State.prototype._getWallRight = function() {\n        return (VIRTUAL_W + this._getWallGap()) / 2;\n    };\n\n    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });\n        } else {\n            // Crumbling ledge\n            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n            this.obstacles.push({\n                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n                side: side2, timer: 0, crumbling: false, fallen: false\n            });\n        }\n    };\n\n    State.prototype.update = function(dt, tapped) {\n        if (!this.pAlive) return;\n\n        // Slow-mo\n        var effectiveDt = dt;\n        if (this.slowMoTimer > 0) {\n            this.slowMoTimer -= dt;\n            effectiveDt = dt * SLOW_MO_FACTOR;\n        }\n\n        this.playTime += effectiveDt;\n        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n\n        // Invincibility\n        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n\n        // Coin streak timeout\n        if (this.coinStreakTimer > 0) {\n            this.coinStreakTimer -= effectiveDt;\n            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n        }\n\n        // Wall narrowing\n        this.wallGap = this._getWallGap();\n        this.wallLeft = this._getWallLeft();\n        this.wallRight = this._getWallRight();\n\n        // Lava rise\n        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n\n        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {\n            this.lavaWarnTimer -= effectiveDt;\n            if (this.lavaWarnTimer <= 0) {\n                SFX.lavaWarn();\n                this.lavaWarnTimer = 0.5;\n            }\n        }\n\n        // Jump input\n        if (tapped && this.pOnWall !== 'air') {\n            this._jump();\n        }\n\n        // Physics\n        if (this.pOnWall === 'air') {\n            this.pvy += GRAVITY * effectiveDt;\n            this.px += this.pvx * effectiveDt;\n            this.py += this.pvy * effectiveDt;\n\n            // Wall collision\n            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n\n            if (this.px <= leftEdge) {\n                this.px = leftEdge;\n                this.pOnWall = 'left';\n                this.pFacing = 1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('left');\n            } else if (this.px >= rightEdge) {\n                this.px = rightEdge;\n                this.pOnWall = 'right';\n                this.pFacing = -1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('right');\n            }\n\n            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n        } else {\n            // On wall - slide down slowly\n            this.pvy = 30; // gentle slide\n            this.py += this.pvy * effectiveDt;\n\n            // Keep within wall bounds\n            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n            if (this.pOnWall === 'left') this.px = le;\n            else this.px = re;\n        }\n\n        // Squash recovery\n        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n\n        // Obstacle updates\n        this._updateObstacles(effectiveDt);\n\n        // Coin collection\n        this._updateCoins(effectiveDt);\n\n        // Collision with obstacles\n        if (this.pInvincible <= 0) {\n            this._checkObstacleCollisions();\n        }\n\n        // Lava death\n        if (this.py > this.lavaY - PLAYER_H / 2) {\n            this._die('lava');\n            return;\n        }\n\n        // Spawn new content ahead\n        this._spawnContent();\n\n        // Height score (negative Y = higher)\n        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n        this.score = this.heightScore + this.coinScore;\n\n        // Camera\n        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n\n        // Cleanup off-screen objects\n        this._cleanup();\n\n        // Effects\n        this.shakeTimer -= effectiveDt;\n        if (this.shakeTimer < 0) this.shakeTimer = 0;\n        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n\n        this.flashAlpha -= effectiveDt * 3;\n        if (this.flashAlpha < 0) this.flashAlpha = 0;\n\n        // Particles\n        this.particles.update(effectiveDt);\n        this.popups.update(effectiveDt);\n\n        // Lava particles\n        this._spawnLavaParticles(effectiveDt);\n    };\n\n    State.prototype._jump = function() {\n        var dir = this.pOnWall === 'left' ? 1 : -1;\n        this.pvx = JUMP_VX_BASE * dir;\n        this.pvy = JUMP_VY;\n        this.pOnWall = 'air';\n        this.pFacing = dir;\n        this.pSquash = 1.4; // stretch on jump\n        SFX.jump();\n\n        // Jump particles\n        for (var i = 0; i < 5; i++) {\n            var angle = Math.random() * Math.PI - Math.PI / 2;\n            var speed = 50 + Math.random() * 80;\n            this.particles.spawn(\n                this.px, this.py,\n                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n                0.3 + Math.random() * 0.2,\n                0, 229, 255, 3\n            );\n        }\n    };\n\n    State.prototype._spawnWallParticles = function(side) {\n        for (var i = 0; i < 6; i++) {\n            var dir = side === 'left' ? 1 : -1;\n            this.particles.spawn(\n                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n                0.2 + Math.random() * 0.2,\n                100, 80, 160, 3\n            );\n        }\n    };\n\n    State.prototype._updateObstacles = function(dt) {\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'platform') {\n                obs.x += obs.speed * obs.dir * dt;\n                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n            }\n            if (obs.type === 'crumble' && obs.crumbling) {\n                obs.timer += dt;\n                if (obs.timer > 0.5) obs.fallen = true;\n            }\n        }\n    };\n\n    State.prototype._updateCoins = function(dt) {\n        var px = this.px, py = this.py;\n        for (var i = 0; i < this.coins.length; i++) {\n            var c = this.coins[i];\n            if (c.collected) continue;\n            c.bobPhase += dt * 3;\n\n            var dx = px - c.x;\n            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n            var dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n                c.collected = true;\n                this.coinStreak++;\n                this.coinStreakTimer = 2.0;\n                var points = 10 * Math.min(this.coinStreak, 10);\n                this.coinScore += points;\n                this.totalCoins++;\n                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n\n                // Slow-mo\n                this.slowMoTimer = SLOW_MO_DURATION;\n\n                // Effects\n                this.flashAlpha = 0.3;\n                SFX.coin(this.coinStreak);\n                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n\n                // Coin burst particles\n                for (var j = 0; j < 8; j++) {\n                    var angle = (j / 8) * Math.PI * 2;\n                    this.particles.spawn(\n                        c.x, c.y,\n                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n                        0.4, 255, 215, 0, 3\n                    );\n                }\n            }\n        }\n    };\n\n    State.prototype._checkObstacleCollisions = function() {\n        var px = this.px, py = this.py;\n        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'crumble' && obs.fallen) continue;\n\n            if (obs.type === 'spike') {\n                // AABB\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    this._die('spike');\n                    return;\n                }\n            }\n\n            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n                // Land on top\n                if (this.pvy > 0 && this.pOnWall === 'air') {\n                    if (pl < obs.x + obs.w && pr > obs.x &&\n                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n                        py - ph / 2 < obs.y) {\n                        // Landing on platform\n                        // For crumbling, start crumble timer\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n                // Side collision with platform acts like a small wall\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    // Push player out horizontally if mostly horizontal collision\n                    var overlapL = pr - obs.x;\n                    var overlapR = obs.x + obs.w - pl;\n                    var overlapT = pb - obs.y;\n                    var overlapB = obs.y + obs.h - pt;\n                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n                    if (minOverlap === overlapT && this.pvy > 0) {\n                        // Land on top\n                        this.py = obs.y - ph / 2;\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    State.prototype._die = function(cause) {\n        if (!this.pAlive) return;\n        this.pAlive = false;\n        SFX.die();\n        this.shakeAmount = 8;\n        this.shakeTimer = 0.4;\n        this.flashAlpha = 0.5;\n        this.gameOverTimer = 0;\n\n        // Death particles\n        for (var i = 0; i < 20; i++) {\n            var angle = (i / 20) * Math.PI * 2;\n            var speed = 80 + Math.random() * 120;\n            var r = cause === 'lava' ? 255 : 255;\n            var g = cause === 'lava' ? 68 : 51;\n            var b = cause === 'lava' ? 0 : 102;\n            this.particles.spawn(\n                this.px, this.py,\n                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n                0.5 + Math.random() * 0.3,\n                r, g, b, 4\n            );\n        }\n\n        // Save high score\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n        }\n    };\n\n    State.prototype._spawnContent = function() {\n        // Spawn ahead of camera (negative Y is up)\n        var spawnAhead = this.camY - 500;\n        while (this.lastSpawnY > spawnAhead) {\n            this.lastSpawnY -= this.spawnInterval;\n\n            // Don't spawn obstacles during safe time\n            if (this.playTime > SAFE_TIME) {\n                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n                if (Math.random() < obstacleChance) {\n                    this._spawnObstacle(this.lastSpawnY);\n                }\n            }\n\n            // Always spawn coins (good density)\n            if (Math.random() < 0.5) {\n                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n            }\n\n            // Decrease spawn interval with difficulty\n            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n        }\n    };\n\n    var _lavaParticleTimer = 0;\n    State.prototype._spawnLavaParticles = function(dt) {\n        _lavaParticleTimer += dt;\n        if (_lavaParticleTimer < 0.05) return;\n        _lavaParticleTimer = 0;\n\n        // Spawn bubbles along lava surface\n        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n        this.particles.spawn(\n            x, this.lavaY,\n            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n            0.5 + Math.random() * 0.5,\n            255, Math.floor(40 + Math.random() * 60), 0, 4\n        );\n    };\n\n    State.prototype._cleanup = function() {\n        var below = this.lavaY + 100;\n        // Remove coins below lava\n        for (var i = this.coins.length - 1; i >= 0; i--) {\n            if (this.coins[i].y > below || this.coins[i].collected) {\n                this.coins.splice(i, 1);\n            }\n        }\n        // Remove obstacles below lava\n        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n            if (this.obstacles[j].y > below) {\n                this.obstacles.splice(j, 1);\n            }\n        }\n    };\n\n    // -------------------------------------------------------\n    // Rendering\n    // -------------------------------------------------------\n\n    function Renderer() {}\n\n    Renderer.prototype.render = function(ctx, canvas, state) {\n        var cw = canvas.width;\n        var ch = canvas.height;\n\n        // Virtual coordinate mapping\n        var scale = cw / VIRTUAL_W;\n        var virtualH = ch / scale;\n        var offsetX = 0;\n\n        // Screen shake\n        var shakeX = 0, shakeY = 0;\n        if (state.shakeTimer > 0) {\n            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n        }\n\n        ctx.save();\n        ctx.translate(shakeX, shakeY);\n\n        // Background gradient\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, COL_BG_BOT);\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n\n        // Background stars (parallax)\n        this._renderStars(ctx, cw, ch, state.camY);\n\n        // Walls\n        this._renderWalls(ctx, state, scale, offsetX, ch);\n\n        // Obstacles\n        this._renderObstacles(ctx, state, scale, offsetX);\n\n        // Coins\n        this._renderCoins(ctx, state, scale, offsetX);\n\n        // Player\n        if (state.pAlive) {\n            this._renderPlayer(ctx, state, scale, offsetX);\n        }\n\n        // Particles\n        state.particles.render(ctx, state.camY, scale, offsetX);\n\n        // Lava\n        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n\n        // Popups\n        state.popups.render(ctx, state.camY, scale, offsetX);\n\n        ctx.restore();\n\n        // Flash overlay\n        if (state.flashAlpha > 0) {\n            ctx.globalAlpha = state.flashAlpha;\n            ctx.fillStyle = '#fff';\n            ctx.fillRect(0, 0, cw, ch);\n            ctx.globalAlpha = 1;\n        }\n\n        // HUD (not affected by shake)\n        this._renderHUD(ctx, cw, ch, state);\n    };\n\n    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n        // Simple deterministic stars\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        var seed = 42;\n        for (var i = 0; i < 40; i++) {\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sx = (seed % cw);\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sy = (seed % (ch * 3));\n            var parallax = 0.05;\n            var screenY = (sy - camY * parallax) % (ch * 3);\n            if (screenY < 0) screenY += ch * 3;\n            if (screenY < ch) {\n                var size = 1 + (i % 3);\n                ctx.fillRect(sx, screenY, size, size);\n            }\n        }\n    };\n\n    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n        var camY = state.camY;\n        var topY = 0;\n        var botY = ch;\n\n        // Left wall\n        var lwScreen = state.wallLeft * scale + offsetX;\n        var lwWidth = (WALL_THICKNESS) * scale;\n        ctx.fillStyle = COL_WALL_LEFT;\n        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n\n        // Right wall\n        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n        ctx.fillStyle = COL_WALL_RIGHT;\n        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n\n        // Wall bricks pattern\n        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n        var brickH = 20 * scale;\n        var startBrickY = Math.floor(camY / 20) * 20;\n        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n            var sy = (by - camY) * scale;\n            var offset = ((by / 20) % 2) * 10 * scale;\n            // Left wall bricks\n            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n                ctx.fillRect(bx + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n            // Right wall bricks\n            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n        }\n    };\n\n    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.obstacles.length; i++) {\n            var obs = state.obstacles[i];\n            var sx = obs.x * scale + offsetX;\n            var sy = (obs.y - camY) * scale;\n            var sw = obs.w * scale;\n            var sh = obs.h * scale;\n\n            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n\n            if (obs.type === 'spike') {\n                ctx.fillStyle = COL_SPIKE;\n                ctx.beginPath();\n                if (obs.side === 'left') {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                } else {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowColor = COL_SPIKE;\n                ctx.shadowBlur = 6 * scale;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            } else if (obs.type === 'platform') {\n                ctx.fillStyle = COL_PLATFORM;\n                ctx.fillRect(sx, sy, sw, sh);\n                // Top highlight\n                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n                ctx.fillRect(sx, sy, sw, 2 * scale);\n            } else if (obs.type === 'crumble') {\n                if (obs.fallen) continue;\n                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n                // Shake if crumbling\n                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n                ctx.globalAlpha = 1;\n            }\n        }\n    };\n\n    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.coins.length; i++) {\n            var c = state.coins[i];\n            if (c.collected) continue;\n            var sx = c.x * scale + offsetX;\n            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n            var sr = COIN_RADIUS * scale;\n\n            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n\n            // Glow\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN_GLOW;\n            ctx.fill();\n\n            // Coin body\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN;\n            ctx.fill();\n\n            // Shine\n            ctx.beginPath();\n            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.fill();\n        }\n    };\n\n    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n        var sx = state.px * scale + offsetX;\n        var sy = (state.py - state.camY) * scale;\n        var sw = PLAYER_W * scale;\n        var sh = PLAYER_H * scale;\n\n        // Invincibility blink\n        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n            ctx.globalAlpha = 0.5;\n        }\n\n        // Squash-stretch\n        var squashX = 1 / state.pSquash;\n        var squashY = state.pSquash;\n\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.scale(squashX, squashY);\n\n        // Body\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 8 * scale;\n        var bodyW = sw;\n        var bodyH = sh;\n        // Rounded rectangle body\n        var r = 4 * scale;\n        ctx.beginPath();\n        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Eyes\n        var eyeOffX = state.pFacing * 3 * scale;\n        var eyeY = -3 * scale;\n        ctx.fillStyle = COL_PLAYER_EYE;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils (look in movement direction)\n        ctx.fillStyle = '#222';\n        var pupilOff = state.pFacing * 1 * scale;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n        ctx.globalAlpha = 1;\n    };\n\n    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n        var lavaScreenY = (state.lavaY - state.camY) * scale;\n        if (lavaScreenY > ch + 50) return;\n\n        var topY = Math.max(0, lavaScreenY - 10 * scale);\n\n        // Lava glow above surface\n        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n\n        // Lava surface wave\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        ctx.lineTo(0, lavaScreenY);\n        var waveTime = state.playTime * 2;\n        for (var x = 0; x <= cw; x += 4) {\n            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n            ctx.lineTo(x, waveY);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n\n        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Surface highlight\n        ctx.strokeStyle = '#ff8800';\n        ctx.lineWidth = 2 * scale;\n        ctx.beginPath();\n        for (var x2 = 0; x2 <= cw; x2 += 4) {\n            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n            if (x2 === 0) ctx.moveTo(x2, waveY2);\n            else ctx.lineTo(x2, waveY2);\n        }\n        ctx.stroke();\n    };\n\n    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n        var pad = Math.max(12, cw * 0.03);\n        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n\n        // Score\n        ctx.fillStyle = COL_SCORE;\n        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n\n        // Height indicator\n        ctx.fillStyle = COL_HEIGHT;\n        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n\n        // Coin streak\n        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n            ctx.globalAlpha = 1;\n        }\n\n        // High score (small, top right)\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n        }\n\n        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Menu / Game Over rendering\n    // -------------------------------------------------------\n\n    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n        // Background\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, '#1a0505');\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(0, 0, cw, ch);\n\n        // Decorative lava at bottom\n        var lavaH = ch * 0.25;\n        var lavaTop = ch - lavaH;\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        for (var x = 0; x <= cw; x += 4) {\n            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n            ctx.lineTo(x, wy);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Glow\n        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n\n        // Title\n        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n        var centerY = ch * 0.32;\n        ctx.fillStyle = COL_LAVA_TOP;\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.shadowColor = '#ff4400';\n        ctx.shadowBlur = 20;\n        ctx.fillText('LAVA RISE', cw / 2, centerY);\n        ctx.shadowBlur = 0;\n\n        // Subtitle\n        ctx.fillStyle = COL_PLAYER;\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n\n        // Tap prompt (pulsing)\n        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n        ctx.globalAlpha = pulseAlpha;\n        ctx.fillStyle = '#ffffff';\n        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n        ctx.globalAlpha = 1;\n\n        // High score\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n        }\n\n        // Small player character preview (bouncing)\n        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n        var ps = Math.max(1, cw / VIRTUAL_W);\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 10;\n        var pw = PLAYER_W * ps;\n        var ph = PLAYER_H * ps;\n        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n        ctx.shadowBlur = 0;\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n    };\n\n    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n        // Darken\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, cw, ch);\n\n        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n        var centerY = ch * 0.3;\n\n        // Game over text\n        ctx.fillStyle = '#ff3333';\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', cw / 2, centerY);\n\n        // Score\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n\n        // Height and coins\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n\n        // New high score?\n        if (state.score >= state.highScore && state.score > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n        }\n\n        // Restart prompt\n        if (canRestart) {\n            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n            ctx.globalAlpha = pulseAlpha;\n            ctx.fillStyle = '#ffffff';\n            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n            ctx.globalAlpha = 1;\n        }\n    };\n\n    // -------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------\n    return {\n        State: State,\n        Renderer: Renderer,\n        SFX: SFX,\n        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n    };\n\n})();\n","numLines":1296,"startLine":1,"totalLines":1296}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01DyLdsLZVWKVgGZKcrVKgcd","type":"message","role":"assistant","content":[{"type":"text","text":"I see a few issues to fix in my review:\n\n1. **Lava direction logic**: The player climbs upward (negative Y), and lava rises upward too. The lava death check `this.py > this.lavaY` should actually be checking if the player's Y is greater (lower on screen) than lava Y. Since lava starts at Y=200 and decreases, and player starts at Y=-50 and decreases... Actually wait - the player goes UP (more negative Y) while lava also goes more negative. The check `this.py > this.lavaY - PLAYER_H/2` means \"if player is below lava\" which is correct since positive Y is down.\n\n2. **Wall gap at start is 400 = VIRTUAL_W = full width, meaning wallLeft=0, wallRight=400**. That means the walls start at the edges with 40px thickness, leaving 320 usable space. This is fine.\n\n3. **The `_lavaParticleTimer` is a closure variable** - this will be shared across instances but there's only one game, so it's fine. However it won't reset on restart. Let me fix that.\n\n4. **The wall narrowing pushes the player when on the wall** - `px` gets repositioned each frame, which is correct.\n\nLet me fix the lava particle timer issue and a few other small things I noticed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20657,"cache_read_input_tokens":56186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20657},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"68eedc5e-220e-4df2-bb49-348fdccddd89"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01DyLdsLZVWKVgGZKcrVKgcd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QFstK73gDWp1w15GYX9feP","name":"Edit","input":{"replace_all":false,"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","old_string":"    var _lavaParticleTimer = 0;\n    State.prototype._spawnLavaParticles = function(dt) {\n        _lavaParticleTimer += dt;\n        if (_lavaParticleTimer < 0.05) return;\n        _lavaParticleTimer = 0;","new_string":"    State.prototype._spawnLavaParticles = function(dt) {\n        if (!this._lavaParticleTimer) this._lavaParticleTimer = 0;\n        this._lavaParticleTimer += dt;\n        if (this._lavaParticleTimer < 0.05) return;\n        this._lavaParticleTimer = 0;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20657,"cache_read_input_tokens":56186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":20657},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"e2af789f-2fcb-41f6-91ef-f6630435bda9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QFstK73gDWp1w15GYX9feP","type":"tool_result","content":"The file F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"2ae13f23-7d9b-4b63-a97a-f506652652a6","tool_use_result":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","oldString":"    var _lavaParticleTimer = 0;\n    State.prototype._spawnLavaParticles = function(dt) {\n        _lavaParticleTimer += dt;\n        if (_lavaParticleTimer < 0.05) return;\n        _lavaParticleTimer = 0;","newString":"    State.prototype._spawnLavaParticles = function(dt) {\n        if (!this._lavaParticleTimer) this._lavaParticleTimer = 0;\n        this._lavaParticleTimer += dt;\n        if (this._lavaParticleTimer < 0.05) return;\n        this._lavaParticleTimer = 0;","originalFile":"/**\n * Lava Rise - Complete game logic\n * Wall-jump between narrowing walls to outrun rising lava\n */\n\nvar LavaRise = (function() {\n    'use strict';\n\n    // -------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------\n    var VIRTUAL_W = 400;\n    var PLAYER_W = 18;\n    var PLAYER_H = 24;\n    var GRAVITY = 1400;\n    var JUMP_VY = -520;\n    var JUMP_VX_BASE = 400;\n    var WALL_THICKNESS = 40;\n    var COIN_RADIUS = 10;\n    var SPIKE_W = 20;\n    var SPIKE_H = 16;\n    var PLATFORM_W = 50;\n    var PLATFORM_H = 10;\n    var PARTICLE_POOL_SIZE = 200;\n    var SLOW_MO_DURATION = 0.3;\n    var SLOW_MO_FACTOR = 0.4;\n    var SAFE_TIME = 5.0;\n    var GAME_OVER_LOCKOUT = 0.8;\n    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    var LAVA_SPEED_MIN = 60;\n    var LAVA_SPEED_MAX = 150;\n    var WALL_GAP_MAX = 400;\n    var WALL_GAP_MIN = 220;\n    var CAMERA_LEAD = 0.3;\n    var CAMERA_SMOOTH = 4.0;\n\n    // Colors\n    var COL_BG_TOP = '#1a0a2e';\n    var COL_BG_BOT = '#0d0015';\n    var COL_WALL_LEFT = '#3a2a5c';\n    var COL_WALL_RIGHT = '#3a2a5c';\n    var COL_WALL_EDGE = '#6a4a9a';\n    var COL_PLAYER = '#00e5ff';\n    var COL_PLAYER_EYE = '#ffffff';\n    var COL_COIN = '#ffd700';\n    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    var COL_SPIKE = '#ff3366';\n    var COL_LAVA_TOP = '#ff4400';\n    var COL_LAVA_MID = '#ff2200';\n    var COL_LAVA_BOT = '#cc1100';\n    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    var COL_PLATFORM = '#8866bb';\n    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    var COL_SCORE = '#ffffff';\n    var COL_HEIGHT = '#aaaaaa';\n\n    // -------------------------------------------------------\n    // Procedural Audio\n    // -------------------------------------------------------\n    var SFX = {\n        _ctx: null,\n\n        init: function() {\n            if (GameAudio.ctx) {\n                this._ctx = GameAudio.ctx;\n            }\n        },\n\n        _ensureCtx: function() {\n            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n            return this._ctx;\n        },\n\n        jump: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(300, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.1);\n        },\n\n        wallHit: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'triangle';\n            osc.frequency.setValueAtTime(150, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.08);\n        },\n\n        coin: function(streak) {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var baseFreq = 800 + Math.min(streak, 10) * 80;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.15);\n            // Harmonic\n            var osc2 = ctx.createOscillator();\n            var gain2 = ctx.createGain();\n            osc2.type = 'sine';\n            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n            osc2.connect(gain2);\n            gain2.connect(ctx.destination);\n            osc2.start(ctx.currentTime + 0.05);\n            osc2.stop(ctx.currentTime + 0.2);\n        },\n\n        die: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sawtooth';\n            osc.frequency.setValueAtTime(400, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.4);\n            // Noise burst\n            var bufSize = ctx.sampleRate * 0.3;\n            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n            var data = buf.getChannelData(0);\n            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n            var noise = ctx.createBufferSource();\n            noise.buffer = buf;\n            var ng = ctx.createGain();\n            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            noise.connect(ng);\n            ng.connect(ctx.destination);\n            noise.start(ctx.currentTime);\n            noise.stop(ctx.currentTime + 0.3);\n        },\n\n        lavaWarn: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(100, ctx.currentTime);\n            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.3);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Particle Pool\n    // -------------------------------------------------------\n    function ParticlePool(size) {\n        this.pool = [];\n        for (var i = 0; i < size; i++) {\n            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n        }\n    }\n\n    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) {\n                p.alive = true;\n                p.x = x; p.y = y;\n                p.vx = vx; p.vy = vy;\n                p.life = life; p.maxLife = life;\n                p.r = r; p.g = g; p.b = b;\n                p.size = size || 2;\n                return p;\n            }\n        }\n        return null;\n    };\n\n    ParticlePool.prototype.update = function(dt) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            p.life -= dt;\n            if (p.life <= 0) { p.alive = false; continue; }\n            p.x += p.vx * dt;\n            p.y += p.vy * dt;\n            p.vy += 200 * dt; // light gravity on particles\n        }\n    };\n\n    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            var sz = p.size * scale * alpha;\n            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    ParticlePool.prototype.clear = function() {\n        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n    };\n\n    // -------------------------------------------------------\n    // Score Popup Pool\n    // -------------------------------------------------------\n    function PopupPool() {\n        this.popups = [];\n    }\n\n    PopupPool.prototype.spawn = function(x, y, text, color) {\n        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n    };\n\n    PopupPool.prototype.update = function(dt) {\n        for (var i = this.popups.length - 1; i >= 0; i--) {\n            var p = this.popups[i];\n            p.life -= dt;\n            p.y -= 60 * dt;\n            if (p.life <= 0) this.popups.splice(i, 1);\n        }\n    };\n\n    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.popups.length; i++) {\n            var p = this.popups[i];\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = p.color;\n            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText(p.text, sx, sy);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    // -------------------------------------------------------\n    // Main Game State\n    // -------------------------------------------------------\n    function State() {\n        this.reset();\n        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n        this.popups = new PopupPool();\n        this.highScore = 0;\n        this.totalCoins = 0;\n        try {\n            var hs = localStorage.getItem('lavarise_hs');\n            if (hs) this.highScore = parseInt(hs, 10) || 0;\n            var tc = localStorage.getItem('lavarise_coins');\n            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n        } catch(e) {}\n    }\n\n    State.prototype.reset = function() {\n        this.playTime = 0;\n        this.difficultyLevel = 0;\n        this.score = 0;\n        this.heightScore = 0;\n        this.coinScore = 0;\n        this.coinStreak = 0;\n        this.coinStreakTimer = 0;\n\n        // Player\n        this.px = VIRTUAL_W * 0.25;\n        this.py = 0;\n        this.pvx = 0;\n        this.pvy = 0;\n        this.pOnWall = 'left'; // 'left', 'right', 'air'\n        this.pFacing = 1; // 1=right, -1=left\n        this.pAlive = true;\n        this.pInvincible = 0;\n        this.pSquash = 1.0; // squash-stretch factor\n\n        // Camera\n        this.camY = 0;\n        this.camTargetY = 0;\n\n        // Lava\n        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n        this.lavaSpeed = LAVA_SPEED_MIN;\n        this.lavaWarnTimer = 0;\n\n        // Walls\n        this.wallGap = WALL_GAP_MAX;\n        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n\n        // Obstacles and coins\n        this.obstacles = [];\n        this.coins = [];\n        this.lastSpawnY = 0;\n        this.spawnInterval = 120;\n\n        // Effects\n        this.slowMoTimer = 0;\n        this.shakeAmount = 0;\n        this.shakeTimer = 0;\n        this.gameOverTimer = 0;\n        this.flashAlpha = 0;\n\n        if (this.particles) this.particles.clear();\n        if (this.popups) this.popups = new PopupPool();\n    };\n\n    // -------------------------------------------------------\n    // Game Logic\n    // -------------------------------------------------------\n\n    State.prototype.initGame = function() {\n        this.reset();\n        // Player starts on left wall, slightly above where lava will begin\n        this.py = -50;\n        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n        this.pOnWall = 'left';\n        this.pFacing = 1;\n        this.pInvincible = SAFE_TIME;\n        this.camY = this.py - 200;\n        this.camTargetY = this.camY;\n        this.lavaY = 200; // starts below player\n\n        // Seed some coins in the safe zone\n        this._spawnCoin(-100);\n        this._spawnCoin(-220);\n        this._spawnCoin(-350);\n\n        SFX.init();\n    };\n\n    State.prototype._getWallGap = function() {\n        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n    };\n\n    State.prototype._getWallLeft = function() {\n        return (VIRTUAL_W - this._getWallGap()) / 2;\n    };\n\n    State.prototype._getWallRight = function() {\n        return (VIRTUAL_W + this._getWallGap()) / 2;\n    };\n\n    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });\n        } else {\n            // Crumbling ledge\n            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n            this.obstacles.push({\n                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n                side: side2, timer: 0, crumbling: false, fallen: false\n            });\n        }\n    };\n\n    State.prototype.update = function(dt, tapped) {\n        if (!this.pAlive) return;\n\n        // Slow-mo\n        var effectiveDt = dt;\n        if (this.slowMoTimer > 0) {\n            this.slowMoTimer -= dt;\n            effectiveDt = dt * SLOW_MO_FACTOR;\n        }\n\n        this.playTime += effectiveDt;\n        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n\n        // Invincibility\n        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n\n        // Coin streak timeout\n        if (this.coinStreakTimer > 0) {\n            this.coinStreakTimer -= effectiveDt;\n            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n        }\n\n        // Wall narrowing\n        this.wallGap = this._getWallGap();\n        this.wallLeft = this._getWallLeft();\n        this.wallRight = this._getWallRight();\n\n        // Lava rise\n        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n\n        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {\n            this.lavaWarnTimer -= effectiveDt;\n            if (this.lavaWarnTimer <= 0) {\n                SFX.lavaWarn();\n                this.lavaWarnTimer = 0.5;\n            }\n        }\n\n        // Jump input\n        if (tapped && this.pOnWall !== 'air') {\n            this._jump();\n        }\n\n        // Physics\n        if (this.pOnWall === 'air') {\n            this.pvy += GRAVITY * effectiveDt;\n            this.px += this.pvx * effectiveDt;\n            this.py += this.pvy * effectiveDt;\n\n            // Wall collision\n            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n\n            if (this.px <= leftEdge) {\n                this.px = leftEdge;\n                this.pOnWall = 'left';\n                this.pFacing = 1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('left');\n            } else if (this.px >= rightEdge) {\n                this.px = rightEdge;\n                this.pOnWall = 'right';\n                this.pFacing = -1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('right');\n            }\n\n            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n        } else {\n            // On wall - slide down slowly\n            this.pvy = 30; // gentle slide\n            this.py += this.pvy * effectiveDt;\n\n            // Keep within wall bounds\n            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n            if (this.pOnWall === 'left') this.px = le;\n            else this.px = re;\n        }\n\n        // Squash recovery\n        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n\n        // Obstacle updates\n        this._updateObstacles(effectiveDt);\n\n        // Coin collection\n        this._updateCoins(effectiveDt);\n\n        // Collision with obstacles\n        if (this.pInvincible <= 0) {\n            this._checkObstacleCollisions();\n        }\n\n        // Lava death\n        if (this.py > this.lavaY - PLAYER_H / 2) {\n            this._die('lava');\n            return;\n        }\n\n        // Spawn new content ahead\n        this._spawnContent();\n\n        // Height score (negative Y = higher)\n        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n        this.score = this.heightScore + this.coinScore;\n\n        // Camera\n        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n\n        // Cleanup off-screen objects\n        this._cleanup();\n\n        // Effects\n        this.shakeTimer -= effectiveDt;\n        if (this.shakeTimer < 0) this.shakeTimer = 0;\n        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n\n        this.flashAlpha -= effectiveDt * 3;\n        if (this.flashAlpha < 0) this.flashAlpha = 0;\n\n        // Particles\n        this.particles.update(effectiveDt);\n        this.popups.update(effectiveDt);\n\n        // Lava particles\n        this._spawnLavaParticles(effectiveDt);\n    };\n\n    State.prototype._jump = function() {\n        var dir = this.pOnWall === 'left' ? 1 : -1;\n        this.pvx = JUMP_VX_BASE * dir;\n        this.pvy = JUMP_VY;\n        this.pOnWall = 'air';\n        this.pFacing = dir;\n        this.pSquash = 1.4; // stretch on jump\n        SFX.jump();\n\n        // Jump particles\n        for (var i = 0; i < 5; i++) {\n            var angle = Math.random() * Math.PI - Math.PI / 2;\n            var speed = 50 + Math.random() * 80;\n            this.particles.spawn(\n                this.px, this.py,\n                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n                0.3 + Math.random() * 0.2,\n                0, 229, 255, 3\n            );\n        }\n    };\n\n    State.prototype._spawnWallParticles = function(side) {\n        for (var i = 0; i < 6; i++) {\n            var dir = side === 'left' ? 1 : -1;\n            this.particles.spawn(\n                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n                0.2 + Math.random() * 0.2,\n                100, 80, 160, 3\n            );\n        }\n    };\n\n    State.prototype._updateObstacles = function(dt) {\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'platform') {\n                obs.x += obs.speed * obs.dir * dt;\n                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n            }\n            if (obs.type === 'crumble' && obs.crumbling) {\n                obs.timer += dt;\n                if (obs.timer > 0.5) obs.fallen = true;\n            }\n        }\n    };\n\n    State.prototype._updateCoins = function(dt) {\n        var px = this.px, py = this.py;\n        for (var i = 0; i < this.coins.length; i++) {\n            var c = this.coins[i];\n            if (c.collected) continue;\n            c.bobPhase += dt * 3;\n\n            var dx = px - c.x;\n            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n            var dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n                c.collected = true;\n                this.coinStreak++;\n                this.coinStreakTimer = 2.0;\n                var points = 10 * Math.min(this.coinStreak, 10);\n                this.coinScore += points;\n                this.totalCoins++;\n                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n\n                // Slow-mo\n                this.slowMoTimer = SLOW_MO_DURATION;\n\n                // Effects\n                this.flashAlpha = 0.3;\n                SFX.coin(this.coinStreak);\n                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n\n                // Coin burst particles\n                for (var j = 0; j < 8; j++) {\n                    var angle = (j / 8) * Math.PI * 2;\n                    this.particles.spawn(\n                        c.x, c.y,\n                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n                        0.4, 255, 215, 0, 3\n                    );\n                }\n            }\n        }\n    };\n\n    State.prototype._checkObstacleCollisions = function() {\n        var px = this.px, py = this.py;\n        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'crumble' && obs.fallen) continue;\n\n            if (obs.type === 'spike') {\n                // AABB\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    this._die('spike');\n                    return;\n                }\n            }\n\n            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n                // Land on top\n                if (this.pvy > 0 && this.pOnWall === 'air') {\n                    if (pl < obs.x + obs.w && pr > obs.x &&\n                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n                        py - ph / 2 < obs.y) {\n                        // Landing on platform\n                        // For crumbling, start crumble timer\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n                // Side collision with platform acts like a small wall\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    // Push player out horizontally if mostly horizontal collision\n                    var overlapL = pr - obs.x;\n                    var overlapR = obs.x + obs.w - pl;\n                    var overlapT = pb - obs.y;\n                    var overlapB = obs.y + obs.h - pt;\n                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n                    if (minOverlap === overlapT && this.pvy > 0) {\n                        // Land on top\n                        this.py = obs.y - ph / 2;\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    State.prototype._die = function(cause) {\n        if (!this.pAlive) return;\n        this.pAlive = false;\n        SFX.die();\n        this.shakeAmount = 8;\n        this.shakeTimer = 0.4;\n        this.flashAlpha = 0.5;\n        this.gameOverTimer = 0;\n\n        // Death particles\n        for (var i = 0; i < 20; i++) {\n            var angle = (i / 20) * Math.PI * 2;\n            var speed = 80 + Math.random() * 120;\n            var r = cause === 'lava' ? 255 : 255;\n            var g = cause === 'lava' ? 68 : 51;\n            var b = cause === 'lava' ? 0 : 102;\n            this.particles.spawn(\n                this.px, this.py,\n                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n                0.5 + Math.random() * 0.3,\n                r, g, b, 4\n            );\n        }\n\n        // Save high score\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n        }\n    };\n\n    State.prototype._spawnContent = function() {\n        // Spawn ahead of camera (negative Y is up)\n        var spawnAhead = this.camY - 500;\n        while (this.lastSpawnY > spawnAhead) {\n            this.lastSpawnY -= this.spawnInterval;\n\n            // Don't spawn obstacles during safe time\n            if (this.playTime > SAFE_TIME) {\n                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n                if (Math.random() < obstacleChance) {\n                    this._spawnObstacle(this.lastSpawnY);\n                }\n            }\n\n            // Always spawn coins (good density)\n            if (Math.random() < 0.5) {\n                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n            }\n\n            // Decrease spawn interval with difficulty\n            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n        }\n    };\n\n    var _lavaParticleTimer = 0;\n    State.prototype._spawnLavaParticles = function(dt) {\n        _lavaParticleTimer += dt;\n        if (_lavaParticleTimer < 0.05) return;\n        _lavaParticleTimer = 0;\n\n        // Spawn bubbles along lava surface\n        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n        this.particles.spawn(\n            x, this.lavaY,\n            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n            0.5 + Math.random() * 0.5,\n            255, Math.floor(40 + Math.random() * 60), 0, 4\n        );\n    };\n\n    State.prototype._cleanup = function() {\n        var below = this.lavaY + 100;\n        // Remove coins below lava\n        for (var i = this.coins.length - 1; i >= 0; i--) {\n            if (this.coins[i].y > below || this.coins[i].collected) {\n                this.coins.splice(i, 1);\n            }\n        }\n        // Remove obstacles below lava\n        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n            if (this.obstacles[j].y > below) {\n                this.obstacles.splice(j, 1);\n            }\n        }\n    };\n\n    // -------------------------------------------------------\n    // Rendering\n    // -------------------------------------------------------\n\n    function Renderer() {}\n\n    Renderer.prototype.render = function(ctx, canvas, state) {\n        var cw = canvas.width;\n        var ch = canvas.height;\n\n        // Virtual coordinate mapping\n        var scale = cw / VIRTUAL_W;\n        var virtualH = ch / scale;\n        var offsetX = 0;\n\n        // Screen shake\n        var shakeX = 0, shakeY = 0;\n        if (state.shakeTimer > 0) {\n            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n        }\n\n        ctx.save();\n        ctx.translate(shakeX, shakeY);\n\n        // Background gradient\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, COL_BG_BOT);\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n\n        // Background stars (parallax)\n        this._renderStars(ctx, cw, ch, state.camY);\n\n        // Walls\n        this._renderWalls(ctx, state, scale, offsetX, ch);\n\n        // Obstacles\n        this._renderObstacles(ctx, state, scale, offsetX);\n\n        // Coins\n        this._renderCoins(ctx, state, scale, offsetX);\n\n        // Player\n        if (state.pAlive) {\n            this._renderPlayer(ctx, state, scale, offsetX);\n        }\n\n        // Particles\n        state.particles.render(ctx, state.camY, scale, offsetX);\n\n        // Lava\n        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n\n        // Popups\n        state.popups.render(ctx, state.camY, scale, offsetX);\n\n        ctx.restore();\n\n        // Flash overlay\n        if (state.flashAlpha > 0) {\n            ctx.globalAlpha = state.flashAlpha;\n            ctx.fillStyle = '#fff';\n            ctx.fillRect(0, 0, cw, ch);\n            ctx.globalAlpha = 1;\n        }\n\n        // HUD (not affected by shake)\n        this._renderHUD(ctx, cw, ch, state);\n    };\n\n    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n        // Simple deterministic stars\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        var seed = 42;\n        for (var i = 0; i < 40; i++) {\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sx = (seed % cw);\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sy = (seed % (ch * 3));\n            var parallax = 0.05;\n            var screenY = (sy - camY * parallax) % (ch * 3);\n            if (screenY < 0) screenY += ch * 3;\n            if (screenY < ch) {\n                var size = 1 + (i % 3);\n                ctx.fillRect(sx, screenY, size, size);\n            }\n        }\n    };\n\n    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n        var camY = state.camY;\n        var topY = 0;\n        var botY = ch;\n\n        // Left wall\n        var lwScreen = state.wallLeft * scale + offsetX;\n        var lwWidth = (WALL_THICKNESS) * scale;\n        ctx.fillStyle = COL_WALL_LEFT;\n        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n\n        // Right wall\n        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n        ctx.fillStyle = COL_WALL_RIGHT;\n        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n\n        // Wall bricks pattern\n        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n        var brickH = 20 * scale;\n        var startBrickY = Math.floor(camY / 20) * 20;\n        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n            var sy = (by - camY) * scale;\n            var offset = ((by / 20) % 2) * 10 * scale;\n            // Left wall bricks\n            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n                ctx.fillRect(bx + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n            // Right wall bricks\n            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n        }\n    };\n\n    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.obstacles.length; i++) {\n            var obs = state.obstacles[i];\n            var sx = obs.x * scale + offsetX;\n            var sy = (obs.y - camY) * scale;\n            var sw = obs.w * scale;\n            var sh = obs.h * scale;\n\n            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n\n            if (obs.type === 'spike') {\n                ctx.fillStyle = COL_SPIKE;\n                ctx.beginPath();\n                if (obs.side === 'left') {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                } else {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowColor = COL_SPIKE;\n                ctx.shadowBlur = 6 * scale;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            } else if (obs.type === 'platform') {\n                ctx.fillStyle = COL_PLATFORM;\n                ctx.fillRect(sx, sy, sw, sh);\n                // Top highlight\n                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n                ctx.fillRect(sx, sy, sw, 2 * scale);\n            } else if (obs.type === 'crumble') {\n                if (obs.fallen) continue;\n                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n                // Shake if crumbling\n                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n                ctx.globalAlpha = 1;\n            }\n        }\n    };\n\n    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.coins.length; i++) {\n            var c = state.coins[i];\n            if (c.collected) continue;\n            var sx = c.x * scale + offsetX;\n            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n            var sr = COIN_RADIUS * scale;\n\n            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n\n            // Glow\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN_GLOW;\n            ctx.fill();\n\n            // Coin body\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN;\n            ctx.fill();\n\n            // Shine\n            ctx.beginPath();\n            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.fill();\n        }\n    };\n\n    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n        var sx = state.px * scale + offsetX;\n        var sy = (state.py - state.camY) * scale;\n        var sw = PLAYER_W * scale;\n        var sh = PLAYER_H * scale;\n\n        // Invincibility blink\n        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n            ctx.globalAlpha = 0.5;\n        }\n\n        // Squash-stretch\n        var squashX = 1 / state.pSquash;\n        var squashY = state.pSquash;\n\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.scale(squashX, squashY);\n\n        // Body\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 8 * scale;\n        var bodyW = sw;\n        var bodyH = sh;\n        // Rounded rectangle body\n        var r = 4 * scale;\n        ctx.beginPath();\n        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Eyes\n        var eyeOffX = state.pFacing * 3 * scale;\n        var eyeY = -3 * scale;\n        ctx.fillStyle = COL_PLAYER_EYE;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils (look in movement direction)\n        ctx.fillStyle = '#222';\n        var pupilOff = state.pFacing * 1 * scale;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n        ctx.globalAlpha = 1;\n    };\n\n    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n        var lavaScreenY = (state.lavaY - state.camY) * scale;\n        if (lavaScreenY > ch + 50) return;\n\n        var topY = Math.max(0, lavaScreenY - 10 * scale);\n\n        // Lava glow above surface\n        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n\n        // Lava surface wave\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        ctx.lineTo(0, lavaScreenY);\n        var waveTime = state.playTime * 2;\n        for (var x = 0; x <= cw; x += 4) {\n            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n            ctx.lineTo(x, waveY);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n\n        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Surface highlight\n        ctx.strokeStyle = '#ff8800';\n        ctx.lineWidth = 2 * scale;\n        ctx.beginPath();\n        for (var x2 = 0; x2 <= cw; x2 += 4) {\n            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n            if (x2 === 0) ctx.moveTo(x2, waveY2);\n            else ctx.lineTo(x2, waveY2);\n        }\n        ctx.stroke();\n    };\n\n    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n        var pad = Math.max(12, cw * 0.03);\n        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n\n        // Score\n        ctx.fillStyle = COL_SCORE;\n        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n\n        // Height indicator\n        ctx.fillStyle = COL_HEIGHT;\n        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n\n        // Coin streak\n        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n            ctx.globalAlpha = 1;\n        }\n\n        // High score (small, top right)\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n        }\n\n        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Menu / Game Over rendering\n    // -------------------------------------------------------\n\n    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n        // Background\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, '#1a0505');\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(0, 0, cw, ch);\n\n        // Decorative lava at bottom\n        var lavaH = ch * 0.25;\n        var lavaTop = ch - lavaH;\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        for (var x = 0; x <= cw; x += 4) {\n            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n            ctx.lineTo(x, wy);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Glow\n        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n\n        // Title\n        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n        var centerY = ch * 0.32;\n        ctx.fillStyle = COL_LAVA_TOP;\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.shadowColor = '#ff4400';\n        ctx.shadowBlur = 20;\n        ctx.fillText('LAVA RISE', cw / 2, centerY);\n        ctx.shadowBlur = 0;\n\n        // Subtitle\n        ctx.fillStyle = COL_PLAYER;\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n\n        // Tap prompt (pulsing)\n        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n        ctx.globalAlpha = pulseAlpha;\n        ctx.fillStyle = '#ffffff';\n        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n        ctx.globalAlpha = 1;\n\n        // High score\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n        }\n\n        // Small player character preview (bouncing)\n        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n        var ps = Math.max(1, cw / VIRTUAL_W);\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 10;\n        var pw = PLAYER_W * ps;\n        var ph = PLAYER_H * ps;\n        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n        ctx.shadowBlur = 0;\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n    };\n\n    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n        // Darken\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, cw, ch);\n\n        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n        var centerY = ch * 0.3;\n\n        // Game over text\n        ctx.fillStyle = '#ff3333';\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', cw / 2, centerY);\n\n        // Score\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n\n        // Height and coins\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n\n        // New high score?\n        if (state.score >= state.highScore && state.score > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n        }\n\n        // Restart prompt\n        if (canRestart) {\n            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n            ctx.globalAlpha = pulseAlpha;\n            ctx.fillStyle = '#ffffff';\n            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n            ctx.globalAlpha = 1;\n        }\n    };\n\n    // -------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------\n    return {\n        State: State,\n        Renderer: Renderer,\n        SFX: SFX,\n        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n    };\n\n})();\n","structuredPatch":[{"oldStart":753,"oldLines":11,"newStart":753,"newLines":11,"lines":["         }","     };"," ","-    var _lavaParticleTimer = 0;","     State.prototype._spawnLavaParticles = function(dt) {","-        _lavaParticleTimer += dt;","-        if (_lavaParticleTimer < 0.05) return;","-        _lavaParticleTimer = 0;","+        if (!this._lavaParticleTimer) this._lavaParticleTimer = 0;","+        this._lavaParticleTimer += dt;","+        if (this._lavaParticleTimer < 0.05) return;","+        this._lavaParticleTimer = 0;"," ","         // Spawn bubbles along lava surface","         var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01AsEXfKgogrjExc8bDGy43F","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also verify the `game.js` file looks correct:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":668,"cache_read_input_tokens":76843,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":668},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"0a89e113-221e-4a16-a82b-532cbc2f2b14"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01AsEXfKgogrjExc8bDGy43F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012efCEwedJsPHgeTZnsH8ax","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":668,"cache_read_input_tokens":76843,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":668},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"1e08e443-b630-4a9d-974f-dc00a236d666"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012efCEwedJsPHgeTZnsH8ax","type":"tool_result","content":"     1â†’/**\n     2â†’ * Game - Lava Rise integration\n     3â†’ * State machine, rAF loop, Poki lifecycle\n     4â†’ */\n     5â†’\n     6â†’import { InputManager } from './input.js';\n     7â†’\n     8â†’/** Config */\n     9â†’export const Config = {\n    10â†’    adsEnabled: false,\n    11â†’};\n    12â†’\n    13â†’export class Game {\n    14â†’    constructor(canvas) {\n    15â†’        this.canvas = canvas;\n    16â†’        this.ctx = canvas.getContext('2d');\n    17â†’        this.input = new InputManager(canvas);\n    18â†’        this.state = 'loading';\n    19â†’        this.score = 0;\n    20â†’        this.lastTime = 0;\n    21â†’        this.menuTime = 0;\n    22â†’        this.gameOverTime = 0;\n    23â†’\n    24â†’        // Lava Rise systems\n    25â†’        this.gs = new LavaRise.State();\n    26â†’        this.renderer = new LavaRise.Renderer();\n    27â†’\n    28â†’        this._boundLoop = this._loop.bind(this);\n    29â†’        this._resize = this._resize.bind(this);\n    30â†’        window.addEventListener('resize', this._resize);\n    31â†’    }\n    32â†’\n    33â†’    async init() {\n    34â†’        await Poki.init();\n    35â†’        this._resize();\n    36â†’        await this.loadAssets();\n    37â†’        Poki.gameLoadingFinished();\n    38â†’        this.state = 'menu';\n    39â†’        this.lastTime = performance.now();\n    40â†’        requestAnimationFrame(this._boundLoop);\n    41â†’    }\n    42â†’\n    43â†’    async loadAssets() {\n    44â†’        // No assets to load - all procedural\n    45â†’    }\n    46â†’\n    47â†’    _resize() {\n    48â†’        this.canvas.width = window.innerWidth;\n    49â†’        this.canvas.height = window.innerHeight;\n    50â†’    }\n    51â†’\n    52â†’    _loop(now) {\n    53â†’        var dt = (now - this.lastTime) / 1000;\n    54â†’        if (dt > 0.1) dt = 0.1;\n    55â†’        this.lastTime = now;\n    56â†’\n    57â†’        this.update(dt);\n    58â†’        this.render();\n    59â†’        this.input.endFrame();\n    60â†’\n    61â†’        requestAnimationFrame(this._boundLoop);\n    62â†’    }\n    63â†’\n    64â†’    // -------------------------------------------------------\n    65â†’    // State transitions\n    66â†’    // -------------------------------------------------------\n    67â†’\n    68â†’    start() {\n    69â†’        this.state = 'playing';\n    70â†’        this.gs.initGame();\n    71â†’        GameAudio.initContext();\n    72â†’        GameAudio.resume();\n    73â†’        LavaRise.SFX.init();\n    74â†’        Poki.gameplayStart();\n    75â†’    }\n    76â†’\n    77â†’    gameOver() {\n    78â†’        this.state = 'gameover';\n    79â†’        this.score = this.gs.score;\n    80â†’        this.gameOverTime = 0;\n    81â†’        Poki.gameplayStop();\n    82â†’    }\n    83â†’\n    84â†’    async restart() {\n    85â†’        if (Config.adsEnabled) {\n    86â†’            await Poki.commercialBreak(\n    87â†’                () => GameAudio.muteAll(),\n    88â†’                () => GameAudio.unmuteAll()\n    89â†’            );\n    90â†’        }\n    91â†’        this.state = 'playing';\n    92â†’        this.gs.initGame();\n    93â†’        Poki.gameplayStart();\n    94â†’    }\n    95â†’\n    96â†’    // -------------------------------------------------------\n    97â†’    // Update\n    98â†’    // -------------------------------------------------------\n    99â†’\n   100â†’    update(dt) {\n   101â†’        var tapped = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n   102â†’\n   103â†’        if (this.state === 'menu') {\n   104â†’            this.menuTime += dt;\n   105â†’            if (tapped) this.start();\n   106â†’        } else if (this.state === 'playing') {\n   107â†’            this.updatePlaying(dt, tapped);\n   108â†’        } else if (this.state === 'gameover') {\n   109â†’            this.gameOverTime += dt;\n   110â†’            // Update particles/effects even after death\n   111â†’            this.gs.particles.update(dt);\n   112â†’            this.gs.popups.update(dt);\n   113â†’            this.gs.shakeTimer -= dt;\n   114â†’            if (this.gs.shakeTimer < 0) this.gs.shakeTimer = 0;\n   115â†’            this.gs.shakeAmount *= Math.max(0, 1 - 8 * dt);\n   116â†’            this.gs.flashAlpha -= dt * 3;\n   117â†’            if (this.gs.flashAlpha < 0) this.gs.flashAlpha = 0;\n   118â†’\n   119â†’            if (tapped && this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT) {\n   120â†’                this.restart();\n   121â†’            }\n   122â†’        }\n   123â†’    }\n   124â†’\n   125â†’    updatePlaying(dt, tapped) {\n   126â†’        this.gs.update(dt, tapped);\n   127â†’        this.score = this.gs.score;\n   128â†’\n   129â†’        if (!this.gs.pAlive) {\n   130â†’            this.gameOver();\n   131â†’        }\n   132â†’    }\n   133â†’\n   134â†’    // -------------------------------------------------------\n   135â†’    // Render\n   136â†’    // -------------------------------------------------------\n   137â†’\n   138â†’    render() {\n   139â†’        var ctx = this.ctx;\n   140â†’        var cw = this.canvas.width;\n   141â†’        var ch = this.canvas.height;\n   142â†’\n   143â†’        if (this.state === 'loading') {\n   144â†’            this.renderLoading();\n   145â†’        } else if (this.state === 'menu') {\n   146â†’            this.renderer.renderMenu(ctx, cw, ch, this.gs, this.menuTime);\n   147â†’        } else if (this.state === 'playing') {\n   148â†’            this.renderer.render(ctx, this.canvas, this.gs);\n   149â†’        } else if (this.state === 'gameover') {\n   150â†’            // Render the game state frozen in background\n   151â†’            this.renderer.render(ctx, this.canvas, this.gs);\n   152â†’            // Overlay game over screen\n   153â†’            var canRestart = this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT;\n   154â†’            this.renderer.renderGameOver(ctx, cw, ch, this.gs, this.gameOverTime, canRestart);\n   155â†’        }\n   156â†’    }\n   157â†’\n   158â†’    renderLoading() {\n   159â†’        var ctx = this.ctx;\n   160â†’        ctx.fillStyle = '#1a0a2e';\n   161â†’        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n   162â†’        ctx.fillStyle = '#ff4400';\n   163â†’        ctx.font = 'bold 24px sans-serif';\n   164â†’        ctx.textAlign = 'center';\n   165â†’        ctx.fillText('LAVA RISE', this.canvas.width / 2, this.canvas.height / 2);\n   166â†’    }\n   167â†’}\n   168â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"e5ef02fb-83da-4f69-8862-4940aa1eca07","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\game.js","content":"/**\n * Game - Lava Rise integration\n * State machine, rAF loop, Poki lifecycle\n */\n\nimport { InputManager } from './input.js';\n\n/** Config */\nexport const Config = {\n    adsEnabled: false,\n};\n\nexport class Game {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.input = new InputManager(canvas);\n        this.state = 'loading';\n        this.score = 0;\n        this.lastTime = 0;\n        this.menuTime = 0;\n        this.gameOverTime = 0;\n\n        // Lava Rise systems\n        this.gs = new LavaRise.State();\n        this.renderer = new LavaRise.Renderer();\n\n        this._boundLoop = this._loop.bind(this);\n        this._resize = this._resize.bind(this);\n        window.addEventListener('resize', this._resize);\n    }\n\n    async init() {\n        await Poki.init();\n        this._resize();\n        await this.loadAssets();\n        Poki.gameLoadingFinished();\n        this.state = 'menu';\n        this.lastTime = performance.now();\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    async loadAssets() {\n        // No assets to load - all procedural\n    }\n\n    _resize() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n\n    _loop(now) {\n        var dt = (now - this.lastTime) / 1000;\n        if (dt > 0.1) dt = 0.1;\n        this.lastTime = now;\n\n        this.update(dt);\n        this.render();\n        this.input.endFrame();\n\n        requestAnimationFrame(this._boundLoop);\n    }\n\n    // -------------------------------------------------------\n    // State transitions\n    // -------------------------------------------------------\n\n    start() {\n        this.state = 'playing';\n        this.gs.initGame();\n        GameAudio.initContext();\n        GameAudio.resume();\n        LavaRise.SFX.init();\n        Poki.gameplayStart();\n    }\n\n    gameOver() {\n        this.state = 'gameover';\n        this.score = this.gs.score;\n        this.gameOverTime = 0;\n        Poki.gameplayStop();\n    }\n\n    async restart() {\n        if (Config.adsEnabled) {\n            await Poki.commercialBreak(\n                () => GameAudio.muteAll(),\n                () => GameAudio.unmuteAll()\n            );\n        }\n        this.state = 'playing';\n        this.gs.initGame();\n        Poki.gameplayStart();\n    }\n\n    // -------------------------------------------------------\n    // Update\n    // -------------------------------------------------------\n\n    update(dt) {\n        var tapped = this.input.wasPressed('Enter') || this.input.wasPressed('Space') || this.input.wasTapped();\n\n        if (this.state === 'menu') {\n            this.menuTime += dt;\n            if (tapped) this.start();\n        } else if (this.state === 'playing') {\n            this.updatePlaying(dt, tapped);\n        } else if (this.state === 'gameover') {\n            this.gameOverTime += dt;\n            // Update particles/effects even after death\n            this.gs.particles.update(dt);\n            this.gs.popups.update(dt);\n            this.gs.shakeTimer -= dt;\n            if (this.gs.shakeTimer < 0) this.gs.shakeTimer = 0;\n            this.gs.shakeAmount *= Math.max(0, 1 - 8 * dt);\n            this.gs.flashAlpha -= dt * 3;\n            if (this.gs.flashAlpha < 0) this.gs.flashAlpha = 0;\n\n            if (tapped && this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT) {\n                this.restart();\n            }\n        }\n    }\n\n    updatePlaying(dt, tapped) {\n        this.gs.update(dt, tapped);\n        this.score = this.gs.score;\n\n        if (!this.gs.pAlive) {\n            this.gameOver();\n        }\n    }\n\n    // -------------------------------------------------------\n    // Render\n    // -------------------------------------------------------\n\n    render() {\n        var ctx = this.ctx;\n        var cw = this.canvas.width;\n        var ch = this.canvas.height;\n\n        if (this.state === 'loading') {\n            this.renderLoading();\n        } else if (this.state === 'menu') {\n            this.renderer.renderMenu(ctx, cw, ch, this.gs, this.menuTime);\n        } else if (this.state === 'playing') {\n            this.renderer.render(ctx, this.canvas, this.gs);\n        } else if (this.state === 'gameover') {\n            // Render the game state frozen in background\n            this.renderer.render(ctx, this.canvas, this.gs);\n            // Overlay game over screen\n            var canRestart = this.gameOverTime >= LavaRise.GAME_OVER_LOCKOUT;\n            this.renderer.renderGameOver(ctx, cw, ch, this.gs, this.gameOverTime, canRestart);\n        }\n    }\n\n    renderLoading() {\n        var ctx = this.ctx;\n        ctx.fillStyle = '#1a0a2e';\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        ctx.fillStyle = '#ff4400';\n        ctx.font = 'bold 24px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('LAVA RISE', this.canvas.width / 2, this.canvas.height / 2);\n    }\n}\n","numLines":168,"startLine":1,"totalLines":168}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01BWibeFbhuz8JmLM47JDGH4","type":"message","role":"assistant","content":[{"type":"text","text":"Let me verify the final `index.html`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2117,"cache_read_input_tokens":77511,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2117},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"ecfbd47d-f3bd-49a2-ad41-934705bab325"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01BWibeFbhuz8JmLM47JDGH4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0183SumuPfbhUtpgaEYP33yt","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2117,"cache_read_input_tokens":77511,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2117},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"b4f9b534-e582-421e-b176-45796ac0ff9e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0183SumuPfbhUtpgaEYP33yt","type":"tool_result","content":"     1â†’<!DOCTYPE html>\n     2â†’<html lang=\"en\">\n     3â†’<head>\n     4â†’    <meta charset=\"UTF-8\">\n     5â†’    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n     6â†’    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n     7â†’    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n     8â†’    <title>Lava Rise</title>\n     9â†’    <link rel=\"stylesheet\" href=\"css/styles.css\">\n    10â†’</head>\n    11â†’<body>\n    12â†’    <div id=\"game-container\">\n    13â†’        <canvas id=\"game-canvas\"></canvas>\n    14â†’    </div>\n    15â†’\n    16â†’    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    17â†’    <script src=\"js/poki.js\"></script>\n    18â†’    <script src=\"js/audio.js\"></script>\n    19â†’    <script src=\"js/lava-rise.js\"></script>\n    20â†’    <script type=\"module\" src=\"js/main.js\"></script>\n    21â†’</body>\n    22â†’</html>\n    23â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"8c166eb3-7bd9-4154-b09a-616204b35c3e","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <title>Lava Rise</title>\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n</head>\n<body>\n    <div id=\"game-container\">\n        <canvas id=\"game-canvas\"></canvas>\n    </div>\n\n    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    <script src=\"js/poki.js\"></script>\n    <script src=\"js/audio.js\"></script>\n    <script src=\"js/lava-rise.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>\n</body>\n</html>\n","numLines":23,"startLine":1,"totalLines":23}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_014eT99w7nYnoJcrhpLH2oi3","type":"message","role":"assistant","content":[{"type":"text","text":"Good. Now let me think about potential gameplay issues and fix them:\n\n1. **Lava warning direction**: `lavaDistance = this.py - this.lavaY` -- since player Y is negative (going up) and lava Y starts positive then goes negative, this difference starts large positive but... wait. Player starts at py=-50, lava at lavaY=200. So `py - lavaY = -50 - 200 = -250`. That's negative, so the warning wouldn't trigger initially. But as lava rises (lavaY decreases), eventually lavaY catches up to py. When lava is just below player, e.g., py=-500, lavaY=-400, then `py - lavaY = -500 - (-400) = -100`. Still negative. The lava is \"below\" (higher Y value) than the player. \n\nThe issue is: in this coordinate system, \"below\" means higher Y. The player is at -500, lava at -400. Lava Y > player Y means lava is below player on screen. The check `this.py > this.lavaY - PLAYER_H/2` for death means \"if player Y is greater than lava Y minus half height\" -- when player falls INTO lava, player's Y increases (falls down) past the lava surface. This is correct.\n\nBut the warning check `lavaDistance = this.py - this.lavaY` gives a negative value when lava is below player. I need to flip this."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":439,"cache_read_input_tokens":79628,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":439},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"a5a385fa-167b-4480-a8ba-ddd9d0a846ed"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_014eT99w7nYnoJcrhpLH2oi3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012UKaGoNwGRYGZGbp5bB4oC","name":"Edit","input":{"replace_all":false,"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","old_string":"        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {","new_string":"        // Lava warning (lavaY > py means lava is below player; smaller gap = more danger)\n        var lavaDistance = this.lavaY - this.py;\n        if (lavaDistance < 150 && lavaDistance > 0) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":439,"cache_read_input_tokens":79628,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":439},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"437e59e7-7e50-4cd4-b991-b39e105190c3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012UKaGoNwGRYGZGbp5bB4oC","type":"tool_result","content":"The file F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"67f94272-1e7c-4e74-9801-2eaedbf86bc7","tool_use_result":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","oldString":"        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {","newString":"        // Lava warning (lavaY > py means lava is below player; smaller gap = more danger)\n        var lavaDistance = this.lavaY - this.py;\n        if (lavaDistance < 150 && lavaDistance > 0) {","originalFile":"/**\n * Lava Rise - Complete game logic\n * Wall-jump between narrowing walls to outrun rising lava\n */\n\nvar LavaRise = (function() {\n    'use strict';\n\n    // -------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------\n    var VIRTUAL_W = 400;\n    var PLAYER_W = 18;\n    var PLAYER_H = 24;\n    var GRAVITY = 1400;\n    var JUMP_VY = -520;\n    var JUMP_VX_BASE = 400;\n    var WALL_THICKNESS = 40;\n    var COIN_RADIUS = 10;\n    var SPIKE_W = 20;\n    var SPIKE_H = 16;\n    var PLATFORM_W = 50;\n    var PLATFORM_H = 10;\n    var PARTICLE_POOL_SIZE = 200;\n    var SLOW_MO_DURATION = 0.3;\n    var SLOW_MO_FACTOR = 0.4;\n    var SAFE_TIME = 5.0;\n    var GAME_OVER_LOCKOUT = 0.8;\n    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    var LAVA_SPEED_MIN = 60;\n    var LAVA_SPEED_MAX = 150;\n    var WALL_GAP_MAX = 400;\n    var WALL_GAP_MIN = 220;\n    var CAMERA_LEAD = 0.3;\n    var CAMERA_SMOOTH = 4.0;\n\n    // Colors\n    var COL_BG_TOP = '#1a0a2e';\n    var COL_BG_BOT = '#0d0015';\n    var COL_WALL_LEFT = '#3a2a5c';\n    var COL_WALL_RIGHT = '#3a2a5c';\n    var COL_WALL_EDGE = '#6a4a9a';\n    var COL_PLAYER = '#00e5ff';\n    var COL_PLAYER_EYE = '#ffffff';\n    var COL_COIN = '#ffd700';\n    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    var COL_SPIKE = '#ff3366';\n    var COL_LAVA_TOP = '#ff4400';\n    var COL_LAVA_MID = '#ff2200';\n    var COL_LAVA_BOT = '#cc1100';\n    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    var COL_PLATFORM = '#8866bb';\n    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    var COL_SCORE = '#ffffff';\n    var COL_HEIGHT = '#aaaaaa';\n\n    // -------------------------------------------------------\n    // Procedural Audio\n    // -------------------------------------------------------\n    var SFX = {\n        _ctx: null,\n\n        init: function() {\n            if (GameAudio.ctx) {\n                this._ctx = GameAudio.ctx;\n            }\n        },\n\n        _ensureCtx: function() {\n            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n            return this._ctx;\n        },\n\n        jump: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(300, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.1);\n        },\n\n        wallHit: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'triangle';\n            osc.frequency.setValueAtTime(150, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.08);\n        },\n\n        coin: function(streak) {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var baseFreq = 800 + Math.min(streak, 10) * 80;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.15);\n            // Harmonic\n            var osc2 = ctx.createOscillator();\n            var gain2 = ctx.createGain();\n            osc2.type = 'sine';\n            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n            osc2.connect(gain2);\n            gain2.connect(ctx.destination);\n            osc2.start(ctx.currentTime + 0.05);\n            osc2.stop(ctx.currentTime + 0.2);\n        },\n\n        die: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sawtooth';\n            osc.frequency.setValueAtTime(400, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.4);\n            // Noise burst\n            var bufSize = ctx.sampleRate * 0.3;\n            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n            var data = buf.getChannelData(0);\n            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n            var noise = ctx.createBufferSource();\n            noise.buffer = buf;\n            var ng = ctx.createGain();\n            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            noise.connect(ng);\n            ng.connect(ctx.destination);\n            noise.start(ctx.currentTime);\n            noise.stop(ctx.currentTime + 0.3);\n        },\n\n        lavaWarn: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(100, ctx.currentTime);\n            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.3);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Particle Pool\n    // -------------------------------------------------------\n    function ParticlePool(size) {\n        this.pool = [];\n        for (var i = 0; i < size; i++) {\n            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n        }\n    }\n\n    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) {\n                p.alive = true;\n                p.x = x; p.y = y;\n                p.vx = vx; p.vy = vy;\n                p.life = life; p.maxLife = life;\n                p.r = r; p.g = g; p.b = b;\n                p.size = size || 2;\n                return p;\n            }\n        }\n        return null;\n    };\n\n    ParticlePool.prototype.update = function(dt) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            p.life -= dt;\n            if (p.life <= 0) { p.alive = false; continue; }\n            p.x += p.vx * dt;\n            p.y += p.vy * dt;\n            p.vy += 200 * dt; // light gravity on particles\n        }\n    };\n\n    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            var sz = p.size * scale * alpha;\n            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    ParticlePool.prototype.clear = function() {\n        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n    };\n\n    // -------------------------------------------------------\n    // Score Popup Pool\n    // -------------------------------------------------------\n    function PopupPool() {\n        this.popups = [];\n    }\n\n    PopupPool.prototype.spawn = function(x, y, text, color) {\n        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n    };\n\n    PopupPool.prototype.update = function(dt) {\n        for (var i = this.popups.length - 1; i >= 0; i--) {\n            var p = this.popups[i];\n            p.life -= dt;\n            p.y -= 60 * dt;\n            if (p.life <= 0) this.popups.splice(i, 1);\n        }\n    };\n\n    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.popups.length; i++) {\n            var p = this.popups[i];\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = p.color;\n            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText(p.text, sx, sy);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    // -------------------------------------------------------\n    // Main Game State\n    // -------------------------------------------------------\n    function State() {\n        this.reset();\n        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n        this.popups = new PopupPool();\n        this.highScore = 0;\n        this.totalCoins = 0;\n        try {\n            var hs = localStorage.getItem('lavarise_hs');\n            if (hs) this.highScore = parseInt(hs, 10) || 0;\n            var tc = localStorage.getItem('lavarise_coins');\n            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n        } catch(e) {}\n    }\n\n    State.prototype.reset = function() {\n        this.playTime = 0;\n        this.difficultyLevel = 0;\n        this.score = 0;\n        this.heightScore = 0;\n        this.coinScore = 0;\n        this.coinStreak = 0;\n        this.coinStreakTimer = 0;\n\n        // Player\n        this.px = VIRTUAL_W * 0.25;\n        this.py = 0;\n        this.pvx = 0;\n        this.pvy = 0;\n        this.pOnWall = 'left'; // 'left', 'right', 'air'\n        this.pFacing = 1; // 1=right, -1=left\n        this.pAlive = true;\n        this.pInvincible = 0;\n        this.pSquash = 1.0; // squash-stretch factor\n\n        // Camera\n        this.camY = 0;\n        this.camTargetY = 0;\n\n        // Lava\n        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n        this.lavaSpeed = LAVA_SPEED_MIN;\n        this.lavaWarnTimer = 0;\n\n        // Walls\n        this.wallGap = WALL_GAP_MAX;\n        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n\n        // Obstacles and coins\n        this.obstacles = [];\n        this.coins = [];\n        this.lastSpawnY = 0;\n        this.spawnInterval = 120;\n\n        // Effects\n        this.slowMoTimer = 0;\n        this.shakeAmount = 0;\n        this.shakeTimer = 0;\n        this.gameOverTimer = 0;\n        this.flashAlpha = 0;\n\n        if (this.particles) this.particles.clear();\n        if (this.popups) this.popups = new PopupPool();\n    };\n\n    // -------------------------------------------------------\n    // Game Logic\n    // -------------------------------------------------------\n\n    State.prototype.initGame = function() {\n        this.reset();\n        // Player starts on left wall, slightly above where lava will begin\n        this.py = -50;\n        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n        this.pOnWall = 'left';\n        this.pFacing = 1;\n        this.pInvincible = SAFE_TIME;\n        this.camY = this.py - 200;\n        this.camTargetY = this.camY;\n        this.lavaY = 200; // starts below player\n\n        // Seed some coins in the safe zone\n        this._spawnCoin(-100);\n        this._spawnCoin(-220);\n        this._spawnCoin(-350);\n\n        SFX.init();\n    };\n\n    State.prototype._getWallGap = function() {\n        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n    };\n\n    State.prototype._getWallLeft = function() {\n        return (VIRTUAL_W - this._getWallGap()) / 2;\n    };\n\n    State.prototype._getWallRight = function() {\n        return (VIRTUAL_W + this._getWallGap()) / 2;\n    };\n\n    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });\n        } else {\n            // Crumbling ledge\n            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n            this.obstacles.push({\n                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n                side: side2, timer: 0, crumbling: false, fallen: false\n            });\n        }\n    };\n\n    State.prototype.update = function(dt, tapped) {\n        if (!this.pAlive) return;\n\n        // Slow-mo\n        var effectiveDt = dt;\n        if (this.slowMoTimer > 0) {\n            this.slowMoTimer -= dt;\n            effectiveDt = dt * SLOW_MO_FACTOR;\n        }\n\n        this.playTime += effectiveDt;\n        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n\n        // Invincibility\n        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n\n        // Coin streak timeout\n        if (this.coinStreakTimer > 0) {\n            this.coinStreakTimer -= effectiveDt;\n            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n        }\n\n        // Wall narrowing\n        this.wallGap = this._getWallGap();\n        this.wallLeft = this._getWallLeft();\n        this.wallRight = this._getWallRight();\n\n        // Lava rise\n        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n\n        // Lava warning\n        var lavaDistance = this.py - this.lavaY;\n        if (lavaDistance < 150 && lavaDistance > 0) {\n            this.lavaWarnTimer -= effectiveDt;\n            if (this.lavaWarnTimer <= 0) {\n                SFX.lavaWarn();\n                this.lavaWarnTimer = 0.5;\n            }\n        }\n\n        // Jump input\n        if (tapped && this.pOnWall !== 'air') {\n            this._jump();\n        }\n\n        // Physics\n        if (this.pOnWall === 'air') {\n            this.pvy += GRAVITY * effectiveDt;\n            this.px += this.pvx * effectiveDt;\n            this.py += this.pvy * effectiveDt;\n\n            // Wall collision\n            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n\n            if (this.px <= leftEdge) {\n                this.px = leftEdge;\n                this.pOnWall = 'left';\n                this.pFacing = 1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('left');\n            } else if (this.px >= rightEdge) {\n                this.px = rightEdge;\n                this.pOnWall = 'right';\n                this.pFacing = -1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('right');\n            }\n\n            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n        } else {\n            // On wall - slide down slowly\n            this.pvy = 30; // gentle slide\n            this.py += this.pvy * effectiveDt;\n\n            // Keep within wall bounds\n            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n            if (this.pOnWall === 'left') this.px = le;\n            else this.px = re;\n        }\n\n        // Squash recovery\n        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n\n        // Obstacle updates\n        this._updateObstacles(effectiveDt);\n\n        // Coin collection\n        this._updateCoins(effectiveDt);\n\n        // Collision with obstacles\n        if (this.pInvincible <= 0) {\n            this._checkObstacleCollisions();\n        }\n\n        // Lava death\n        if (this.py > this.lavaY - PLAYER_H / 2) {\n            this._die('lava');\n            return;\n        }\n\n        // Spawn new content ahead\n        this._spawnContent();\n\n        // Height score (negative Y = higher)\n        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n        this.score = this.heightScore + this.coinScore;\n\n        // Camera\n        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n\n        // Cleanup off-screen objects\n        this._cleanup();\n\n        // Effects\n        this.shakeTimer -= effectiveDt;\n        if (this.shakeTimer < 0) this.shakeTimer = 0;\n        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n\n        this.flashAlpha -= effectiveDt * 3;\n        if (this.flashAlpha < 0) this.flashAlpha = 0;\n\n        // Particles\n        this.particles.update(effectiveDt);\n        this.popups.update(effectiveDt);\n\n        // Lava particles\n        this._spawnLavaParticles(effectiveDt);\n    };\n\n    State.prototype._jump = function() {\n        var dir = this.pOnWall === 'left' ? 1 : -1;\n        this.pvx = JUMP_VX_BASE * dir;\n        this.pvy = JUMP_VY;\n        this.pOnWall = 'air';\n        this.pFacing = dir;\n        this.pSquash = 1.4; // stretch on jump\n        SFX.jump();\n\n        // Jump particles\n        for (var i = 0; i < 5; i++) {\n            var angle = Math.random() * Math.PI - Math.PI / 2;\n            var speed = 50 + Math.random() * 80;\n            this.particles.spawn(\n                this.px, this.py,\n                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n                0.3 + Math.random() * 0.2,\n                0, 229, 255, 3\n            );\n        }\n    };\n\n    State.prototype._spawnWallParticles = function(side) {\n        for (var i = 0; i < 6; i++) {\n            var dir = side === 'left' ? 1 : -1;\n            this.particles.spawn(\n                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n                0.2 + Math.random() * 0.2,\n                100, 80, 160, 3\n            );\n        }\n    };\n\n    State.prototype._updateObstacles = function(dt) {\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'platform') {\n                obs.x += obs.speed * obs.dir * dt;\n                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n            }\n            if (obs.type === 'crumble' && obs.crumbling) {\n                obs.timer += dt;\n                if (obs.timer > 0.5) obs.fallen = true;\n            }\n        }\n    };\n\n    State.prototype._updateCoins = function(dt) {\n        var px = this.px, py = this.py;\n        for (var i = 0; i < this.coins.length; i++) {\n            var c = this.coins[i];\n            if (c.collected) continue;\n            c.bobPhase += dt * 3;\n\n            var dx = px - c.x;\n            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n            var dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n                c.collected = true;\n                this.coinStreak++;\n                this.coinStreakTimer = 2.0;\n                var points = 10 * Math.min(this.coinStreak, 10);\n                this.coinScore += points;\n                this.totalCoins++;\n                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n\n                // Slow-mo\n                this.slowMoTimer = SLOW_MO_DURATION;\n\n                // Effects\n                this.flashAlpha = 0.3;\n                SFX.coin(this.coinStreak);\n                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n\n                // Coin burst particles\n                for (var j = 0; j < 8; j++) {\n                    var angle = (j / 8) * Math.PI * 2;\n                    this.particles.spawn(\n                        c.x, c.y,\n                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n                        0.4, 255, 215, 0, 3\n                    );\n                }\n            }\n        }\n    };\n\n    State.prototype._checkObstacleCollisions = function() {\n        var px = this.px, py = this.py;\n        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'crumble' && obs.fallen) continue;\n\n            if (obs.type === 'spike') {\n                // AABB\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    this._die('spike');\n                    return;\n                }\n            }\n\n            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n                // Land on top\n                if (this.pvy > 0 && this.pOnWall === 'air') {\n                    if (pl < obs.x + obs.w && pr > obs.x &&\n                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n                        py - ph / 2 < obs.y) {\n                        // Landing on platform\n                        // For crumbling, start crumble timer\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n                // Side collision with platform acts like a small wall\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    // Push player out horizontally if mostly horizontal collision\n                    var overlapL = pr - obs.x;\n                    var overlapR = obs.x + obs.w - pl;\n                    var overlapT = pb - obs.y;\n                    var overlapB = obs.y + obs.h - pt;\n                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n                    if (minOverlap === overlapT && this.pvy > 0) {\n                        // Land on top\n                        this.py = obs.y - ph / 2;\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    State.prototype._die = function(cause) {\n        if (!this.pAlive) return;\n        this.pAlive = false;\n        SFX.die();\n        this.shakeAmount = 8;\n        this.shakeTimer = 0.4;\n        this.flashAlpha = 0.5;\n        this.gameOverTimer = 0;\n\n        // Death particles\n        for (var i = 0; i < 20; i++) {\n            var angle = (i / 20) * Math.PI * 2;\n            var speed = 80 + Math.random() * 120;\n            var r = cause === 'lava' ? 255 : 255;\n            var g = cause === 'lava' ? 68 : 51;\n            var b = cause === 'lava' ? 0 : 102;\n            this.particles.spawn(\n                this.px, this.py,\n                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n                0.5 + Math.random() * 0.3,\n                r, g, b, 4\n            );\n        }\n\n        // Save high score\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n        }\n    };\n\n    State.prototype._spawnContent = function() {\n        // Spawn ahead of camera (negative Y is up)\n        var spawnAhead = this.camY - 500;\n        while (this.lastSpawnY > spawnAhead) {\n            this.lastSpawnY -= this.spawnInterval;\n\n            // Don't spawn obstacles during safe time\n            if (this.playTime > SAFE_TIME) {\n                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n                if (Math.random() < obstacleChance) {\n                    this._spawnObstacle(this.lastSpawnY);\n                }\n            }\n\n            // Always spawn coins (good density)\n            if (Math.random() < 0.5) {\n                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n            }\n\n            // Decrease spawn interval with difficulty\n            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n        }\n    };\n\n    State.prototype._spawnLavaParticles = function(dt) {\n        if (!this._lavaParticleTimer) this._lavaParticleTimer = 0;\n        this._lavaParticleTimer += dt;\n        if (this._lavaParticleTimer < 0.05) return;\n        this._lavaParticleTimer = 0;\n\n        // Spawn bubbles along lava surface\n        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n        this.particles.spawn(\n            x, this.lavaY,\n            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n            0.5 + Math.random() * 0.5,\n            255, Math.floor(40 + Math.random() * 60), 0, 4\n        );\n    };\n\n    State.prototype._cleanup = function() {\n        var below = this.lavaY + 100;\n        // Remove coins below lava\n        for (var i = this.coins.length - 1; i >= 0; i--) {\n            if (this.coins[i].y > below || this.coins[i].collected) {\n                this.coins.splice(i, 1);\n            }\n        }\n        // Remove obstacles below lava\n        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n            if (this.obstacles[j].y > below) {\n                this.obstacles.splice(j, 1);\n            }\n        }\n    };\n\n    // -------------------------------------------------------\n    // Rendering\n    // -------------------------------------------------------\n\n    function Renderer() {}\n\n    Renderer.prototype.render = function(ctx, canvas, state) {\n        var cw = canvas.width;\n        var ch = canvas.height;\n\n        // Virtual coordinate mapping\n        var scale = cw / VIRTUAL_W;\n        var virtualH = ch / scale;\n        var offsetX = 0;\n\n        // Screen shake\n        var shakeX = 0, shakeY = 0;\n        if (state.shakeTimer > 0) {\n            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n        }\n\n        ctx.save();\n        ctx.translate(shakeX, shakeY);\n\n        // Background gradient\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, COL_BG_BOT);\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n\n        // Background stars (parallax)\n        this._renderStars(ctx, cw, ch, state.camY);\n\n        // Walls\n        this._renderWalls(ctx, state, scale, offsetX, ch);\n\n        // Obstacles\n        this._renderObstacles(ctx, state, scale, offsetX);\n\n        // Coins\n        this._renderCoins(ctx, state, scale, offsetX);\n\n        // Player\n        if (state.pAlive) {\n            this._renderPlayer(ctx, state, scale, offsetX);\n        }\n\n        // Particles\n        state.particles.render(ctx, state.camY, scale, offsetX);\n\n        // Lava\n        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n\n        // Popups\n        state.popups.render(ctx, state.camY, scale, offsetX);\n\n        ctx.restore();\n\n        // Flash overlay\n        if (state.flashAlpha > 0) {\n            ctx.globalAlpha = state.flashAlpha;\n            ctx.fillStyle = '#fff';\n            ctx.fillRect(0, 0, cw, ch);\n            ctx.globalAlpha = 1;\n        }\n\n        // HUD (not affected by shake)\n        this._renderHUD(ctx, cw, ch, state);\n    };\n\n    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n        // Simple deterministic stars\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        var seed = 42;\n        for (var i = 0; i < 40; i++) {\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sx = (seed % cw);\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sy = (seed % (ch * 3));\n            var parallax = 0.05;\n            var screenY = (sy - camY * parallax) % (ch * 3);\n            if (screenY < 0) screenY += ch * 3;\n            if (screenY < ch) {\n                var size = 1 + (i % 3);\n                ctx.fillRect(sx, screenY, size, size);\n            }\n        }\n    };\n\n    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n        var camY = state.camY;\n        var topY = 0;\n        var botY = ch;\n\n        // Left wall\n        var lwScreen = state.wallLeft * scale + offsetX;\n        var lwWidth = (WALL_THICKNESS) * scale;\n        ctx.fillStyle = COL_WALL_LEFT;\n        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n\n        // Right wall\n        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n        ctx.fillStyle = COL_WALL_RIGHT;\n        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n\n        // Wall bricks pattern\n        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n        var brickH = 20 * scale;\n        var startBrickY = Math.floor(camY / 20) * 20;\n        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n            var sy = (by - camY) * scale;\n            var offset = ((by / 20) % 2) * 10 * scale;\n            // Left wall bricks\n            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n                ctx.fillRect(bx + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n            // Right wall bricks\n            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n        }\n    };\n\n    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.obstacles.length; i++) {\n            var obs = state.obstacles[i];\n            var sx = obs.x * scale + offsetX;\n            var sy = (obs.y - camY) * scale;\n            var sw = obs.w * scale;\n            var sh = obs.h * scale;\n\n            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n\n            if (obs.type === 'spike') {\n                ctx.fillStyle = COL_SPIKE;\n                ctx.beginPath();\n                if (obs.side === 'left') {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                } else {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowColor = COL_SPIKE;\n                ctx.shadowBlur = 6 * scale;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            } else if (obs.type === 'platform') {\n                ctx.fillStyle = COL_PLATFORM;\n                ctx.fillRect(sx, sy, sw, sh);\n                // Top highlight\n                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n                ctx.fillRect(sx, sy, sw, 2 * scale);\n            } else if (obs.type === 'crumble') {\n                if (obs.fallen) continue;\n                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n                // Shake if crumbling\n                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n                ctx.globalAlpha = 1;\n            }\n        }\n    };\n\n    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.coins.length; i++) {\n            var c = state.coins[i];\n            if (c.collected) continue;\n            var sx = c.x * scale + offsetX;\n            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n            var sr = COIN_RADIUS * scale;\n\n            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n\n            // Glow\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN_GLOW;\n            ctx.fill();\n\n            // Coin body\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN;\n            ctx.fill();\n\n            // Shine\n            ctx.beginPath();\n            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.fill();\n        }\n    };\n\n    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n        var sx = state.px * scale + offsetX;\n        var sy = (state.py - state.camY) * scale;\n        var sw = PLAYER_W * scale;\n        var sh = PLAYER_H * scale;\n\n        // Invincibility blink\n        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n            ctx.globalAlpha = 0.5;\n        }\n\n        // Squash-stretch\n        var squashX = 1 / state.pSquash;\n        var squashY = state.pSquash;\n\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.scale(squashX, squashY);\n\n        // Body\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 8 * scale;\n        var bodyW = sw;\n        var bodyH = sh;\n        // Rounded rectangle body\n        var r = 4 * scale;\n        ctx.beginPath();\n        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Eyes\n        var eyeOffX = state.pFacing * 3 * scale;\n        var eyeY = -3 * scale;\n        ctx.fillStyle = COL_PLAYER_EYE;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils (look in movement direction)\n        ctx.fillStyle = '#222';\n        var pupilOff = state.pFacing * 1 * scale;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n        ctx.globalAlpha = 1;\n    };\n\n    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n        var lavaScreenY = (state.lavaY - state.camY) * scale;\n        if (lavaScreenY > ch + 50) return;\n\n        var topY = Math.max(0, lavaScreenY - 10 * scale);\n\n        // Lava glow above surface\n        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n\n        // Lava surface wave\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        ctx.lineTo(0, lavaScreenY);\n        var waveTime = state.playTime * 2;\n        for (var x = 0; x <= cw; x += 4) {\n            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n            ctx.lineTo(x, waveY);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n\n        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Surface highlight\n        ctx.strokeStyle = '#ff8800';\n        ctx.lineWidth = 2 * scale;\n        ctx.beginPath();\n        for (var x2 = 0; x2 <= cw; x2 += 4) {\n            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n            if (x2 === 0) ctx.moveTo(x2, waveY2);\n            else ctx.lineTo(x2, waveY2);\n        }\n        ctx.stroke();\n    };\n\n    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n        var pad = Math.max(12, cw * 0.03);\n        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n\n        // Score\n        ctx.fillStyle = COL_SCORE;\n        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n\n        // Height indicator\n        ctx.fillStyle = COL_HEIGHT;\n        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n\n        // Coin streak\n        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n            ctx.globalAlpha = 1;\n        }\n\n        // High score (small, top right)\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n        }\n\n        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Menu / Game Over rendering\n    // -------------------------------------------------------\n\n    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n        // Background\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, '#1a0505');\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(0, 0, cw, ch);\n\n        // Decorative lava at bottom\n        var lavaH = ch * 0.25;\n        var lavaTop = ch - lavaH;\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        for (var x = 0; x <= cw; x += 4) {\n            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n            ctx.lineTo(x, wy);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Glow\n        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n\n        // Title\n        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n        var centerY = ch * 0.32;\n        ctx.fillStyle = COL_LAVA_TOP;\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.shadowColor = '#ff4400';\n        ctx.shadowBlur = 20;\n        ctx.fillText('LAVA RISE', cw / 2, centerY);\n        ctx.shadowBlur = 0;\n\n        // Subtitle\n        ctx.fillStyle = COL_PLAYER;\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n\n        // Tap prompt (pulsing)\n        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n        ctx.globalAlpha = pulseAlpha;\n        ctx.fillStyle = '#ffffff';\n        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n        ctx.globalAlpha = 1;\n\n        // High score\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n        }\n\n        // Small player character preview (bouncing)\n        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n        var ps = Math.max(1, cw / VIRTUAL_W);\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 10;\n        var pw = PLAYER_W * ps;\n        var ph = PLAYER_H * ps;\n        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n        ctx.shadowBlur = 0;\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n    };\n\n    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n        // Darken\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, cw, ch);\n\n        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n        var centerY = ch * 0.3;\n\n        // Game over text\n        ctx.fillStyle = '#ff3333';\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', cw / 2, centerY);\n\n        // Score\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n\n        // Height and coins\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n\n        // New high score?\n        if (state.score >= state.highScore && state.score > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n        }\n\n        // Restart prompt\n        if (canRestart) {\n            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n            ctx.globalAlpha = pulseAlpha;\n            ctx.fillStyle = '#ffffff';\n            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n            ctx.globalAlpha = 1;\n        }\n    };\n\n    // -------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------\n    return {\n        State: State,\n        Renderer: Renderer,\n        SFX: SFX,\n        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n    };\n\n})();\n","structuredPatch":[{"oldStart":448,"oldLines":8,"newStart":448,"newLines":8,"lines":["         this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;","         this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)"," ","-        // Lava warning","-        var lavaDistance = this.py - this.lavaY;","+        // Lava warning (lavaY > py means lava is below player; smaller gap = more danger)","+        var lavaDistance = this.lavaY - this.py;","         if (lavaDistance < 150 && lavaDistance > 0) {","             this.lavaWarnTimer -= effectiveDt;","             if (this.lavaWarnTimer <= 0) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01Ef84iBkPzqWAuVd4htMpCx","type":"message","role":"assistant","content":[{"type":"text","text":"Now fix the same issue in the HUD lava proximity warning:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":824,"cache_read_input_tokens":80067,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":824},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"3919c1a1-d9b5-4d6c-9834-233c487d0fc7"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01Ef84iBkPzqWAuVd4htMpCx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LgH4Y5CiXYvNsbSDirvvuK","name":"Edit","input":{"replace_all":false,"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","old_string":"        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {","new_string":"        // Lava proximity warning\n        var lavaDist = state.lavaY - state.py;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":824,"cache_read_input_tokens":80067,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":824},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"8d1cb870-49f6-42fc-9894-d7c6a01b9efd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LgH4Y5CiXYvNsbSDirvvuK","type":"tool_result","content":"The file F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"4ec5f116-909f-444d-bda4-02e3e5eddd1c","tool_use_result":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","oldString":"        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {","newString":"        // Lava proximity warning\n        var lavaDist = state.lavaY - state.py;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {","originalFile":"/**\n * Lava Rise - Complete game logic\n * Wall-jump between narrowing walls to outrun rising lava\n */\n\nvar LavaRise = (function() {\n    'use strict';\n\n    // -------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------\n    var VIRTUAL_W = 400;\n    var PLAYER_W = 18;\n    var PLAYER_H = 24;\n    var GRAVITY = 1400;\n    var JUMP_VY = -520;\n    var JUMP_VX_BASE = 400;\n    var WALL_THICKNESS = 40;\n    var COIN_RADIUS = 10;\n    var SPIKE_W = 20;\n    var SPIKE_H = 16;\n    var PLATFORM_W = 50;\n    var PLATFORM_H = 10;\n    var PARTICLE_POOL_SIZE = 200;\n    var SLOW_MO_DURATION = 0.3;\n    var SLOW_MO_FACTOR = 0.4;\n    var SAFE_TIME = 5.0;\n    var GAME_OVER_LOCKOUT = 0.8;\n    var DIFFICULTY_RAMP_TIME = 120; // 2 minutes to max\n    var LAVA_SPEED_MIN = 60;\n    var LAVA_SPEED_MAX = 150;\n    var WALL_GAP_MAX = 400;\n    var WALL_GAP_MIN = 220;\n    var CAMERA_LEAD = 0.3;\n    var CAMERA_SMOOTH = 4.0;\n\n    // Colors\n    var COL_BG_TOP = '#1a0a2e';\n    var COL_BG_BOT = '#0d0015';\n    var COL_WALL_LEFT = '#3a2a5c';\n    var COL_WALL_RIGHT = '#3a2a5c';\n    var COL_WALL_EDGE = '#6a4a9a';\n    var COL_PLAYER = '#00e5ff';\n    var COL_PLAYER_EYE = '#ffffff';\n    var COL_COIN = '#ffd700';\n    var COL_COIN_GLOW = 'rgba(255,215,0,0.3)';\n    var COL_SPIKE = '#ff3366';\n    var COL_LAVA_TOP = '#ff4400';\n    var COL_LAVA_MID = '#ff2200';\n    var COL_LAVA_BOT = '#cc1100';\n    var COL_LAVA_GLOW = 'rgba(255,68,0,0.4)';\n    var COL_PLATFORM = '#8866bb';\n    var COL_PLATFORM_CRUMBLE = '#aa8844';\n    var COL_SCORE = '#ffffff';\n    var COL_HEIGHT = '#aaaaaa';\n\n    // -------------------------------------------------------\n    // Procedural Audio\n    // -------------------------------------------------------\n    var SFX = {\n        _ctx: null,\n\n        init: function() {\n            if (GameAudio.ctx) {\n                this._ctx = GameAudio.ctx;\n            }\n        },\n\n        _ensureCtx: function() {\n            if (!this._ctx && GameAudio.ctx) this._ctx = GameAudio.ctx;\n            return this._ctx;\n        },\n\n        jump: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'square';\n            osc.frequency.setValueAtTime(300, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.08);\n            gain.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.1);\n        },\n\n        wallHit: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'triangle';\n            osc.frequency.setValueAtTime(150, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.06);\n            gain.gain.setValueAtTime(0.12 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.08);\n        },\n\n        coin: function(streak) {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var baseFreq = 800 + Math.min(streak, 10) * 80;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.1);\n            gain.gain.setValueAtTime(0.18 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.15);\n            // Harmonic\n            var osc2 = ctx.createOscillator();\n            var gain2 = ctx.createGain();\n            osc2.type = 'sine';\n            osc2.frequency.setValueAtTime(baseFreq * 2, ctx.currentTime + 0.05);\n            gain2.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime + 0.05);\n            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);\n            osc2.connect(gain2);\n            gain2.connect(ctx.destination);\n            osc2.start(ctx.currentTime + 0.05);\n            osc2.stop(ctx.currentTime + 0.2);\n        },\n\n        die: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sawtooth';\n            osc.frequency.setValueAtTime(400, ctx.currentTime);\n            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.4);\n            gain.gain.setValueAtTime(0.2 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.4);\n            // Noise burst\n            var bufSize = ctx.sampleRate * 0.3;\n            var buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);\n            var data = buf.getChannelData(0);\n            for (var i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;\n            var noise = ctx.createBufferSource();\n            noise.buffer = buf;\n            var ng = ctx.createGain();\n            ng.gain.setValueAtTime(0.15 * GameAudio.masterVolume, ctx.currentTime);\n            ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            noise.connect(ng);\n            ng.connect(ctx.destination);\n            noise.start(ctx.currentTime);\n            noise.stop(ctx.currentTime + 0.3);\n        },\n\n        lavaWarn: function() {\n            var ctx = this._ensureCtx();\n            if (!ctx) return;\n            var osc = ctx.createOscillator();\n            var gain = ctx.createGain();\n            osc.type = 'sine';\n            osc.frequency.setValueAtTime(100, ctx.currentTime);\n            osc.frequency.setValueAtTime(120, ctx.currentTime + 0.1);\n            osc.frequency.setValueAtTime(100, ctx.currentTime + 0.2);\n            gain.gain.setValueAtTime(0.08 * GameAudio.masterVolume, ctx.currentTime);\n            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);\n            osc.connect(gain);\n            gain.connect(ctx.destination);\n            osc.start(ctx.currentTime);\n            osc.stop(ctx.currentTime + 0.3);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Particle Pool\n    // -------------------------------------------------------\n    function ParticlePool(size) {\n        this.pool = [];\n        for (var i = 0; i < size; i++) {\n            this.pool.push({ alive: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, g: 0, b: 0, size: 2 });\n        }\n    }\n\n    ParticlePool.prototype.spawn = function(x, y, vx, vy, life, r, g, b, size) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) {\n                p.alive = true;\n                p.x = x; p.y = y;\n                p.vx = vx; p.vy = vy;\n                p.life = life; p.maxLife = life;\n                p.r = r; p.g = g; p.b = b;\n                p.size = size || 2;\n                return p;\n            }\n        }\n        return null;\n    };\n\n    ParticlePool.prototype.update = function(dt) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            p.life -= dt;\n            if (p.life <= 0) { p.alive = false; continue; }\n            p.x += p.vx * dt;\n            p.y += p.vy * dt;\n            p.vy += 200 * dt; // light gravity on particles\n        }\n    };\n\n    ParticlePool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.pool.length; i++) {\n            var p = this.pool[i];\n            if (!p.alive) continue;\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            var sz = p.size * scale * alpha;\n            if (sy < -20 || sy > ctx.canvas.height + 20) continue;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = 'rgb(' + p.r + ',' + p.g + ',' + p.b + ')';\n            ctx.fillRect(sx - sz * 0.5, sy - sz * 0.5, sz, sz);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    ParticlePool.prototype.clear = function() {\n        for (var i = 0; i < this.pool.length; i++) this.pool[i].alive = false;\n    };\n\n    // -------------------------------------------------------\n    // Score Popup Pool\n    // -------------------------------------------------------\n    function PopupPool() {\n        this.popups = [];\n    }\n\n    PopupPool.prototype.spawn = function(x, y, text, color) {\n        this.popups.push({ x: x, y: y, text: text, color: color, life: 0.8, maxLife: 0.8 });\n    };\n\n    PopupPool.prototype.update = function(dt) {\n        for (var i = this.popups.length - 1; i >= 0; i--) {\n            var p = this.popups[i];\n            p.life -= dt;\n            p.y -= 60 * dt;\n            if (p.life <= 0) this.popups.splice(i, 1);\n        }\n    };\n\n    PopupPool.prototype.render = function(ctx, camY, scale, offsetX) {\n        for (var i = 0; i < this.popups.length; i++) {\n            var p = this.popups[i];\n            var alpha = p.life / p.maxLife;\n            var sx = p.x * scale + offsetX;\n            var sy = (p.y - camY) * scale;\n            ctx.globalAlpha = alpha;\n            ctx.fillStyle = p.color;\n            ctx.font = 'bold ' + Math.floor(16 * scale) + 'px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.fillText(p.text, sx, sy);\n        }\n        ctx.globalAlpha = 1.0;\n    };\n\n    // -------------------------------------------------------\n    // Main Game State\n    // -------------------------------------------------------\n    function State() {\n        this.reset();\n        this.particles = new ParticlePool(PARTICLE_POOL_SIZE);\n        this.popups = new PopupPool();\n        this.highScore = 0;\n        this.totalCoins = 0;\n        try {\n            var hs = localStorage.getItem('lavarise_hs');\n            if (hs) this.highScore = parseInt(hs, 10) || 0;\n            var tc = localStorage.getItem('lavarise_coins');\n            if (tc) this.totalCoins = parseInt(tc, 10) || 0;\n        } catch(e) {}\n    }\n\n    State.prototype.reset = function() {\n        this.playTime = 0;\n        this.difficultyLevel = 0;\n        this.score = 0;\n        this.heightScore = 0;\n        this.coinScore = 0;\n        this.coinStreak = 0;\n        this.coinStreakTimer = 0;\n\n        // Player\n        this.px = VIRTUAL_W * 0.25;\n        this.py = 0;\n        this.pvx = 0;\n        this.pvy = 0;\n        this.pOnWall = 'left'; // 'left', 'right', 'air'\n        this.pFacing = 1; // 1=right, -1=left\n        this.pAlive = true;\n        this.pInvincible = 0;\n        this.pSquash = 1.0; // squash-stretch factor\n\n        // Camera\n        this.camY = 0;\n        this.camTargetY = 0;\n\n        // Lava\n        this.lavaY = 300; // world Y of lava surface (lower = higher on screen since Y goes down initially but we climb up)\n        this.lavaSpeed = LAVA_SPEED_MIN;\n        this.lavaWarnTimer = 0;\n\n        // Walls\n        this.wallGap = WALL_GAP_MAX;\n        this.wallLeft = (VIRTUAL_W - WALL_GAP_MAX) / 2;\n        this.wallRight = (VIRTUAL_W + WALL_GAP_MAX) / 2;\n\n        // Obstacles and coins\n        this.obstacles = [];\n        this.coins = [];\n        this.lastSpawnY = 0;\n        this.spawnInterval = 120;\n\n        // Effects\n        this.slowMoTimer = 0;\n        this.shakeAmount = 0;\n        this.shakeTimer = 0;\n        this.gameOverTimer = 0;\n        this.flashAlpha = 0;\n\n        if (this.particles) this.particles.clear();\n        if (this.popups) this.popups = new PopupPool();\n    };\n\n    // -------------------------------------------------------\n    // Game Logic\n    // -------------------------------------------------------\n\n    State.prototype.initGame = function() {\n        this.reset();\n        // Player starts on left wall, slightly above where lava will begin\n        this.py = -50;\n        this.px = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n        this.pOnWall = 'left';\n        this.pFacing = 1;\n        this.pInvincible = SAFE_TIME;\n        this.camY = this.py - 200;\n        this.camTargetY = this.camY;\n        this.lavaY = 200; // starts below player\n\n        // Seed some coins in the safe zone\n        this._spawnCoin(-100);\n        this._spawnCoin(-220);\n        this._spawnCoin(-350);\n\n        SFX.init();\n    };\n\n    State.prototype._getWallGap = function() {\n        return WALL_GAP_MAX - (WALL_GAP_MAX - WALL_GAP_MIN) * this.difficultyLevel;\n    };\n\n    State.prototype._getWallLeft = function() {\n        return (VIRTUAL_W - this._getWallGap()) / 2;\n    };\n\n    State.prototype._getWallRight = function() {\n        return (VIRTUAL_W + this._getWallGap()) / 2;\n    };\n\n    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });\n        } else {\n            // Crumbling ledge\n            var side2 = Math.random() < 0.5 ? 'left' : 'right';\n            var lx = side2 === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - 40;\n            this.obstacles.push({\n                type: 'crumble', x: lx, y: y, w: 40, h: PLATFORM_H,\n                side: side2, timer: 0, crumbling: false, fallen: false\n            });\n        }\n    };\n\n    State.prototype.update = function(dt, tapped) {\n        if (!this.pAlive) return;\n\n        // Slow-mo\n        var effectiveDt = dt;\n        if (this.slowMoTimer > 0) {\n            this.slowMoTimer -= dt;\n            effectiveDt = dt * SLOW_MO_FACTOR;\n        }\n\n        this.playTime += effectiveDt;\n        this.difficultyLevel = Math.min(1, this.playTime / DIFFICULTY_RAMP_TIME);\n\n        // Invincibility\n        if (this.pInvincible > 0) this.pInvincible -= effectiveDt;\n\n        // Coin streak timeout\n        if (this.coinStreakTimer > 0) {\n            this.coinStreakTimer -= effectiveDt;\n            if (this.coinStreakTimer <= 0) this.coinStreak = 0;\n        }\n\n        // Wall narrowing\n        this.wallGap = this._getWallGap();\n        this.wallLeft = this._getWallLeft();\n        this.wallRight = this._getWallRight();\n\n        // Lava rise\n        this.lavaSpeed = LAVA_SPEED_MIN + (LAVA_SPEED_MAX - LAVA_SPEED_MIN) * this.difficultyLevel;\n        this.lavaY -= this.lavaSpeed * effectiveDt; // moving upward in world coords (negative Y is up)\n\n        // Lava warning (lavaY > py means lava is below player; smaller gap = more danger)\n        var lavaDistance = this.lavaY - this.py;\n        if (lavaDistance < 150 && lavaDistance > 0) {\n            this.lavaWarnTimer -= effectiveDt;\n            if (this.lavaWarnTimer <= 0) {\n                SFX.lavaWarn();\n                this.lavaWarnTimer = 0.5;\n            }\n        }\n\n        // Jump input\n        if (tapped && this.pOnWall !== 'air') {\n            this._jump();\n        }\n\n        // Physics\n        if (this.pOnWall === 'air') {\n            this.pvy += GRAVITY * effectiveDt;\n            this.px += this.pvx * effectiveDt;\n            this.py += this.pvy * effectiveDt;\n\n            // Wall collision\n            var leftEdge = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var rightEdge = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n\n            if (this.px <= leftEdge) {\n                this.px = leftEdge;\n                this.pOnWall = 'left';\n                this.pFacing = 1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('left');\n            } else if (this.px >= rightEdge) {\n                this.px = rightEdge;\n                this.pOnWall = 'right';\n                this.pFacing = -1;\n                this.pvx = 0;\n                this.pvy = 0;\n                this.pSquash = 0.6;\n                SFX.wallHit();\n                this._spawnWallParticles('right');\n            }\n\n            // Sliding on wall (gravity pulls down while on wall, but only slowly)\n        } else {\n            // On wall - slide down slowly\n            this.pvy = 30; // gentle slide\n            this.py += this.pvy * effectiveDt;\n\n            // Keep within wall bounds\n            var le = this.wallLeft + WALL_THICKNESS + PLAYER_W / 2;\n            var re = this.wallRight - WALL_THICKNESS - PLAYER_W / 2;\n            if (this.pOnWall === 'left') this.px = le;\n            else this.px = re;\n        }\n\n        // Squash recovery\n        this.pSquash += (1.0 - this.pSquash) * 8 * effectiveDt;\n\n        // Obstacle updates\n        this._updateObstacles(effectiveDt);\n\n        // Coin collection\n        this._updateCoins(effectiveDt);\n\n        // Collision with obstacles\n        if (this.pInvincible <= 0) {\n            this._checkObstacleCollisions();\n        }\n\n        // Lava death\n        if (this.py > this.lavaY - PLAYER_H / 2) {\n            this._die('lava');\n            return;\n        }\n\n        // Spawn new content ahead\n        this._spawnContent();\n\n        // Height score (negative Y = higher)\n        var currentHeight = Math.floor(Math.max(0, -this.py / 10));\n        if (currentHeight > this.heightScore) this.heightScore = currentHeight;\n        this.score = this.heightScore + this.coinScore;\n\n        // Camera\n        this.camTargetY = this.py - 200 + this.pvy * CAMERA_LEAD;\n        this.camY += (this.camTargetY - this.camY) * CAMERA_SMOOTH * effectiveDt;\n\n        // Cleanup off-screen objects\n        this._cleanup();\n\n        // Effects\n        this.shakeTimer -= effectiveDt;\n        if (this.shakeTimer < 0) this.shakeTimer = 0;\n        this.shakeAmount *= Math.max(0, 1 - 8 * effectiveDt);\n\n        this.flashAlpha -= effectiveDt * 3;\n        if (this.flashAlpha < 0) this.flashAlpha = 0;\n\n        // Particles\n        this.particles.update(effectiveDt);\n        this.popups.update(effectiveDt);\n\n        // Lava particles\n        this._spawnLavaParticles(effectiveDt);\n    };\n\n    State.prototype._jump = function() {\n        var dir = this.pOnWall === 'left' ? 1 : -1;\n        this.pvx = JUMP_VX_BASE * dir;\n        this.pvy = JUMP_VY;\n        this.pOnWall = 'air';\n        this.pFacing = dir;\n        this.pSquash = 1.4; // stretch on jump\n        SFX.jump();\n\n        // Jump particles\n        for (var i = 0; i < 5; i++) {\n            var angle = Math.random() * Math.PI - Math.PI / 2;\n            var speed = 50 + Math.random() * 80;\n            this.particles.spawn(\n                this.px, this.py,\n                -dir * speed * Math.cos(angle), speed * Math.sin(angle) - 30,\n                0.3 + Math.random() * 0.2,\n                0, 229, 255, 3\n            );\n        }\n    };\n\n    State.prototype._spawnWallParticles = function(side) {\n        for (var i = 0; i < 6; i++) {\n            var dir = side === 'left' ? 1 : -1;\n            this.particles.spawn(\n                this.px, this.py + (Math.random() - 0.5) * PLAYER_H,\n                dir * (30 + Math.random() * 60), (Math.random() - 0.5) * 100,\n                0.2 + Math.random() * 0.2,\n                100, 80, 160, 3\n            );\n        }\n    };\n\n    State.prototype._updateObstacles = function(dt) {\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'platform') {\n                obs.x += obs.speed * obs.dir * dt;\n                if (obs.x <= obs.minX) { obs.x = obs.minX; obs.dir = 1; }\n                if (obs.x >= obs.maxX) { obs.x = obs.maxX; obs.dir = -1; }\n            }\n            if (obs.type === 'crumble' && obs.crumbling) {\n                obs.timer += dt;\n                if (obs.timer > 0.5) obs.fallen = true;\n            }\n        }\n    };\n\n    State.prototype._updateCoins = function(dt) {\n        var px = this.px, py = this.py;\n        for (var i = 0; i < this.coins.length; i++) {\n            var c = this.coins[i];\n            if (c.collected) continue;\n            c.bobPhase += dt * 3;\n\n            var dx = px - c.x;\n            var dy = py - (c.y + Math.sin(c.bobPhase) * 4);\n            var dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist < COIN_RADIUS + PLAYER_W * 0.6) {\n                c.collected = true;\n                this.coinStreak++;\n                this.coinStreakTimer = 2.0;\n                var points = 10 * Math.min(this.coinStreak, 10);\n                this.coinScore += points;\n                this.totalCoins++;\n                try { localStorage.setItem('lavarise_coins', '' + this.totalCoins); } catch(e) {}\n\n                // Slow-mo\n                this.slowMoTimer = SLOW_MO_DURATION;\n\n                // Effects\n                this.flashAlpha = 0.3;\n                SFX.coin(this.coinStreak);\n                this.popups.spawn(c.x, c.y - 15, '+' + points, COL_COIN);\n\n                // Coin burst particles\n                for (var j = 0; j < 8; j++) {\n                    var angle = (j / 8) * Math.PI * 2;\n                    this.particles.spawn(\n                        c.x, c.y,\n                        Math.cos(angle) * 80, Math.sin(angle) * 80,\n                        0.4, 255, 215, 0, 3\n                    );\n                }\n            }\n        }\n    };\n\n    State.prototype._checkObstacleCollisions = function() {\n        var px = this.px, py = this.py;\n        var pw = PLAYER_W * 0.7, ph = PLAYER_H * 0.7; // slightly forgiving hitbox\n        var pl = px - pw / 2, pr = px + pw / 2, pt = py - ph / 2, pb = py + ph / 2;\n\n        for (var i = 0; i < this.obstacles.length; i++) {\n            var obs = this.obstacles[i];\n            if (obs.type === 'crumble' && obs.fallen) continue;\n\n            if (obs.type === 'spike') {\n                // AABB\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    this._die('spike');\n                    return;\n                }\n            }\n\n            if (obs.type === 'platform' || (obs.type === 'crumble' && !obs.fallen)) {\n                // Land on top\n                if (this.pvy > 0 && this.pOnWall === 'air') {\n                    if (pl < obs.x + obs.w && pr > obs.x &&\n                        pb > obs.y && pb < obs.y + obs.h + 10 &&\n                        py - ph / 2 < obs.y) {\n                        // Landing on platform\n                        // For crumbling, start crumble timer\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n                // Side collision with platform acts like a small wall\n                if (pl < obs.x + obs.w && pr > obs.x && pt < obs.y + obs.h && pb > obs.y) {\n                    // Push player out horizontally if mostly horizontal collision\n                    var overlapL = pr - obs.x;\n                    var overlapR = obs.x + obs.w - pl;\n                    var overlapT = pb - obs.y;\n                    var overlapB = obs.y + obs.h - pt;\n                    var minOverlap = Math.min(overlapL, overlapR, overlapT, overlapB);\n                    if (minOverlap === overlapT && this.pvy > 0) {\n                        // Land on top\n                        this.py = obs.y - ph / 2;\n                        if (obs.type === 'crumble' && !obs.crumbling) {\n                            obs.crumbling = true;\n                            obs.timer = 0;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    State.prototype._die = function(cause) {\n        if (!this.pAlive) return;\n        this.pAlive = false;\n        SFX.die();\n        this.shakeAmount = 8;\n        this.shakeTimer = 0.4;\n        this.flashAlpha = 0.5;\n        this.gameOverTimer = 0;\n\n        // Death particles\n        for (var i = 0; i < 20; i++) {\n            var angle = (i / 20) * Math.PI * 2;\n            var speed = 80 + Math.random() * 120;\n            var r = cause === 'lava' ? 255 : 255;\n            var g = cause === 'lava' ? 68 : 51;\n            var b = cause === 'lava' ? 0 : 102;\n            this.particles.spawn(\n                this.px, this.py,\n                Math.cos(angle) * speed, Math.sin(angle) * speed - 50,\n                0.5 + Math.random() * 0.3,\n                r, g, b, 4\n            );\n        }\n\n        // Save high score\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n            try { localStorage.setItem('lavarise_hs', '' + this.highScore); } catch(e) {}\n        }\n    };\n\n    State.prototype._spawnContent = function() {\n        // Spawn ahead of camera (negative Y is up)\n        var spawnAhead = this.camY - 500;\n        while (this.lastSpawnY > spawnAhead) {\n            this.lastSpawnY -= this.spawnInterval;\n\n            // Don't spawn obstacles during safe time\n            if (this.playTime > SAFE_TIME) {\n                var obstacleChance = 0.3 + 0.3 * this.difficultyLevel;\n                if (Math.random() < obstacleChance) {\n                    this._spawnObstacle(this.lastSpawnY);\n                }\n            }\n\n            // Always spawn coins (good density)\n            if (Math.random() < 0.5) {\n                this._spawnCoin(this.lastSpawnY + Math.random() * 60 - 30);\n            }\n\n            // Decrease spawn interval with difficulty\n            this.spawnInterval = 120 - 40 * this.difficultyLevel;\n        }\n    };\n\n    State.prototype._spawnLavaParticles = function(dt) {\n        if (!this._lavaParticleTimer) this._lavaParticleTimer = 0;\n        this._lavaParticleTimer += dt;\n        if (this._lavaParticleTimer < 0.05) return;\n        this._lavaParticleTimer = 0;\n\n        // Spawn bubbles along lava surface\n        var x = this.wallLeft + Math.random() * (this.wallRight - this.wallLeft);\n        this.particles.spawn(\n            x, this.lavaY,\n            (Math.random() - 0.5) * 30, -(20 + Math.random() * 40),\n            0.5 + Math.random() * 0.5,\n            255, Math.floor(40 + Math.random() * 60), 0, 4\n        );\n    };\n\n    State.prototype._cleanup = function() {\n        var below = this.lavaY + 100;\n        // Remove coins below lava\n        for (var i = this.coins.length - 1; i >= 0; i--) {\n            if (this.coins[i].y > below || this.coins[i].collected) {\n                this.coins.splice(i, 1);\n            }\n        }\n        // Remove obstacles below lava\n        for (var j = this.obstacles.length - 1; j >= 0; j--) {\n            if (this.obstacles[j].y > below) {\n                this.obstacles.splice(j, 1);\n            }\n        }\n    };\n\n    // -------------------------------------------------------\n    // Rendering\n    // -------------------------------------------------------\n\n    function Renderer() {}\n\n    Renderer.prototype.render = function(ctx, canvas, state) {\n        var cw = canvas.width;\n        var ch = canvas.height;\n\n        // Virtual coordinate mapping\n        var scale = cw / VIRTUAL_W;\n        var virtualH = ch / scale;\n        var offsetX = 0;\n\n        // Screen shake\n        var shakeX = 0, shakeY = 0;\n        if (state.shakeTimer > 0) {\n            shakeX = (Math.random() - 0.5) * state.shakeAmount * scale;\n            shakeY = (Math.random() - 0.5) * state.shakeAmount * scale;\n        }\n\n        ctx.save();\n        ctx.translate(shakeX, shakeY);\n\n        // Background gradient\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, COL_BG_BOT);\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(-10, -10, cw + 20, ch + 20);\n\n        // Background stars (parallax)\n        this._renderStars(ctx, cw, ch, state.camY);\n\n        // Walls\n        this._renderWalls(ctx, state, scale, offsetX, ch);\n\n        // Obstacles\n        this._renderObstacles(ctx, state, scale, offsetX);\n\n        // Coins\n        this._renderCoins(ctx, state, scale, offsetX);\n\n        // Player\n        if (state.pAlive) {\n            this._renderPlayer(ctx, state, scale, offsetX);\n        }\n\n        // Particles\n        state.particles.render(ctx, state.camY, scale, offsetX);\n\n        // Lava\n        this._renderLava(ctx, state, scale, offsetX, cw, ch);\n\n        // Popups\n        state.popups.render(ctx, state.camY, scale, offsetX);\n\n        ctx.restore();\n\n        // Flash overlay\n        if (state.flashAlpha > 0) {\n            ctx.globalAlpha = state.flashAlpha;\n            ctx.fillStyle = '#fff';\n            ctx.fillRect(0, 0, cw, ch);\n            ctx.globalAlpha = 1;\n        }\n\n        // HUD (not affected by shake)\n        this._renderHUD(ctx, cw, ch, state);\n    };\n\n    Renderer.prototype._renderStars = function(ctx, cw, ch, camY) {\n        // Simple deterministic stars\n        ctx.fillStyle = 'rgba(255,255,255,0.3)';\n        var seed = 42;\n        for (var i = 0; i < 40; i++) {\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sx = (seed % cw);\n            seed = (seed * 1103515245 + 12345) & 0x7fffffff;\n            var sy = (seed % (ch * 3));\n            var parallax = 0.05;\n            var screenY = (sy - camY * parallax) % (ch * 3);\n            if (screenY < 0) screenY += ch * 3;\n            if (screenY < ch) {\n                var size = 1 + (i % 3);\n                ctx.fillRect(sx, screenY, size, size);\n            }\n        }\n    };\n\n    Renderer.prototype._renderWalls = function(ctx, state, scale, offsetX, ch) {\n        var camY = state.camY;\n        var topY = 0;\n        var botY = ch;\n\n        // Left wall\n        var lwScreen = state.wallLeft * scale + offsetX;\n        var lwWidth = (WALL_THICKNESS) * scale;\n        ctx.fillStyle = COL_WALL_LEFT;\n        ctx.fillRect(lwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(lwScreen + lwWidth - 2 * scale, topY, 2 * scale, botY - topY);\n\n        // Right wall\n        var rwScreen = (state.wallRight - WALL_THICKNESS) * scale + offsetX;\n        ctx.fillStyle = COL_WALL_RIGHT;\n        ctx.fillRect(rwScreen, topY, lwWidth, botY - topY);\n        // Edge highlight\n        ctx.fillStyle = COL_WALL_EDGE;\n        ctx.fillRect(rwScreen, topY, 2 * scale, botY - topY);\n\n        // Wall bricks pattern\n        ctx.fillStyle = 'rgba(255,255,255,0.03)';\n        var brickH = 20 * scale;\n        var startBrickY = Math.floor(camY / 20) * 20;\n        for (var by = startBrickY; by < camY + ch / scale + 20; by += 20) {\n            var sy = (by - camY) * scale;\n            var offset = ((by / 20) % 2) * 10 * scale;\n            // Left wall bricks\n            for (var bx = lwScreen; bx < lwScreen + lwWidth; bx += 20 * scale) {\n                ctx.fillRect(bx + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(lwScreen, sy, lwWidth, 1);\n            // Right wall bricks\n            for (var bx2 = rwScreen; bx2 < rwScreen + lwWidth; bx2 += 20 * scale) {\n                ctx.fillRect(bx2 + offset, sy, 1, brickH);\n            }\n            ctx.fillRect(rwScreen, sy, lwWidth, 1);\n        }\n    };\n\n    Renderer.prototype._renderObstacles = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.obstacles.length; i++) {\n            var obs = state.obstacles[i];\n            var sx = obs.x * scale + offsetX;\n            var sy = (obs.y - camY) * scale;\n            var sw = obs.w * scale;\n            var sh = obs.h * scale;\n\n            if (sy < -50 || sy > ctx.canvas.height + 50) continue;\n\n            if (obs.type === 'spike') {\n                ctx.fillStyle = COL_SPIKE;\n                ctx.beginPath();\n                if (obs.side === 'left') {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                } else {\n                    ctx.moveTo(sx, sy + sh);\n                    ctx.lineTo(sx + sw, sy + sh);\n                    ctx.lineTo(sx + sw / 2, sy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                // Glow\n                ctx.shadowColor = COL_SPIKE;\n                ctx.shadowBlur = 6 * scale;\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            } else if (obs.type === 'platform') {\n                ctx.fillStyle = COL_PLATFORM;\n                ctx.fillRect(sx, sy, sw, sh);\n                // Top highlight\n                ctx.fillStyle = 'rgba(255,255,255,0.2)';\n                ctx.fillRect(sx, sy, sw, 2 * scale);\n            } else if (obs.type === 'crumble') {\n                if (obs.fallen) continue;\n                var alpha = obs.crumbling ? Math.max(0, 1 - obs.timer * 2) : 1;\n                ctx.globalAlpha = alpha;\n                ctx.fillStyle = COL_PLATFORM_CRUMBLE;\n                // Shake if crumbling\n                var crumbleShake = obs.crumbling ? (Math.random() - 0.5) * 4 * scale : 0;\n                ctx.fillRect(sx + crumbleShake, sy, sw, sh);\n                ctx.globalAlpha = 1;\n            }\n        }\n    };\n\n    Renderer.prototype._renderCoins = function(ctx, state, scale, offsetX) {\n        var camY = state.camY;\n        for (var i = 0; i < state.coins.length; i++) {\n            var c = state.coins[i];\n            if (c.collected) continue;\n            var sx = c.x * scale + offsetX;\n            var sy = (c.y + Math.sin(c.bobPhase) * 4 - camY) * scale;\n            var sr = COIN_RADIUS * scale;\n\n            if (sy < -30 || sy > ctx.canvas.height + 30) continue;\n\n            // Glow\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr * 2, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN_GLOW;\n            ctx.fill();\n\n            // Coin body\n            ctx.beginPath();\n            ctx.arc(sx, sy, sr, 0, Math.PI * 2);\n            ctx.fillStyle = COL_COIN;\n            ctx.fill();\n\n            // Shine\n            ctx.beginPath();\n            ctx.arc(sx - sr * 0.25, sy - sr * 0.25, sr * 0.4, 0, Math.PI * 2);\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.fill();\n        }\n    };\n\n    Renderer.prototype._renderPlayer = function(ctx, state, scale, offsetX) {\n        var sx = state.px * scale + offsetX;\n        var sy = (state.py - state.camY) * scale;\n        var sw = PLAYER_W * scale;\n        var sh = PLAYER_H * scale;\n\n        // Invincibility blink\n        if (state.pInvincible > 0 && Math.floor(state.pInvincible * 10) % 2 === 0) {\n            ctx.globalAlpha = 0.5;\n        }\n\n        // Squash-stretch\n        var squashX = 1 / state.pSquash;\n        var squashY = state.pSquash;\n\n        ctx.save();\n        ctx.translate(sx, sy);\n        ctx.scale(squashX, squashY);\n\n        // Body\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 8 * scale;\n        var bodyW = sw;\n        var bodyH = sh;\n        // Rounded rectangle body\n        var r = 4 * scale;\n        ctx.beginPath();\n        ctx.moveTo(-bodyW / 2 + r, -bodyH / 2);\n        ctx.lineTo(bodyW / 2 - r, -bodyH / 2);\n        ctx.quadraticCurveTo(bodyW / 2, -bodyH / 2, bodyW / 2, -bodyH / 2 + r);\n        ctx.lineTo(bodyW / 2, bodyH / 2 - r);\n        ctx.quadraticCurveTo(bodyW / 2, bodyH / 2, bodyW / 2 - r, bodyH / 2);\n        ctx.lineTo(-bodyW / 2 + r, bodyH / 2);\n        ctx.quadraticCurveTo(-bodyW / 2, bodyH / 2, -bodyW / 2, bodyH / 2 - r);\n        ctx.lineTo(-bodyW / 2, -bodyH / 2 + r);\n        ctx.quadraticCurveTo(-bodyW / 2, -bodyH / 2, -bodyW / 2 + r, -bodyH / 2);\n        ctx.closePath();\n        ctx.fill();\n        ctx.shadowBlur = 0;\n\n        // Eyes\n        var eyeOffX = state.pFacing * 3 * scale;\n        var eyeY = -3 * scale;\n        ctx.fillStyle = COL_PLAYER_EYE;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale, eyeY, 2.5 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils (look in movement direction)\n        ctx.fillStyle = '#222';\n        var pupilOff = state.pFacing * 1 * scale;\n        ctx.beginPath();\n        ctx.arc(eyeOffX - 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(eyeOffX + 2.5 * scale + pupilOff, eyeY, 1.2 * scale, 0, Math.PI * 2);\n        ctx.fill();\n\n        ctx.restore();\n        ctx.globalAlpha = 1;\n    };\n\n    Renderer.prototype._renderLava = function(ctx, state, scale, offsetX, cw, ch) {\n        var lavaScreenY = (state.lavaY - state.camY) * scale;\n        if (lavaScreenY > ch + 50) return;\n\n        var topY = Math.max(0, lavaScreenY - 10 * scale);\n\n        // Lava glow above surface\n        var glowGrad = ctx.createLinearGradient(0, topY - 60 * scale, 0, topY);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, COL_LAVA_GLOW);\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, topY - 60 * scale, cw, 60 * scale);\n\n        // Lava surface wave\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        ctx.lineTo(0, lavaScreenY);\n        var waveTime = state.playTime * 2;\n        for (var x = 0; x <= cw; x += 4) {\n            var waveY = lavaScreenY + Math.sin(x * 0.02 + waveTime) * 4 * scale +\n                                      Math.sin(x * 0.04 + waveTime * 1.3) * 2 * scale;\n            ctx.lineTo(x, waveY);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n\n        var lavaGrad = ctx.createLinearGradient(0, lavaScreenY, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.3, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Surface highlight\n        ctx.strokeStyle = '#ff8800';\n        ctx.lineWidth = 2 * scale;\n        ctx.beginPath();\n        for (var x2 = 0; x2 <= cw; x2 += 4) {\n            var waveY2 = lavaScreenY + Math.sin(x2 * 0.02 + waveTime) * 4 * scale +\n                                       Math.sin(x2 * 0.04 + waveTime * 1.3) * 2 * scale;\n            if (x2 === 0) ctx.moveTo(x2, waveY2);\n            else ctx.lineTo(x2, waveY2);\n        }\n        ctx.stroke();\n    };\n\n    Renderer.prototype._renderHUD = function(ctx, cw, ch, state) {\n        var pad = Math.max(12, cw * 0.03);\n        var fontSize = Math.max(16, Math.min(28, cw * 0.05));\n\n        // Score\n        ctx.fillStyle = COL_SCORE;\n        ctx.font = 'bold ' + Math.floor(fontSize) + 'px sans-serif';\n        ctx.textAlign = 'left';\n        ctx.fillText('' + Math.floor(state.score), pad, pad + fontSize);\n\n        // Height indicator\n        ctx.fillStyle = COL_HEIGHT;\n        ctx.font = Math.floor(fontSize * 0.6) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm', pad, pad + fontSize + fontSize * 0.7);\n\n        // Coin streak\n        if (state.coinStreak > 1 && state.coinStreakTimer > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(fontSize * 0.8) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.globalAlpha = Math.min(1, state.coinStreakTimer);\n            ctx.fillText('x' + state.coinStreak, cw - pad, pad + fontSize);\n            ctx.globalAlpha = 1;\n        }\n\n        // High score (small, top right)\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.4)';\n            ctx.font = Math.floor(fontSize * 0.5) + 'px sans-serif';\n            ctx.textAlign = 'right';\n            ctx.fillText('BEST: ' + state.highScore, cw - pad, pad + fontSize * 0.5);\n        }\n\n        // Lava proximity warning\n        var lavaDist = state.py - state.lavaY;\n        if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {\n            var warnAlpha = (1 - lavaDist / 150) * 0.3;\n            ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';\n            ctx.fillRect(0, ch - ch * 0.15, cw, ch * 0.15);\n        }\n    };\n\n    // -------------------------------------------------------\n    // Menu / Game Over rendering\n    // -------------------------------------------------------\n\n    Renderer.prototype.renderMenu = function(ctx, cw, ch, state, time) {\n        // Background\n        var bgGrad = ctx.createLinearGradient(0, 0, 0, ch);\n        bgGrad.addColorStop(0, COL_BG_TOP);\n        bgGrad.addColorStop(1, '#1a0505');\n        ctx.fillStyle = bgGrad;\n        ctx.fillRect(0, 0, cw, ch);\n\n        // Decorative lava at bottom\n        var lavaH = ch * 0.25;\n        var lavaTop = ch - lavaH;\n        ctx.beginPath();\n        ctx.moveTo(0, ch);\n        for (var x = 0; x <= cw; x += 4) {\n            var wy = lavaTop + Math.sin(x * 0.015 + time * 2) * 8 + Math.sin(x * 0.03 + time * 1.5) * 4;\n            ctx.lineTo(x, wy);\n        }\n        ctx.lineTo(cw, ch);\n        ctx.closePath();\n        var lavaGrad = ctx.createLinearGradient(0, lavaTop, 0, ch);\n        lavaGrad.addColorStop(0, COL_LAVA_TOP);\n        lavaGrad.addColorStop(0.5, COL_LAVA_MID);\n        lavaGrad.addColorStop(1, COL_LAVA_BOT);\n        ctx.fillStyle = lavaGrad;\n        ctx.fill();\n\n        // Glow\n        var glowGrad = ctx.createLinearGradient(0, lavaTop - ch * 0.1, 0, lavaTop);\n        glowGrad.addColorStop(0, 'rgba(255,68,0,0)');\n        glowGrad.addColorStop(1, 'rgba(255,68,0,0.3)');\n        ctx.fillStyle = glowGrad;\n        ctx.fillRect(0, lavaTop - ch * 0.1, cw, ch * 0.1);\n\n        // Title\n        var titleSize = Math.max(32, Math.min(64, cw * 0.12));\n        var centerY = ch * 0.32;\n        ctx.fillStyle = COL_LAVA_TOP;\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.shadowColor = '#ff4400';\n        ctx.shadowBlur = 20;\n        ctx.fillText('LAVA RISE', cw / 2, centerY);\n        ctx.shadowBlur = 0;\n\n        // Subtitle\n        ctx.fillStyle = COL_PLAYER;\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText('Wall-jump to survive!', cw / 2, centerY + titleSize * 0.55);\n\n        // Tap prompt (pulsing)\n        var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n        ctx.globalAlpha = pulseAlpha;\n        ctx.fillStyle = '#ffffff';\n        ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n        ctx.fillText('TAP TO START', cw / 2, ch * 0.55);\n        ctx.globalAlpha = 1;\n\n        // High score\n        if (state.highScore > 0) {\n            ctx.fillStyle = 'rgba(255,255,255,0.5)';\n            ctx.font = Math.floor(titleSize * 0.3) + 'px sans-serif';\n            ctx.fillText('BEST: ' + state.highScore, cw / 2, ch * 0.65);\n        }\n\n        // Small player character preview (bouncing)\n        var previewY = ch * 0.44 + Math.sin(time * 2) * 8;\n        var ps = Math.max(1, cw / VIRTUAL_W);\n        ctx.fillStyle = COL_PLAYER;\n        ctx.shadowColor = COL_PLAYER;\n        ctx.shadowBlur = 10;\n        var pw = PLAYER_W * ps;\n        var ph = PLAYER_H * ps;\n        ctx.fillRect(cw / 2 - pw / 2, previewY - ph / 2, pw, ph);\n        ctx.shadowBlur = 0;\n        // Eyes\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(cw / 2 - 2 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.arc(cw / 2 + 3 * ps, previewY - 2 * ps, 2.5 * ps, 0, Math.PI * 2);\n        ctx.fill();\n    };\n\n    Renderer.prototype.renderGameOver = function(ctx, cw, ch, state, time, canRestart) {\n        // Darken\n        ctx.fillStyle = 'rgba(0,0,0,0.7)';\n        ctx.fillRect(0, 0, cw, ch);\n\n        var titleSize = Math.max(28, Math.min(56, cw * 0.1));\n        var centerY = ch * 0.3;\n\n        // Game over text\n        ctx.fillStyle = '#ff3333';\n        ctx.font = 'bold ' + Math.floor(titleSize) + 'px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText('GAME OVER', cw / 2, centerY);\n\n        // Score\n        ctx.fillStyle = '#ffffff';\n        ctx.font = 'bold ' + Math.floor(titleSize * 0.7) + 'px sans-serif';\n        ctx.fillText('' + Math.floor(state.score), cw / 2, centerY + titleSize * 0.9);\n\n        // Height and coins\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = Math.floor(titleSize * 0.35) + 'px sans-serif';\n        ctx.fillText(state.heightScore + 'm  |  ' + state.coinScore + ' coins', cw / 2, centerY + titleSize * 1.4);\n\n        // New high score?\n        if (state.score >= state.highScore && state.score > 0) {\n            ctx.fillStyle = COL_COIN;\n            ctx.font = 'bold ' + Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('NEW BEST!', cw / 2, centerY + titleSize * 1.9);\n        }\n\n        // Restart prompt\n        if (canRestart) {\n            var pulseAlpha = 0.5 + Math.sin(time * 3) * 0.3;\n            ctx.globalAlpha = pulseAlpha;\n            ctx.fillStyle = '#ffffff';\n            ctx.font = Math.floor(titleSize * 0.4) + 'px sans-serif';\n            ctx.fillText('TAP TO RETRY', cw / 2, ch * 0.65);\n            ctx.globalAlpha = 1;\n        }\n    };\n\n    // -------------------------------------------------------\n    // Public API\n    // -------------------------------------------------------\n    return {\n        State: State,\n        Renderer: Renderer,\n        SFX: SFX,\n        GAME_OVER_LOCKOUT: GAME_OVER_LOCKOUT\n    };\n\n})();\n","structuredPatch":[{"oldStart":1144,"oldLines":7,"newStart":1144,"newLines":7,"lines":["         }"," ","         // Lava proximity warning","-        var lavaDist = state.py - state.lavaY;","+        var lavaDist = state.lavaY - state.py;","         if (lavaDist < 150 && lavaDist > 0 && state.pAlive) {","             var warnAlpha = (1 - lavaDist / 150) * 0.3;","             ctx.fillStyle = 'rgba(255,68,0,' + warnAlpha + ')';"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01ETN8e39QsowNVJ5XurX7dQ","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also check the lava death check more carefully. Player at py=-500 climbing up. Lava at lavaY=-400 rising. When lava catches player: lavaY becomes <= py. Death check is `this.py > this.lavaY - PLAYER_H/2`. If py=-500 and lavaY=-510: `py > lavaY - 12` => `-500 > -522` => true. But lava at -510 is ABOVE the player at -500 (more negative = higher). That's wrong - lava passed through the player already.\n\nActually wait: if lava is at -510 (above) and player at -500 (below), the player is IN the lava, so death is correct. The lava surface is at -510 meaning everything from -510 downward (toward +inf) is lava. The player at -500 is below the surface, so they're in lava. The check `py > lavaY - PLAYER_H/2` is checking if the player's center is below the lava surface minus a small offset, which is correct.\n\nBut let me reconsider: `lavaY - PLAYER_H/2 = -510 - 12 = -522`. Is `-500 > -522`? Yes, so player dies. This is correct - the player's bottom would be at `py + PLAYER_H/2 = -500 + 12 = -488`, and lava is at -510, so the player's bottom is definitely in the lava zone. Good.\n\nNow let me think about a more subtle issue: the `WALL_GAP_MAX = 400` equals `VIRTUAL_W = 400`. That means `wallLeft = (400 - 400) / 2 = 0` and `wallRight = (400 + 400) / 2 = 400`. The wall thickness is 40, so the left wall goes from 0 to 40, right wall from 360 to 400. Playable area is 40 to 360 = 320 units. As difficulty increases, gap narrows to 220, so wallLeft = 90, wallRight = 310. Walls go from 90 to 130 and 270 to 310. Playable is 130 to 270 = 140 units. This all makes sense.\n\nThe player width is 18, so the player fits comfortably. Jump VX of 400 means crossing 320 units takes about 0.8s at the start - that's a good arc duration with the gravity. At max difficulty, 140 units takes about 0.35s - fast but still controllable.\n\nOne issue I want to check: the `_spawnCoin` function. `gap - WALL_THICKNESS * 2` could give the inner playable area for coin positioning. At max gap=400: `400 - 80 = 320`. The coin x = `wl + 40 + random * 320`. With wl=0, that's 40 to 360. At min gap=220: `220 - 80 = 140`. With wl=90, that's 130 to 270. Both are within the playable area. Good.\n\nLet me also check the platform spawn area calculation to make sure it doesn't produce negative widths:\n\nAt min gap: `wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40 = 310 - 90 - 80 - 50 - 40 = 50`. So `px = 130 + 20 + random * 50 = 150 to 200`. Platform goes from 150-200 to 200-250 (plus PLATFORM_W=50). With max x at 200+50=250, which is within 130-270. Good.\n\nAt max gap: `400 - 0 - 80 - 50 - 40 = 230`. So `px = 40 + 20 + random * 230 = 60 to 290`. Platform 60 to 110 or 290 to 340. Both within 40-360. Good.\n\nNow let me think about the input flow. The `input.js` uses `click` events for tapping. On mobile, `touchstart` fires first, then `click` fires after a delay. Both are bound. The `wasTapped()` returns true if either fired this frame. The `endFrame()` clears it. Since both `touchstart` and `click` set `_tapped = true`, and they happen in the same frame... actually `touchstart` happens immediately but `click` happens ~300ms later on mobile. So on mobile, `wasTapped()` would fire on the `touchstart` frame (good, responsive), and then again on the `click` frame (which would cause a double-jump issue).\n\nLet me check the input code again. The `touchstart` handler sets `_tapped = true`, and `endFrame()` clears it. The `click` that comes 300ms later would set `_tapped = true` again in a later frame. This means on mobile, each tap would register twice - once immediately (touchstart) and once ~300ms later (click).\n\nThis is a problem. I need to handle this in the input manager or in my game code. Since the instructions say to keep `input.js` as-is unless I have a specific reason, and this IS a specific reason (double-jump on mobile), let me add a debounce in input.js:\n\nActually, looking more carefully at the input.js code: the `click` event on canvas and the `touchstart` event on canvas are both bound. On mobile, a touch produces both `touchstart` AND `click`. The click comes ~300ms later. This will cause a double tap detection.\n\nBut wait - in a wall-jump game, the player must be on a wall to jump. After the first tap (touchstart), the player is in the air. The delayed click arrives while in air, so `pOnWall === 'air'` and the jump won't fire. So the double-tap isn't actually a gameplay problem for the jump mechanic. But it IS a problem for menu/gameover transitions (could cause skipping menu straight into game, etc). However, the menu transition happens in one frame and changes state to 'playing', so the delayed click would just register as a tap in the playing state which gets consumed by the air check.\n\nActually there's a subtler issue: what if you tap to start the game from menu, the touchstart fires, state becomes 'playing', and then the click fires 300ms later and causes a jump? That's one free jump, which is actually fine since the player starts on a wall.\n\nFor the game over screen, the 0.8s lockout protects against accidental restart. The touchstart would trigger first, and if lockout hasn't expired, nothing happens. The click 300ms later would also be within lockout if it hasn't expired.\n\nI think this is fine as-is. The worst case is one extra tap being consumed, which doesn't cause problems.\n\nLet me now do one final review to make sure the coin spawning in the playable area is correct and check for any other issues:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":302,"cache_read_input_tokens":80891,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":302},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"0e5b54cc-48e7-4c4a-9ee4-b7ff9c5a3a93"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01ETN8e39QsowNVJ5XurX7dQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mj7mBkz83bQyyhEMvyih49","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","offset":379,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":302,"cache_read_input_tokens":80891,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":302},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"560fcbfd-89e5-419c-b579-52589f31cf6f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mj7mBkz83bQyyhEMvyih49","type":"tool_result","content":"   379â†’    State.prototype._spawnCoin = function(y) {\n   380â†’        var gap = this._getWallGap();\n   381â†’        var wl = this._getWallLeft();\n   382â†’        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n   383â†’        this.coins.push({\n   384â†’            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n   385â†’        });\n   386â†’    };\n   387â†’\n   388â†’    State.prototype._spawnObstacle = function(y) {\n   389â†’        var type = Math.random();\n   390â†’        var wl = this._getWallLeft();\n   391â†’        var wr = this._getWallRight();\n   392â†’\n   393â†’        if (type < 0.4) {\n   394â†’            // Spike on wall\n   395â†’            var side = Math.random() < 0.5 ? 'left' : 'right';\n   396â†’            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n   397â†’            this.obstacles.push({\n   398â†’                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n   399â†’            });\n   400â†’        } else if (type < 0.7) {\n   401â†’            // Moving platform\n   402â†’            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n   403â†’            var speed = 40 + Math.random() * 60;\n   404â†’            this.obstacles.push({\n   405â†’                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n   406â†’                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n   407â†’                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n   408â†’            });"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"5e48d814-f0c0-44e3-8768-3b2f10d7d9eb","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\js\\lava-rise.js","content":"    State.prototype._spawnCoin = function(y) {\n        var gap = this._getWallGap();\n        var wl = this._getWallLeft();\n        var cx = wl + WALL_THICKNESS + Math.random() * (gap - WALL_THICKNESS * 2);\n        this.coins.push({\n            x: cx, y: y, collected: false, bobPhase: Math.random() * Math.PI * 2\n        });\n    };\n\n    State.prototype._spawnObstacle = function(y) {\n        var type = Math.random();\n        var wl = this._getWallLeft();\n        var wr = this._getWallRight();\n\n        if (type < 0.4) {\n            // Spike on wall\n            var side = Math.random() < 0.5 ? 'left' : 'right';\n            var sx = side === 'left' ? wl + WALL_THICKNESS : wr - WALL_THICKNESS - SPIKE_W;\n            this.obstacles.push({\n                type: 'spike', x: sx, y: y, w: SPIKE_W, h: SPIKE_H, side: side\n            });\n        } else if (type < 0.7) {\n            // Moving platform\n            var px = wl + WALL_THICKNESS + 20 + Math.random() * (wr - wl - WALL_THICKNESS * 2 - PLATFORM_W - 40);\n            var speed = 40 + Math.random() * 60;\n            this.obstacles.push({\n                type: 'platform', x: px, y: y, w: PLATFORM_W, h: PLATFORM_H,\n                origX: px, speed: speed, dir: Math.random() < 0.5 ? 1 : -1,\n                minX: wl + WALL_THICKNESS + 5, maxX: wr - WALL_THICKNESS - PLATFORM_W - 5\n            });","numLines":30,"startLine":379,"totalLines":1296}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01CCPsN19pnvcPAk4bAUCnc5","type":"message","role":"assistant","content":[{"type":"text","text":"Everything looks solid. Let me verify the final `index.html` and files are all consistent:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2368,"cache_read_input_tokens":81193,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2368},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"4512410c-9f84-43bb-b46f-fd4e5a422cb0"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01CCPsN19pnvcPAk4bAUCnc5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VaMFZ4ZaPR7A15K2RyCvMK","name":"Read","input":{"file_path":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2368,"cache_read_input_tokens":81193,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2368},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"cebd22e5-5abb-4c6d-b92c-1890fdad29c1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VaMFZ4ZaPR7A15K2RyCvMK","type":"tool_result","content":"     1â†’<!DOCTYPE html>\n     2â†’<html lang=\"en\">\n     3â†’<head>\n     4â†’    <meta charset=\"UTF-8\">\n     5â†’    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n     6â†’    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n     7â†’    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n     8â†’    <title>Lava Rise</title>\n     9â†’    <link rel=\"stylesheet\" href=\"css/styles.css\">\n    10â†’</head>\n    11â†’<body>\n    12â†’    <div id=\"game-container\">\n    13â†’        <canvas id=\"game-canvas\"></canvas>\n    14â†’    </div>\n    15â†’\n    16â†’    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    17â†’    <script src=\"js/poki.js\"></script>\n    18â†’    <script src=\"js/audio.js\"></script>\n    19â†’    <script src=\"js/lava-rise.js\"></script>\n    20â†’    <script type=\"module\" src=\"js/main.js\"></script>\n    21â†’</body>\n    22â†’</html>\n    23â†’"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"10680d89-f72b-4182-9b26-b3c3b6e49915","tool_use_result":{"type":"text","file":{"filePath":"F:\\experiments\\ClaudeOnClaude\\poki-tests\\lava_rise\\index.html","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <title>Lava Rise</title>\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n</head>\n<body>\n    <div id=\"game-container\">\n        <canvas id=\"game-canvas\"></canvas>\n    </div>\n\n    <script src=\"https://game-cdn.poki.com/scripts/v2/poki-sdk.js\"></script>\n    <script src=\"js/poki.js\"></script>\n    <script src=\"js/audio.js\"></script>\n    <script src=\"js/lava-rise.js\"></script>\n    <script type=\"module\" src=\"js/main.js\"></script>\n</body>\n</html>\n","numLines":23,"startLine":1,"totalLines":23}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_018vhGL3kcJ4MAwXLabC78Fo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FfBHQoBXVyHzUVgMsGyj97","name":"TodoWrite","input":{"todos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"completed","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"completed","activeForm":"Updating index.html with new script tag"},{"content":"Review and polish the complete game","status":"completed","activeForm":"Reviewing and polishing the game"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":449,"cache_read_input_tokens":83561,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":449},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"8e2ea6e4-b1b3-4b70-a821-06b1f9e642b6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FfBHQoBXVyHzUVgMsGyj97","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"efbe291c-0652-4942-831a-157e756c3d1f","tool_use_result":{"oldTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"completed","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"completed","activeForm":"Updating index.html with new script tag"},{"content":"Review and polish the complete game","status":"in_progress","activeForm":"Reviewing and polishing the game"}],"newTodos":[{"content":"Create js/lava-rise.js with all game systems","status":"completed","activeForm":"Creating lava-rise.js with all game systems"},{"content":"Modify js/game.js to integrate LavaRise systems","status":"completed","activeForm":"Modifying game.js to integrate LavaRise"},{"content":"Update index.html to include lava-rise.js script tag","status":"completed","activeForm":"Updating index.html with new script tag"},{"content":"Review and polish the complete game","status":"completed","activeForm":"Reviewing and polishing the game"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_014RPVyA7gq8N9p36Y3CGTvG","type":"message","role":"assistant","content":[{"type":"text","text":"The game is fully implemented. Here's a summary of what was built:\n\n**Files modified:**\n- `index.html` - Title updated to \"Lava Rise\", added `lava-rise.js` script tag\n- `js/game.js` - Replaced demo code with LavaRise integration (state machine delegates to LavaRise.State and LavaRise.Renderer)\n\n**Files created:**\n- `js/lava-rise.js` (~1295 lines) - Complete game engine in a single IIFE\n\n**Key systems implemented:**\n\n| System | Details |\n|--------|---------|\n| **Player** | Wall-cling + instant tap-to-jump. Alternates walls with physics arcs (gravity 1400, jumpVY -520, jumpVX 400). Squash-stretch on jump/land. |\n| **Lava** | Rises from below, speed ramps 60->150 over 2 min. Animated wave surface with gradient + glow. Proximity warning (red tint + audio). |\n| **Walls** | Narrow from 400->220 gap via difficulty. Brick pattern texture. Purple with edge highlights. |\n| **Obstacles** | Spikes (triangle, instant kill), moving platforms (bounce between walls), crumbling ledges (0.5s timer + shake). |\n| **Coins** | Bobbing gold circles with glow. Collection triggers slow-mo (0.3s at 40%), particle burst, score popup. Streak multiplier (x1-x10). |\n| **Difficulty** | Single float 0->1 over 120s drives lava speed, wall gap, and obstacle spawn density. |\n| **Audio** | All procedural via Web Audio oscillators: jump (square chirp), wall hit (triangle thud), coin (sine + harmonic, pitch rises with streak), death (sawtooth + noise), lava warning (sine pulse). |\n| **Particles** | 200-pool pre-allocated. Jump trails, wall impact, coin burst, death explosion, lava bubbles. |\n| **Camera** | Smooth follow with velocity lead (0.3x). Screen shake on death. |\n| **Polish** | Invincibility blink for 5s safe start, 0.8s restart lockout, flash overlay on coin/death, HUD with score/height/streak/best, parallax stars. |\n| **Menus** | Animated lava at bottom, pulsing \"TAP TO START\", bouncing player preview, high score display. Game over shows score breakdown + \"NEW BEST!\" |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":252,"cache_read_input_tokens":84010,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":252},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","uuid":"b915c9ea-649b-4fea-b26a-bd322d22ba12"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":352992,"duration_api_ms":352082,"num_turns":25,"result":"The game is fully implemented. Here's a summary of what was built:\n\n**Files modified:**\n- `index.html` - Title updated to \"Lava Rise\", added `lava-rise.js` script tag\n- `js/game.js` - Replaced demo code with LavaRise integration (state machine delegates to LavaRise.State and LavaRise.Renderer)\n\n**Files created:**\n- `js/lava-rise.js` (~1295 lines) - Complete game engine in a single IIFE\n\n**Key systems implemented:**\n\n| System | Details |\n|--------|---------|\n| **Player** | Wall-cling + instant tap-to-jump. Alternates walls with physics arcs (gravity 1400, jumpVY -520, jumpVX 400). Squash-stretch on jump/land. |\n| **Lava** | Rises from below, speed ramps 60->150 over 2 min. Animated wave surface with gradient + glow. Proximity warning (red tint + audio). |\n| **Walls** | Narrow from 400->220 gap via difficulty. Brick pattern texture. Purple with edge highlights. |\n| **Obstacles** | Spikes (triangle, instant kill), moving platforms (bounce between walls), crumbling ledges (0.5s timer + shake). |\n| **Coins** | Bobbing gold circles with glow. Collection triggers slow-mo (0.3s at 40%), particle burst, score popup. Streak multiplier (x1-x10). |\n| **Difficulty** | Single float 0->1 over 120s drives lava speed, wall gap, and obstacle spawn density. |\n| **Audio** | All procedural via Web Audio oscillators: jump (square chirp), wall hit (triangle thud), coin (sine + harmonic, pitch rises with streak), death (sawtooth + noise), lava warning (sine pulse). |\n| **Particles** | 200-pool pre-allocated. Jump trails, wall impact, coin burst, death explosion, lava bubbles. |\n| **Camera** | Smooth follow with velocity lead (0.3x). Screen shake on death. |\n| **Polish** | Invincibility blink for 5s safe start, 0.8s restart lockout, flash overlay on coin/death, HUD with score/height/streak/best, parallax stars. |\n| **Menus** | Animated lava at bottom, pulsing \"TAP TO START\", bouncing player preview, high score display. Game over shows score breakdown + \"NEW BEST!\" |","stop_reason":null,"session_id":"49ae1741-8f7d-46af-8795-41b99d501708","total_cost_usd":1.5554402499999995,"usage":{"input_tokens":20,"cache_creation_input_tokens":62579,"cache_read_input_tokens":1133943,"output_tokens":23890,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":62579,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]},"modelUsage":{"claude-opus-4-6":{"inputTokens":20,"outputTokens":23890,"cacheReadInputTokens":1133943,"cacheCreationInputTokens":62579,"webSearchRequests":0,"costUSD":1.5554402499999995,"contextWindow":200000,"maxOutputTokens":32000}},"permission_denials":[],"uuid":"99f706d9-4bcd-45ca-80d6-13d8ebc24be5"}


=== STDERR ===
